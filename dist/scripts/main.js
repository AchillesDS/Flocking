/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/css-loader/index.js!../node_modules/postcss-loader/lib/index.js??ref--5-2!../node_modules/less-loader/dist/cjs.js!./src/main.less":
/*!***************************************************************************************************************************************!*\
  !*** ../node_modules/css-loader!../node_modules/postcss-loader/lib??ref--5-2!../node_modules/less-loader/dist/cjs.js!./src/main.less ***!
  \***************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ \"../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"* {\\n  margin: 0;\\n  padding: 0;\\n}\\nhtml,\\nbody {\\n  width: 100%;\\n  height: 100%;\\n}\\nbody {\\n  max-width: 750px;\\n  margin: 0 auto;\\n}\\n\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5sZXNzP2ZmNTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSw0QkFBNkIsY0FBYyxlQUFlLEdBQUcsZUFBZSxnQkFBZ0IsaUJBQWlCLEdBQUcsUUFBUSxxQkFBcUIsbUJBQW1CLEdBQUc7O0FBRW5LIiwiZmlsZSI6Ii4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tNS0yIS4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3NyYy9tYWluLmxlc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIioge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG59XFxuaHRtbCxcXG5ib2R5IHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbn1cXG5ib2R5IHtcXG4gIG1heC13aWR0aDogNzUwcHg7XFxuICBtYXJnaW46IDAgYXV0bztcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/css-loader/index.js!../node_modules/postcss-loader/lib/index.js??ref--5-2!../node_modules/less-loader/dist/cjs.js!./src/main.less\n");

/***/ }),

/***/ "../node_modules/css-loader/lib/css-base.js":
/*!**************************************************!*\
  !*** ../node_modules/css-loader/lib/css-base.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzPzdiNGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYzs7QUFFbEU7QUFDQSIsImZpbGUiOiIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/css-loader/lib/css-base.js\n");

/***/ }),

/***/ "../node_modules/style-loader/lib/addStyles.js":
/*!*****************************************************!*\
  !*** ../node_modules/style-loader/lib/addStyles.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target) {\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"../node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertInto + \" \" + options.insertAt.before);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzPzUxZWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0EsbUJBQW1CLDJCQUEyQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTs7QUFFQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkLGtEQUFrRCxzQkFBc0I7QUFDeEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQSw2QkFBNkIsbUJBQW1COztBQUVoRDs7QUFFQTs7QUFFQTtBQUNBIiwiZmlsZSI6Ii4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG59O1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcGFzc2luZyBmdW5jdGlvbiBpbiBvcHRpb25zLCB0aGVuIHVzZSBpdCBmb3IgcmVzb2x2ZSBcImhlYWRcIiBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIFVzZWZ1bCBmb3IgU2hhZG93IFJvb3Qgc3R5bGUgaS5lXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICAgaW5zZXJ0SW50bzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmb29cIikuc2hhZG93Um9vdCB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR2YXIgc3R5bGVUYXJnZXQgPSBnZXRUYXJnZXQuY2FsbCh0aGlzLCB0YXJnZXQpO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblx0XHRcdGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuXHRcdFx0XHRcdC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcblx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lbW9bdGFyZ2V0XVxuXHR9O1xufSkoKTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSBcImJvb2xlYW5cIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcbiAgICAgICAgaWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKSB7XG5cdFx0dmFyIG5leHRTaWJsaW5nID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8gKyBcIiBcIiArIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKTtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0U2libGluZyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiW1N0eWxlIExvYWRlcl1cXG5cXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXFxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXFxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcXG5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0aWYob3B0aW9ucy5hdHRycy50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH1cblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/style-loader/lib/addStyles.js\n");

/***/ }),

/***/ "../node_modules/style-loader/lib/urls.js":
/*!************************************************!*\
  !*** ../node_modules/style-loader/lib/urls.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qcz85NDMyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVyxFQUFFO0FBQ3JELHdDQUF3QyxXQUFXLEVBQUU7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0NBQXNDO0FBQ3RDLEdBQUc7QUFDSDtBQUNBLDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EiLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvfFxccyokKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/style-loader/lib/urls.js\n");

/***/ }),

/***/ "./node_modules/.1.2.9@cax/dist/cax.js":
/*!*********************************************!*\
  !*** ./node_modules/.1.2.9@cax/dist/cax.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n *  cax v1.2.9\r\n *  By https://github.com/dntzhang \r\n *  Github: https://github.com/dntzhang/cax\r\n *  MIT Licensed.\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 16);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _graphics = __webpack_require__(4);\n\nvar _graphics2 = _interopRequireDefault(_graphics);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Shape = function (_Graphics) {\n  _inherits(Shape, _Graphics);\n\n  function Shape() {\n    _classCallCheck(this, Shape);\n\n    return _possibleConstructorReturn(this, (Shape.__proto__ || Object.getPrototypeOf(Shape)).apply(this, arguments));\n  }\n\n  _createClass(Shape, [{\n    key: 'draw',\n\n    // constructor() {\n    //     super()\n    // }\n\n    value: function draw() {}\n  }, {\n    key: 'render',\n    value: function render(ctx) {\n      this.clear();\n      this.draw();\n      _get(Shape.prototype.__proto__ || Object.getPrototypeOf(Shape.prototype), 'render', this).call(this, ctx);\n    }\n  }]);\n\n  return Shape;\n}(_graphics2.default);\n\nexports.default = Shape;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _displayObject = __webpack_require__(3);\n\nvar _displayObject2 = _interopRequireDefault(_displayObject);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Group = function (_DisplayObject) {\n  _inherits(Group, _DisplayObject);\n\n  function Group(data) {\n    _classCallCheck(this, Group);\n\n    var _this = _possibleConstructorReturn(this, (Group.__proto__ || Object.getPrototypeOf(Group)).call(this, data));\n\n    _this.children = [];\n    return _this;\n  }\n\n  _createClass(Group, [{\n    key: 'add',\n    value: function add(child) {\n      var len = arguments.length;\n\n      for (var i = 0; i < len; i++) {\n        var c = arguments[i];\n        var parent = c.parent;\n        if (parent) {\n          parent.removeChildAt(parent.children.indexOf(c));\n        }\n        this.children.push(c);\n        c.parent = this;\n      }\n    }\n  }, {\n    key: 'addChildAt',\n    value: function addChildAt(child, index) {\n      var par = child.parent;\n      par && par.removeChildAt(par.children.indexOf(child));\n      child.parent = this;\n      this.children.splice(index, 0, child);\n    }\n  }, {\n    key: 'removeChildAt',\n    value: function removeChildAt(index) {\n      var child = this.children[index];\n      if (child) {\n        child.parent = null;\n      }\n      this.children.splice(index, 1);\n    }\n  }, {\n    key: 'replace',\n    value: function replace(current, pre) {\n      var index = pre.parent.children.indexOf(pre);\n      this.removeChildAt(index);\n      this.addChildAt(current, index);\n    }\n  }, {\n    key: 'remove',\n    value: function remove(child) {\n      var len = arguments.length;\n      var cLen = this.children.length;\n\n      for (var i = 0; i < len; i++) {\n        for (var j = 0; j < cLen; j++) {\n          if (child.id === this.children[j].id) {\n            child.parent = null;\n            this.children.splice(j, 1);\n            j--;\n            cLen--;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'empty',\n    value: function empty() {\n      this.children.forEach(function (child) {\n        child.parent = null;\n      });\n      this.children.length = 0;\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.empty();\n      // Stage does not have a parent\n      this.parent && _get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'destroy', this).call(this);\n    }\n  }]);\n\n  return Group;\n}(_displayObject2.default);\n\nexports.default = Group;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _displayObject = __webpack_require__(3);\n\nvar _displayObject2 = _interopRequireDefault(_displayObject);\n\nvar _util = __webpack_require__(9);\n\nvar _util2 = _interopRequireDefault(_util);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Bitmap = function (_DisplayObject) {\n  _inherits(Bitmap, _DisplayObject);\n\n  function Bitmap(img, onLoad) {\n    _classCallCheck(this, Bitmap);\n\n    var _this = _possibleConstructorReturn(this, (Bitmap.__proto__ || Object.getPrototypeOf(Bitmap)).call(this));\n\n    if (typeof img === 'string') {\n      if (Bitmap.cache[img]) {\n        if (_util2.default.isWeapp) {\n          _this.img = Bitmap.cache[img].img;\n          _this.rect = [0, 0, Bitmap.cache[img].width, Bitmap.cache[img].height];\n          _this.width = _this.rect[2];\n          _this.height = _this.rect[3];\n        } else {\n          _this.img = Bitmap.cache[img];\n          _this.rect = [0, 0, _this.img.width, _this.img.height];\n          _this.width = _this.img.width;\n          _this.height = _this.img.height;\n        }\n        onLoad && onLoad.call(_this);\n      } else if (_util2.default.isWeapp) {\n        _util2.default.getImageInWx(img, function (result) {\n          _this.img = result.img;\n          if (!_this.rect) {\n            _this.rect = [0, 0, result.width, result.height];\n          }\n          _this.width = result.width;\n          _this.height = result.height;\n          onLoad && onLoad.call(_this);\n          Bitmap.cache[img] = result;\n        });\n      } else {\n        _this.img = _util2.default.isWegame ? wx.createImage() : new window.Image();\n        _this.visible = false;\n        _this.img.onload = function () {\n          _this.visible = true;\n          if (!_this.rect) {\n            _this.rect = [0, 0, _this.img.width, _this.img.height];\n          }\n          _this.width = _this.img.width;\n          _this.height = _this.img.height;\n          onLoad && onLoad.call(_this);\n          Bitmap.cache[img] = _this.img;\n        };\n        _this.img.src = img;\n      }\n    } else {\n      _this.img = img;\n      _this.rect = [0, 0, img.width, img.height];\n      _this.width = img.width;\n      _this.height = img.height;\n      Bitmap.cache[img.src] = img;\n    }\n    return _this;\n  }\n\n  _createClass(Bitmap, [{\n    key: 'clone',\n    value: function clone() {\n      // 复制完img宽度0？？所以直接传字符串\n      var bitmap = new Bitmap(typeof this.img === 'string' ? this.img : this.img.src);\n      bitmap.x = this.x;\n      bitmap.y = this.y;\n      bitmap.scaleX = this.scaleX;\n      bitmap.scaleY = this.scaleY;\n      bitmap.rotation = this.rotation;\n      bitmap.skewX = this.skewX;\n      bitmap.skewY = this.skewY;\n      bitmap.originX = this.originX;\n      bitmap.originY = this.originY;\n      bitmap.width = this.width;\n      bitmap.height = this.height;\n      bitmap.cursor = this.cursor;\n\n      return bitmap;\n    }\n  }]);\n\n  return Bitmap;\n}(_displayObject2.default);\n\nBitmap.cache = {};\n\nexports.default = Bitmap;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _matrix2d = __webpack_require__(21);\n\nvar _matrix2d2 = _interopRequireDefault(_matrix2d);\n\nvar _eventDispatcher = __webpack_require__(22);\n\nvar _eventDispatcher2 = _interopRequireDefault(_eventDispatcher);\n\nvar _uid = __webpack_require__(23);\n\nvar _uid2 = _interopRequireDefault(_uid);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar DisplayObject = function (_EventDispatcher) {\n  _inherits(DisplayObject, _EventDispatcher);\n\n  function DisplayObject() {\n    _classCallCheck(this, DisplayObject);\n\n    var _this = _possibleConstructorReturn(this, (DisplayObject.__proto__ || Object.getPrototypeOf(DisplayObject)).call(this));\n\n    _this.alpha = _this.complexAlpha = _this.scaleX = _this.scaleY = 1;\n    _this.x = _this.y = _this.rotation = _this.skewX = _this.skewY = _this.originX = _this.originY = 0;\n    _this.cursor = null;\n    _this.visible = true;\n    _this._matrix = new _matrix2d2.default();\n    _this._hitMatrix = new _matrix2d2.default();\n    _this.id = _uid2.default.get();\n    _this.clipGraphics = null;\n    _this.clipRuleNonzero = true;\n    _this.fixed = false;\n    _this.shadow = null;\n    _this.compositeOperation = null;\n    _this.absClipGraphics = null;\n    _this.absClipRuleNonzero = true;\n    _this.cacheUpdating = false;\n\n    try {\n      Object.defineProperties(_this, {\n        stage: { get: _this._getStage },\n        scale: {\n          get: function get() {\n            return this.scaleX;\n          },\n          set: function set(scale) {\n            this.scaleX = this.scaleY = scale;\n          }\n        }\n      });\n    } catch (e) {}\n    return _this;\n  }\n\n  _createClass(DisplayObject, [{\n    key: 'isVisible',\n    value: function isVisible() {\n      return this.visible && this.alpha > 0 && this.scaleX !== 0 && this.scaleY !== 0;\n    }\n  }, {\n    key: 'initAABB',\n    value: function initAABB() {\n      if (this.width === undefined || this.height === undefined) {\n        return;\n      }\n\n      var x = void 0,\n          y = void 0,\n          width = this.width,\n          height = this.height,\n          mtx = this._matrix,\n          xA = width * mtx.a,\n          xB = width * mtx.b,\n          yC = height * mtx.c,\n          yD = height * mtx.d,\n          tx = mtx.tx,\n          ty = mtx.ty,\n          minX = tx,\n          maxX = tx,\n          minY = ty,\n          maxY = ty;\n\n      if ((x = xA + tx) < minX) {\n        minX = x;\n      } else if (x > maxX) {\n        maxX = x;\n      }\n      if ((x = xA + yC + tx) < minX) {\n        minX = x;\n      } else if (x > maxX) {\n        maxX = x;\n      }\n      if ((x = yC + tx) < minX) {\n        minX = x;\n      } else if (x > maxX) {\n        maxX = x;\n      }\n      if ((y = xB + ty) < minY) {\n        minY = y;\n      } else if (y > maxY) {\n        maxY = y;\n      }\n      if ((y = xB + yD + ty) < minY) {\n        minY = y;\n      } else if (y > maxY) {\n        maxY = y;\n      }\n      if ((y = yD + ty) < minY) {\n        minY = y;\n      } else if (y > maxY) {\n        maxY = y;\n      }\n      this.AABB = [minX, minY, maxX - minX, maxY - minY];\n      this.rectPoints = [{\n        x: tx,\n        y: ty\n      }, {\n        x: xA + tx,\n        y: xB + ty\n      }, {\n        x: xA + yC + tx,\n        y: xB + yD + ty\n      }, {\n        x: yC + tx,\n        y: yD + ty\n      }];\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.parent.remove(this);\n    }\n  }, {\n    key: 'hover',\n    value: function hover(over, out, move) {\n      this.on('mouseover', over);\n      this.on('mouseout', out);\n      move && this.on('mousemove', move);\n    }\n\n    // https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/clip\n\n  }, {\n    key: 'clip',\n    value: function clip(graphics, notClipRuleNonzero) {\n      this.clipGraphics = graphics;\n      this.clipRuleNonzero = !notClipRuleNonzero;\n    }\n  }, {\n    key: 'unclip',\n    value: function unclip() {\n      this.clipGraphics = null;\n    }\n  }, {\n    key: 'absClip',\n    value: function absClip(graphics, notClipRuleNonzero) {\n      this.absClipGraphics = graphics;\n      this.absClipRuleNonzero = !notClipRuleNonzero;\n    }\n  }, {\n    key: 'unAbsClip',\n    value: function unAbsClip() {\n      this.absClipGraphics = null;\n    }\n  }, {\n    key: 'cache',\n    value: function cache(x, y, width, height, scale, cacheUpdating) {\n      this._cacheData = {\n        x: x || 0,\n        y: y || 0,\n        width: width || this.width,\n        height: height || this.height,\n        scale: scale || 1\n      };\n      this.cacheUpdating = cacheUpdating;\n      if (!this.cacheCanvas) {\n        if (typeof wx !== 'undefined' && wx.createCanvas) {\n          this.cacheCanvas = wx.createCanvas();\n        } else {\n          this.cacheCanvas = document.createElement('canvas');\n        }\n        this.cacheCtx = this.cacheCanvas.getContext('2d');\n      }\n      this.cacheCanvas.width = this._cacheData.width * this._cacheData.scale;\n      this.cacheCanvas.height = this._cacheData.height * this._cacheData.scale;\n\n      // debug cache canvas\n      // this.cacheCtx.fillRect(0,0,1000,1000)\n      this._readyToCache = true;\n    }\n  }, {\n    key: 'uncache',\n    value: function uncache() {\n      this.cacheCanvas = null;\n    }\n  }, {\n    key: 'filter',\n    value: function filter(filterName, filterBox) {\n      filterBox = Object.assign({}, {\n        x: 0,\n        y: 0,\n        width: this.width,\n        height: this.height\n      }, filterBox);\n      this.cache(filterBox.x, filterBox.y, filterBox.width, filterBox.height);\n      this._readyToFilter = true;\n      this._filterName = filterName;\n    }\n  }, {\n    key: 'setTransform',\n    value: function setTransform(x, y, scaleX, scaleY, rotation, skewX, skewY, originX, originY) {\n      this.x = x || 0;\n      this.y = y || 0;\n      this.scaleX = scaleX == null ? 1 : scaleX;\n      this.scaleY = scaleY == null ? 1 : scaleY;\n      this.rotation = rotation || 0;\n      this.skewX = skewX || 0;\n      this.skewY = skewY || 0;\n      this.originX = originX || 0;\n      this.originY = originY || 0;\n    }\n  }, {\n    key: 'setMatrix',\n    value: function setMatrix(a, b, c, d, tx, ty) {\n      _matrix2d2.default.decompose(a, b, c, d, tx, ty, this);\n    }\n  }, {\n    key: 'unfilter',\n    value: function unfilter() {\n      this.uncache();\n    }\n  }, {\n    key: '_getStage',\n    value: function _getStage() {\n      var o = this;\n      while (o.parent) {\n        o = o.parent;\n      }\n      if (o.___instanceof === 'Stage') {\n        return o;\n      }\n      return null;\n    }\n  }]);\n\n  return DisplayObject;\n}(_eventDispatcher2.default);\n\nexports.default = DisplayObject;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _displayObject = __webpack_require__(3);\n\nvar _displayObject2 = _interopRequireDefault(_displayObject);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar assMap = {\n  fillStyle: true,\n  strokeStyle: true,\n  lineWidth: true,\n  lineCap: true,\n  lineDashOffset: true,\n  lineJoin: true,\n  miterLimit: true\n};\n\nvar Graphics = function (_DisplayObject) {\n  _inherits(Graphics, _DisplayObject);\n\n  function Graphics() {\n    _classCallCheck(this, Graphics);\n\n    var _this = _possibleConstructorReturn(this, (Graphics.__proto__ || Object.getPrototypeOf(Graphics)).call(this));\n\n    _this.cmds = [];\n    _this.currentGradient = null;\n    return _this;\n  }\n\n  _createClass(Graphics, [{\n    key: 'clearRect',\n    value: function clearRect() {\n      this.cmds.push(['clearRect', arguments]);\n      return this;\n    }\n  }, {\n    key: 'rect',\n    value: function rect() {\n      this.cmds.push(['rect', arguments]);\n      return this;\n    }\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this.cmds.length = 0;\n      return this;\n    }\n  }, {\n    key: 'setLineDash',\n    value: function setLineDash() {\n      this.cmds.push(['setLineDash', arguments]);\n      return this;\n    }\n  }, {\n    key: 'strokeRect',\n    value: function strokeRect() {\n      this.cmds.push(['strokeRect', arguments]);\n      return this;\n    }\n  }, {\n    key: 'fillRect',\n    value: function fillRect() {\n      this.cmds.push(['fillRect', arguments]);\n      return this;\n    }\n  }, {\n    key: 'beginPath',\n    value: function beginPath() {\n      this.cmds.push(['beginPath', arguments]);\n      return this;\n    }\n  }, {\n    key: 'arc',\n    value: function arc() {\n      this.cmds.push(['arc', arguments]);\n      return this;\n    }\n  }, {\n    key: 'closePath',\n    value: function closePath() {\n      this.cmds.push(['closePath', arguments]);\n      return this;\n    }\n  }, {\n    key: 'fillStyle',\n    value: function fillStyle() {\n      this.cmds.push(['fillStyle', arguments]);\n      return this;\n    }\n  }, {\n    key: 'fill',\n    value: function fill() {\n      this.cmds.push(['fill', arguments]);\n      return this;\n    }\n  }, {\n    key: 'strokeStyle',\n    value: function strokeStyle() {\n      this.cmds.push(['strokeStyle', arguments]);\n      return this;\n    }\n  }, {\n    key: 'lineWidth',\n    value: function lineWidth() {\n      this.cmds.push(['lineWidth', arguments]);\n      return this;\n    }\n  }, {\n    key: 'lineCap',\n    value: function lineCap() {\n      this.cmds.push(['lineCap', arguments]);\n      return this;\n    }\n  }, {\n    key: 'lineDashOffset',\n    value: function lineDashOffset() {\n      this.cmds.push(['lineDashOffset', arguments]);\n      return this;\n    }\n  }, {\n    key: 'lineJoin',\n    value: function lineJoin() {\n      this.cmds.push(['lineJoin', arguments]);\n      return this;\n    }\n  }, {\n    key: 'miterLimit',\n    value: function miterLimit() {\n      this.cmds.push(['miterLimit', arguments]);\n      return this;\n    }\n  }, {\n    key: 'stroke',\n    value: function stroke() {\n      this.cmds.push(['stroke', arguments]);\n      return this;\n    }\n  }, {\n    key: 'moveTo',\n    value: function moveTo() {\n      this.cmds.push(['moveTo', arguments]);\n      return this;\n    }\n  }, {\n    key: 'lineTo',\n    value: function lineTo() {\n      this.cmds.push(['lineTo', arguments]);\n      return this;\n    }\n  }, {\n    key: 'bezierCurveTo',\n    value: function bezierCurveTo() {\n      this.cmds.push(['bezierCurveTo', arguments]);\n      return this;\n    }\n  }, {\n    key: 'quadraticCurveTo',\n    value: function quadraticCurveTo() {\n      this.cmds.push(['quadraticCurveTo', arguments]);\n      return this;\n    }\n  }, {\n    key: 'createRadialGradient',\n    value: function createRadialGradient() {\n      this.cmds.push(['createRadialGradient', arguments]);\n      return this;\n    }\n  }, {\n    key: 'createLinearGradient',\n    value: function createLinearGradient() {\n      this.cmds.push(['createLinearGradient', arguments]);\n      return this;\n    }\n  }, {\n    key: 'addColorStop',\n    value: function addColorStop() {\n      this.cmds.push(['addColorStop', arguments]);\n      return this;\n    }\n  }, {\n    key: 'fillGradient',\n    value: function fillGradient() {\n      this.cmds.push(['fillGradient']);\n      return this;\n    }\n  }, {\n    key: 'arcTo',\n    value: function arcTo() {\n      this.cmds.push(['arcTo', arguments]);\n      return this;\n    }\n  }, {\n    key: 'render',\n    value: function render(ctx) {\n      var _this2 = this;\n\n      this.cmds.forEach(function (cmd) {\n        var methodName = cmd[0];\n        if (assMap[methodName]) {\n          ctx[methodName] = cmd[1][0];\n        } else if (methodName === 'addColorStop') {\n          _this2.currentGradient && _this2.currentGradient.addColorStop(cmd[1][0], cmd[1][1]);\n        } else if (methodName === 'fillGradient') {\n          ctx.fillStyle = _this2.currentGradient;\n        } else {\n          var result = ctx[methodName].apply(ctx, Array.prototype.slice.call(cmd[1]));\n          if (methodName === 'createRadialGradient' || methodName === 'createLinearGradient') {\n            _this2.currentGradient = result;\n          }\n        }\n      });\n    }\n  }]);\n\n  return Graphics;\n}(_displayObject2.default);\n\nexports.default = Graphics;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _displayObject = __webpack_require__(3);\n\nvar _displayObject2 = _interopRequireDefault(_displayObject);\n\nvar _util = __webpack_require__(9);\n\nvar _util2 = _interopRequireDefault(_util);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar measureCtx = void 0;\n\nif (_util2.default.isWeapp) {\n  measureCtx = wx.createCanvasContext('measure0');\n} else if (typeof document !== 'undefined') {\n  measureCtx = document.createElement('canvas').getContext('2d');\n}\n\nvar Text = function (_DisplayObject) {\n  _inherits(Text, _DisplayObject);\n\n  function Text(text, option) {\n    _classCallCheck(this, Text);\n\n    var _this = _possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).call(this));\n\n    _this.text = text;\n    option = option || {};\n    _this.font = option.font || '10px sans-serif';\n    _this.color = option.color || 'black';\n    _this.textAlign = option.textAlign || 'left';\n    _this.baseline = option.baseline || 'top';\n    return _this;\n  }\n\n  _createClass(Text, [{\n    key: 'getWidth',\n    value: function getWidth() {\n      if (!measureCtx) {\n        if (_util2.default.isWegame) {\n          measureCtx = wx.createCanvas().getContext('2d');\n        }\n      }\n\n      if (this.font) {\n        measureCtx.font = this.font;\n      }\n      return measureCtx.measureText(this.text).width;\n    }\n  }]);\n\n  return Text;\n}(_displayObject2.default);\n\nexports.default = Text;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _displayObject = __webpack_require__(3);\n\nvar _displayObject2 = _interopRequireDefault(_displayObject);\n\nvar _util = __webpack_require__(9);\n\nvar _util2 = _interopRequireDefault(_util);\n\nvar _bitmap = __webpack_require__(2);\n\nvar _bitmap2 = _interopRequireDefault(_bitmap);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Sprite = function (_DisplayObject) {\n  _inherits(Sprite, _DisplayObject);\n\n  function Sprite(option) {\n    _classCallCheck(this, Sprite);\n\n    var _this = _possibleConstructorReturn(this, (Sprite.__proto__ || Object.getPrototypeOf(Sprite)).call(this));\n\n    _this.option = option;\n    var len = _this.option.imgs.length;\n    var count = 0;\n    var firstImg = _this.option.imgs[0];\n    _this.imgMap = {};\n\n    if (_util2.default.isWeapp) {\n      _this.option.imgs.forEach(function (img) {\n        _util2.default.getImageInWx(img, function (result) {\n          _this.imgMap[img] = result.img;\n          count++;\n          if (count === len) {\n            _this.img = _this.imgMap[firstImg];\n            _this.rect = [0, 0, 0, 0];\n          }\n        });\n      });\n    } else {\n      if (typeof firstImg === 'string') {\n        var _len = _this.option.imgs.length;\n        var loadedCount = 0;\n        _this.option.imgs.forEach(function (src) {\n          if (_bitmap2.default.cache[src]) {\n            _this.imgMap[src] = _bitmap2.default.cache[src];\n            loadedCount++;\n            if (loadedCount === _len) {\n              _this.img = _this.imgMap[firstImg];\n              _this.rect = [0, 0, 0, 0];\n            }\n          } else {\n            var img = _util2.default.isWegame ? wx.createImage() : new window.Image();\n            img.onload = function () {\n              _this.imgMap[src] = img;\n              loadedCount++;\n              if (loadedCount === _len) {\n                _this.img = _this.imgMap[firstImg];\n                _this.rect = [0, 0, 0, 0];\n              }\n              _bitmap2.default.cache[src] = img;\n            };\n            img.src = src;\n          }\n        });\n      } else if (firstImg instanceof _bitmap2.default) {\n        _this.rect = [0, 0, 0, 0];\n        _this.img = firstImg.img;\n      } else {\n        _this.rect = [0, 0, 0, 0];\n        _this.img = firstImg;\n      }\n    }\n\n    _this.x = option.x || 0;\n    _this.y = option.y || 0;\n    _this.currentFrameIndex = 0;\n    _this.animationFrameIndex = 0;\n    _this.currentAnimation = option.currentAnimation || null;\n\n    _this.interval = 1e3 / option.framerate;\n\n    _this.paused = false;\n    _this.animationEnd = option.animationEnd || function () {};\n    if (_this.currentAnimation) {\n      if (option.playOnce) {\n        _this.gotoAndPlayOnce(_this.currentAnimation);\n      } else {\n        _this.gotoAndPlay(_this.currentAnimation);\n      }\n    }\n    return _this;\n  }\n\n  _createClass(Sprite, [{\n    key: 'play',\n    value: function play() {\n      this.paused = false;\n    }\n  }, {\n    key: 'pause',\n    value: function pause() {\n      this.paused = true;\n    }\n  }, {\n    key: 'reset',\n    value: function reset() {\n      this.currentFrameIndex = 0;\n      this.animationFrameIndex = 0;\n    }\n  }, {\n    key: 'updateFrame',\n    value: function updateFrame() {\n      if (!this.paused) {\n        var opt = this.option;\n        this.dt = Date.now() - this.startTime;\n        var frames = opt.animations[this.currentAnimation].frames;\n        var len = frames.length;\n        var index = Math.floor(this.dt / this.interval % len);\n        this.rect = opt.frames[frames[index]];\n        var rectLen = this.rect.length;\n\n        rectLen > 4 && (this.originX = this.rect[2] * this.rect[4]);\n        rectLen > 5 && (this.originY = this.rect[3] * this.rect[5]);\n        if (rectLen > 6) {\n          var img = this.option.imgs[this.rect[6]];\n          this.img = typeof img === 'string' ? this.imgMap[img] : img;\n        }\n\n        if (index === len - 1 && (!this.endTime || Date.now() - this.endTime > this.interval)) {\n          this.endTime = Date.now();\n          this.animationEnd();\n          if (this._willDestroy) {\n            this.destroy();\n          }\n        }\n      }\n    }\n  }, {\n    key: 'gotoAndPlay',\n    value: function gotoAndPlay(animation) {\n      this.paused = false;\n      this.reset();\n      this.currentAnimation = animation;\n      this.startTime = Date.now();\n    }\n  }, {\n    key: 'gotoAndStop',\n    value: function gotoAndStop(animation) {\n      this.reset();\n      this.paused = true;\n      this.currentAnimation = animation;\n      var opt = this.option;\n      var frames = opt.animations[this.currentAnimation].frames;\n      this.rect = opt.frames[frames[this.animationFrameIndex]];\n      var rect = this.rect;\n      this.width = rect[2];\n      this.height = rect[3];\n      var rectLen = rect.length;\n      rectLen > 4 && (this.originX = rect[2] * rect[4]);\n      rectLen > 5 && (this.originY = rect[3] * rect[5]);\n      if (rectLen > 6) {\n        var img = this.option.imgs[rect[6]];\n        this.img = typeof img === 'string' ? this.imgMap[img] : img;\n      }\n    }\n  }, {\n    key: 'gotoAndPlayOnce',\n    value: function gotoAndPlayOnce(animation) {\n      this.gotoAndPlay(animation);\n      this._willDestroy = true;\n    }\n  }]);\n\n  return Sprite;\n}(_displayObject2.default);\n\nexports.default = Sprite;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Event = function () {\n  function Event() {\n    _classCallCheck(this, Event);\n\n    this.propagationStopped = false;\n    this.stageX = null;\n    this.stageY = null;\n    this.pureEvent = null;\n  }\n\n  _createClass(Event, [{\n    key: \"stopPropagation\",\n    value: function stopPropagation() {\n      this.propagationStopped = true;\n    }\n  }, {\n    key: \"preventDefault\",\n    value: function preventDefault() {\n      this.pureEvent.preventDefault();\n    }\n  }]);\n\n  return Event;\n}();\n\nexports.default = Event;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Render = function () {\n  function Render() {\n    _classCallCheck(this, Render);\n  }\n\n  _createClass(Render, [{\n    key: \"render\",\n    value: function render() {}\n  }, {\n    key: \"renderGraphics\",\n    value: function renderGraphics() {}\n  }, {\n    key: \"clear\",\n    value: function clear() {}\n  }]);\n\n  return Render;\n}();\n\nexports.default = Render;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.getImageInWx = getImageInWx;\nfunction getImageInWx(img, callback) {\n  if (img.indexOf('https://') === -1 && img.indexOf('http://') === -1 || img.indexOf('http://tmp/') === 0) {\n    wx.getImageInfo({\n      src: img,\n      success: function success(info) {\n        callback({\n          img: img,\n          width: info.width,\n          height: info.height\n        });\n      }\n    });\n  } else {\n    wx.downloadFile({\n      url: img,\n      success: function success(res) {\n        if (res.statusCode === 200) {\n          wx.getImageInfo({\n            src: res.tempFilePath,\n            success: function success(info) {\n              callback({\n                img: res.tempFilePath,\n                width: info.width,\n                height: info.height\n              });\n            }\n          });\n        }\n      }\n    });\n  }\n}\n\nfunction getGlobal() {\n  if ((typeof global === 'undefined' ? 'undefined' : _typeof(global)) !== 'object' || !global || global.Math !== Math || global.Array !== Array) {\n    if (typeof self !== 'undefined') {\n      return self;\n    } else if (typeof window !== 'undefined') {\n      return window;\n    } else if (typeof global !== 'undefined') {\n      return global;\n    }\n    return function () {\n      return this;\n    }();\n  }\n  return global;\n}\n\nvar root = getGlobal();\n\nexports.default = {\n  getImageInWx: getImageInWx,\n  root: root,\n  isWeapp: typeof wx !== 'undefined' && !wx.createCanvas,\n  isWegame: typeof wx !== 'undefined' && wx.createCanvas\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(25)))\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\r\n * Tween.js - Licensed under the MIT license\r\n * https://github.com/tweenjs/tween.js\r\n * ----------------------------------------------\r\n *\r\n * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\r\n * Thank you all, you're awesome!\r\n */\n\nvar _Group = function _Group() {\n  this._tweens = {};\n  this._tweensAddedDuringUpdate = {};\n};\n\n_Group.prototype = {\n  getAll: function getAll() {\n    return Object.keys(this._tweens).map(function (tweenId) {\n      return this._tweens[tweenId];\n    }.bind(this));\n  },\n\n  removeAll: function removeAll() {\n    this._tweens = {};\n  },\n\n  add: function add(tween) {\n    this._tweens[tween.getId()] = tween;\n    this._tweensAddedDuringUpdate[tween.getId()] = tween;\n  },\n\n  remove: function remove(tween) {\n    delete this._tweens[tween.getId()];\n    delete this._tweensAddedDuringUpdate[tween.getId()];\n  },\n\n  update: function update(time, preserve) {\n    var tweenIds = Object.keys(this._tweens);\n\n    if (tweenIds.length === 0) {\n      return false;\n    }\n\n    time = time !== undefined ? time : TWEEN.now();\n\n    // Tweens are updated in \"batches\". If you add a new tween during an update, then the\n    // new tween will be updated in the next batch.\n    // If you remove a tween during an update, it may or may not be updated. However,\n    // if the removed tween was added during the current batch, then it will not be updated.\n    while (tweenIds.length > 0) {\n      this._tweensAddedDuringUpdate = {};\n\n      for (var i = 0; i < tweenIds.length; i++) {\n        var tween = this._tweens[tweenIds[i]];\n\n        if (tween && tween.update(time) === false) {\n          tween._isPlaying = false;\n\n          if (!preserve) {\n            delete this._tweens[tweenIds[i]];\n          }\n        }\n      }\n\n      tweenIds = Object.keys(this._tweensAddedDuringUpdate);\n    }\n\n    return true;\n  }\n};\n\nvar TWEEN = new _Group();\n\nTWEEN.Group = _Group;\nTWEEN._nextId = 0;\nTWEEN.nextId = function () {\n  return TWEEN._nextId++;\n};\n\n// Include a performance.now polyfill.\n// In node.js, use process.hrtime.\nif (typeof window === 'undefined' && typeof process !== 'undefined') {\n  if (typeof wx !== 'undefined') {\n    TWEEN.now = Date.now;\n  } else {\n    TWEEN.now = function () {\n      var time = process.hrtime();\n\n      // Convert [seconds, nanoseconds] to milliseconds.\n      return time[0] * 1000 + time[1] / 1000000;\n    };\n  }\n} else if (typeof window !== 'undefined' &&\n// In a browser, use window.performance.now if it is available.\nwindow.performance !== undefined && window.performance.now !== undefined) {\n  // This must be bound, because directly assigning this function\n  // leads to an invocation exception in Chrome.\n  TWEEN.now = window.performance.now.bind(window.performance);\n} else if (Date.now !== undefined) {\n  // Use Date.now if it is available.\n  TWEEN.now = Date.now;\n} else {\n  // Otherwise, use 'new Date().getTime()'.\n  TWEEN.now = function () {\n    return new Date().getTime();\n  };\n}\n\nTWEEN.Tween = function (object, group) {\n  this._object = object;\n  this._valuesStart = {};\n  this._valuesEnd = {};\n  this._valuesStartRepeat = {};\n  this._duration = 1000;\n  this._repeat = 0;\n  this._repeatDelayTime = undefined;\n  this._yoyo = false;\n  this._isPlaying = false;\n  this._reversed = false;\n  this._delayTime = 0;\n  this._startTime = null;\n  this._easingFunction = TWEEN.Easing.Linear.None;\n  this._interpolationFunction = TWEEN.Interpolation.Linear;\n  this._chainedTweens = [];\n  this._onStartCallback = null;\n  this._onStartCallbackFired = false;\n  this._onUpdateCallback = null;\n  this._onCompleteCallback = null;\n  this._onStopCallback = null;\n  this._group = group || TWEEN;\n  this._id = TWEEN.nextId();\n\n  this._paused = false;\n  this._passTime = null;\n};\n\nTWEEN.Tween.prototype = {\n  getId: function getId() {\n    return this._id;\n  },\n\n  toggle: function toggle() {\n    if (this._paused) {\n      this.play();\n    } else {\n      this.pause();\n    }\n  },\n\n\n  pause: function pause() {\n    this._paused = true;\n    var pauseTime = TWEEN.now();\n    this._passTime = pauseTime - this._startTime;\n  },\n\n  play: function play() {\n    this._paused = false;\n    var nowTime = TWEEN.now();\n    this._startTime = nowTime - this._passTime;\n  },\n\n  isPlaying: function isPlaying() {\n    return this._isPlaying;\n  },\n\n  to: function to(properties, duration) {\n    this._valuesEnd = properties;\n\n    if (duration !== undefined) {\n      this._duration = duration;\n    }\n\n    return this;\n  },\n\n  start: function start(time) {\n    this._group.add(this);\n\n    this._isPlaying = true;\n\n    this._onStartCallbackFired = false;\n\n    this._startTime = time !== undefined ? typeof time === 'string' ? TWEEN.now() + parseFloat(time) : time : TWEEN.now();\n    this._startTime += this._delayTime;\n\n    for (var property in this._valuesEnd) {\n      // Check if an Array was provided as property value\n      if (this._valuesEnd[property] instanceof Array) {\n        if (this._valuesEnd[property].length === 0) {\n          continue;\n        }\n\n        // Create a local copy of the Array with the start value at the front\n        this._valuesEnd[property] = [this._object[property]].concat(this._valuesEnd[property]);\n      }\n\n      // If `to()` specifies a property that doesn't exist in the source object,\n      // we should not set that property in the object\n      if (this._object[property] === undefined) {\n        continue;\n      }\n\n      // Save the starting value.\n      this._valuesStart[property] = this._object[property];\n\n      if (this._valuesStart[property] instanceof Array === false) {\n        this._valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings\n      }\n\n      this._valuesStartRepeat[property] = this._valuesStart[property] || 0;\n    }\n\n    return this;\n  },\n\n  stop: function stop() {\n    if (!this._isPlaying) {\n      return this;\n    }\n\n    this._group.remove(this);\n    this._isPlaying = false;\n\n    if (this._onStopCallback !== null) {\n      this._onStopCallback(this._object);\n    }\n\n    this.stopChainedTweens();\n    return this;\n  },\n\n  end: function end() {\n    this.update(this._startTime + this._duration);\n    return this;\n  },\n\n  stopChainedTweens: function stopChainedTweens() {\n    for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n      this._chainedTweens[i].stop();\n    }\n  },\n\n  group: function group(group) {\n    this._group = group;\n    return this;\n  },\n\n  delay: function delay(amount) {\n    this._delayTime = amount;\n    return this;\n  },\n\n  repeat: function repeat(times) {\n    this._repeat = times;\n    return this;\n  },\n\n  repeatDelay: function repeatDelay(amount) {\n    this._repeatDelayTime = amount;\n    return this;\n  },\n\n  yoyo: function yoyo(yy) {\n    this._yoyo = yy;\n    return this;\n  },\n\n  easing: function easing(eas) {\n    this._easingFunction = eas;\n    return this;\n  },\n\n  interpolation: function interpolation(inter) {\n    this._interpolationFunction = inter;\n    return this;\n  },\n\n  chain: function chain() {\n    this._chainedTweens = arguments;\n    return this;\n  },\n\n  onStart: function onStart(callback) {\n    this._onStartCallback = callback;\n    return this;\n  },\n\n  onUpdate: function onUpdate(callback) {\n    this._onUpdateCallback = callback;\n    return this;\n  },\n\n  onComplete: function onComplete(callback) {\n    this._onCompleteCallback = callback;\n    return this;\n  },\n\n  onStop: function onStop(callback) {\n    this._onStopCallback = callback;\n    return this;\n  },\n\n  update: function update(time) {\n    if (this._paused) return true;\n    var property;\n    var elapsed;\n    var value;\n\n    if (time < this._startTime) {\n      return true;\n    }\n\n    if (this._onStartCallbackFired === false) {\n      if (this._onStartCallback !== null) {\n        this._onStartCallback(this._object);\n      }\n\n      this._onStartCallbackFired = true;\n    }\n\n    elapsed = (time - this._startTime) / this._duration;\n    elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;\n\n    value = this._easingFunction(elapsed);\n\n    for (property in this._valuesEnd) {\n      // Don't update properties that do not exist in the source object\n      if (this._valuesStart[property] === undefined) {\n        continue;\n      }\n\n      var start = this._valuesStart[property] || 0;\n      var end = this._valuesEnd[property];\n\n      if (end instanceof Array) {\n        this._object[property] = this._interpolationFunction(end, value);\n      } else {\n        // Parses relative end values with start as base (e.g.: +10, -3)\n        if (typeof end === 'string') {\n          if (end.charAt(0) === '+' || end.charAt(0) === '-') {\n            end = start + parseFloat(end);\n          } else {\n            end = parseFloat(end);\n          }\n        }\n\n        // Protect against non numeric properties.\n        if (typeof end === 'number') {\n          this._object[property] = start + (end - start) * value;\n        }\n      }\n    }\n\n    if (this._onUpdateCallback !== null) {\n      this._onUpdateCallback(this._object);\n    }\n\n    if (elapsed === 1) {\n      if (this._repeat > 0) {\n        if (isFinite(this._repeat)) {\n          this._repeat--;\n        }\n\n        // Reassign starting values, restart by making startTime = now\n        for (property in this._valuesStartRepeat) {\n          if (typeof this._valuesEnd[property] === 'string') {\n            this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);\n          }\n\n          if (this._yoyo) {\n            var tmp = this._valuesStartRepeat[property];\n\n            this._valuesStartRepeat[property] = this._valuesEnd[property];\n            this._valuesEnd[property] = tmp;\n          }\n\n          this._valuesStart[property] = this._valuesStartRepeat[property];\n        }\n\n        if (this._yoyo) {\n          this._reversed = !this._reversed;\n        }\n\n        if (this._repeatDelayTime !== undefined) {\n          this._startTime = time + this._repeatDelayTime;\n        } else {\n          this._startTime = time + this._delayTime;\n        }\n\n        return true;\n      } else {\n        if (this._onCompleteCallback !== null) {\n          this._onCompleteCallback(this._object);\n        }\n\n        for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n          // Make the chained tweens start exactly at the time they should,\n          // even if the `update()` method was called way past the duration of the tween\n          this._chainedTweens[i].start(this._startTime + this._duration);\n        }\n\n        return false;\n      }\n    }\n\n    return true;\n  }\n};\n\nTWEEN.Easing = {\n\n  Linear: {\n\n    None: function None(k) {\n      return k;\n    }\n\n  },\n\n  Quadratic: {\n\n    In: function In(k) {\n      return k * k;\n    },\n\n    Out: function Out(k) {\n      return k * (2 - k);\n    },\n\n    InOut: function InOut(k) {\n      if ((k *= 2) < 1) {\n        return 0.5 * k * k;\n      }\n\n      return -0.5 * (--k * (k - 2) - 1);\n    }\n\n  },\n\n  Cubic: {\n\n    In: function In(k) {\n      return k * k * k;\n    },\n\n    Out: function Out(k) {\n      return --k * k * k + 1;\n    },\n\n    InOut: function InOut(k) {\n      if ((k *= 2) < 1) {\n        return 0.5 * k * k * k;\n      }\n\n      return 0.5 * ((k -= 2) * k * k + 2);\n    }\n\n  },\n\n  Quartic: {\n\n    In: function In(k) {\n      return k * k * k * k;\n    },\n\n    Out: function Out(k) {\n      return 1 - --k * k * k * k;\n    },\n\n    InOut: function InOut(k) {\n      if ((k *= 2) < 1) {\n        return 0.5 * k * k * k * k;\n      }\n\n      return -0.5 * ((k -= 2) * k * k * k - 2);\n    }\n\n  },\n\n  Quintic: {\n\n    In: function In(k) {\n      return k * k * k * k * k;\n    },\n\n    Out: function Out(k) {\n      return --k * k * k * k * k + 1;\n    },\n\n    InOut: function InOut(k) {\n      if ((k *= 2) < 1) {\n        return 0.5 * k * k * k * k * k;\n      }\n\n      return 0.5 * ((k -= 2) * k * k * k * k + 2);\n    }\n\n  },\n\n  Sinusoidal: {\n\n    In: function In(k) {\n      return 1 - Math.cos(k * Math.PI / 2);\n    },\n\n    Out: function Out(k) {\n      return Math.sin(k * Math.PI / 2);\n    },\n\n    InOut: function InOut(k) {\n      return 0.5 * (1 - Math.cos(Math.PI * k));\n    }\n\n  },\n\n  Exponential: {\n\n    In: function In(k) {\n      return k === 0 ? 0 : Math.pow(1024, k - 1);\n    },\n\n    Out: function Out(k) {\n      return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n    },\n\n    InOut: function InOut(k) {\n      if (k === 0) {\n        return 0;\n      }\n\n      if (k === 1) {\n        return 1;\n      }\n\n      if ((k *= 2) < 1) {\n        return 0.5 * Math.pow(1024, k - 1);\n      }\n\n      return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n    }\n\n  },\n\n  Circular: {\n\n    In: function In(k) {\n      return 1 - Math.sqrt(1 - k * k);\n    },\n\n    Out: function Out(k) {\n      return Math.sqrt(1 - --k * k);\n    },\n\n    InOut: function InOut(k) {\n      if ((k *= 2) < 1) {\n        return -0.5 * (Math.sqrt(1 - k * k) - 1);\n      }\n\n      return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n    }\n\n  },\n\n  Elastic: {\n\n    In: function In(k) {\n      if (k === 0) {\n        return 0;\n      }\n\n      if (k === 1) {\n        return 1;\n      }\n\n      return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\n    },\n\n    Out: function Out(k) {\n      if (k === 0) {\n        return 0;\n      }\n\n      if (k === 1) {\n        return 1;\n      }\n\n      return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;\n    },\n\n    InOut: function InOut(k) {\n      if (k === 0) {\n        return 0;\n      }\n\n      if (k === 1) {\n        return 1;\n      }\n\n      k *= 2;\n\n      if (k < 1) {\n        return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\n      }\n\n      return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;\n    }\n\n  },\n\n  Back: {\n\n    In: function In(k) {\n      var s = 1.70158;\n\n      return k * k * ((s + 1) * k - s);\n    },\n\n    Out: function Out(k) {\n      var s = 1.70158;\n\n      return --k * k * ((s + 1) * k + s) + 1;\n    },\n\n    InOut: function InOut(k) {\n      var s = 1.70158 * 1.525;\n\n      if ((k *= 2) < 1) {\n        return 0.5 * (k * k * ((s + 1) * k - s));\n      }\n\n      return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n    }\n\n  },\n\n  Bounce: {\n\n    In: function In(k) {\n      return 1 - TWEEN.Easing.Bounce.Out(1 - k);\n    },\n\n    Out: function Out(k) {\n      if (k < 1 / 2.75) {\n        return 7.5625 * k * k;\n      } else if (k < 2 / 2.75) {\n        return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n      } else if (k < 2.5 / 2.75) {\n        return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n      } else {\n        return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n      }\n    },\n\n    InOut: function InOut(k) {\n      if (k < 0.5) {\n        return TWEEN.Easing.Bounce.In(k * 2) * 0.5;\n      }\n\n      return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;\n    }\n\n  }\n\n};\n\nTWEEN.Interpolation = {\n\n  Linear: function Linear(v, k) {\n    var m = v.length - 1;\n    var f = m * k;\n    var i = Math.floor(f);\n    var fn = TWEEN.Interpolation.Utils.Linear;\n\n    if (k < 0) {\n      return fn(v[0], v[1], f);\n    }\n\n    if (k > 1) {\n      return fn(v[m], v[m - 1], m - f);\n    }\n\n    return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);\n  },\n\n  Bezier: function Bezier(v, k) {\n    var b = 0;\n    var n = v.length - 1;\n    var pw = Math.pow;\n    var bn = TWEEN.Interpolation.Utils.Bernstein;\n\n    for (var i = 0; i <= n; i++) {\n      b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);\n    }\n\n    return b;\n  },\n\n  CatmullRom: function CatmullRom(v, k) {\n    var m = v.length - 1;\n    var f = m * k;\n    var i = Math.floor(f);\n    var fn = TWEEN.Interpolation.Utils.CatmullRom;\n\n    if (v[0] === v[m]) {\n      if (k < 0) {\n        i = Math.floor(f = m * (1 + k));\n      }\n\n      return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);\n    } else {\n      if (k < 0) {\n        return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);\n      }\n\n      if (k > 1) {\n        return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);\n      }\n\n      return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);\n    }\n  },\n\n  Utils: {\n\n    Linear: function Linear(p0, p1, t) {\n      return (p1 - p0) * t + p0;\n    },\n\n    Bernstein: function Bernstein(n, i) {\n      var fc = TWEEN.Interpolation.Utils.Factorial;\n\n      return fc(n) / fc(i) / fc(n - i);\n    },\n\n    Factorial: function () {\n      var a = [1];\n\n      return function (n) {\n        var s = 1;\n\n        if (a[n]) {\n          return a[n];\n        }\n\n        for (var i = n; i > 1; i--) {\n          s *= i;\n        }\n\n        a[n] = s;\n        return s;\n      };\n    }(),\n\n    CatmullRom: function CatmullRom(p0, p1, p2, p3, t) {\n      var v0 = (p2 - p0) * 0.5;\n      var v1 = (p3 - p1) * 0.5;\n      var t2 = t * t;\n      var t3 = t * t2;\n\n      return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n    }\n\n  }\n\n};\n\n// UMD (Universal Module Definition)\n(function (root) {\n  if (typeof module !== 'undefined' && ( false ? undefined : _typeof(exports)) === 'object') {\n    // Node.js\n    module.exports = TWEEN;\n  } else if (root !== undefined) {\n    // Global variable\n    root.TWEEN = TWEEN;\n  }\n})(undefined);\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(17)))\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _tween = __webpack_require__(10);\n\nvar _tween2 = _interopRequireDefault(_tween);\n\nvar _rafInterval = __webpack_require__(12);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar To = function () {\n  function To(element) {\n    _classCallCheck(this, To);\n\n    this.element = element;\n    this.cmds = [];\n    this.index = 0;\n    this.tweens = [];\n    this._pause = false;\n    this.loop = (0, _rafInterval.setRafInterval)(function () {\n      _tween2.default.update();\n    }, 15);\n    this.cycleCount = 0;\n  }\n\n  _createClass(To, [{\n    key: 'to',\n    value: function to(target, duration, easing) {\n      this.cmds.push(['to']);\n      if (arguments.length !== 0) {\n        for (var key in target) {\n          this.set(key, target[key], duration || 0, easing);\n        }\n      }\n      return this;\n    }\n  }, {\n    key: 'set',\n    value: function set(prop, value, duration, easing) {\n      this.cmds[this.cmds.length - 1].push([prop, [value, duration, easing]]);\n      return this;\n    }\n  }, {\n    key: 'x',\n    value: function x() {\n      this.cmds[this.cmds.length - 1].push(['x', arguments]);\n      return this;\n    }\n  }, {\n    key: 'y',\n    value: function y() {\n      this.cmds[this.cmds.length - 1].push(['y', arguments]);\n      return this;\n    }\n  }, {\n    key: 'z',\n    value: function z() {\n      this.cmds[this.cmds.length - 1].push(['z', arguments]);\n      return this;\n    }\n  }, {\n    key: 'rotation',\n    value: function rotation() {\n      this.cmds[this.cmds.length - 1].push(['rotation', arguments]);\n      return this;\n    }\n  }, {\n    key: 'scaleX',\n    value: function scaleX() {\n      this.cmds[this.cmds.length - 1].push(['scaleX', arguments]);\n      return this;\n    }\n  }, {\n    key: 'scaleY',\n    value: function scaleY() {\n      this.cmds[this.cmds.length - 1].push(['scaleY', arguments]);\n      return this;\n    }\n  }, {\n    key: 'skewX',\n    value: function skewX() {\n      this.cmds[this.cmds.length - 1].push(['skewX', arguments]);\n      return this;\n    }\n  }, {\n    key: 'skewY',\n    value: function skewY() {\n      this.cmds[this.cmds.length - 1].push(['skewY', arguments]);\n      return this;\n    }\n  }, {\n    key: 'originX',\n    value: function originX() {\n      this.cmds[this.cmds.length - 1].push(['originX', arguments]);\n      return this;\n    }\n  }, {\n    key: 'originY',\n    value: function originY() {\n      this.cmds[this.cmds.length - 1].push(['originY', arguments]);\n      return this;\n    }\n  }, {\n    key: 'alpha',\n    value: function alpha() {\n      this.cmds[this.cmds.length - 1].push(['alpha', arguments]);\n      return this;\n    }\n  }, {\n    key: 'begin',\n    value: function begin(fn) {\n      this.cmds[this.cmds.length - 1].begin = fn;\n      return this;\n    }\n  }, {\n    key: 'progress',\n    value: function progress(fn) {\n      this.cmds[this.cmds.length - 1].progress = fn;\n      return this;\n    }\n  }, {\n    key: 'end',\n    value: function end(fn) {\n      this.cmds[this.cmds.length - 1].end = fn;\n      return this;\n    }\n  }, {\n    key: 'wait',\n    value: function wait() {\n      this.cmds.push(['wait', arguments]);\n      return this;\n    }\n  }, {\n    key: 'then',\n    value: function then() {\n      this.cmds.push(['then', arguments]);\n      return this;\n    }\n  }, {\n    key: 'cycle',\n    value: function cycle() {\n      this.cmds.push(['cycle', arguments]);\n      return this;\n    }\n  }, {\n    key: 'start',\n    value: function start() {\n      if (this._pause) return;\n      var len = this.cmds.length;\n      if (this.index < len) {\n        this.exec(this.cmds[this.index], this.index === len - 1);\n      } else {\n        (0, _rafInterval.clearRafInterval)(this.loop);\n      }\n      return this;\n    }\n  }, {\n    key: 'pause',\n    value: function pause() {\n      this._pause = true;\n      for (var i = 0, len = this.tweens.length; i < len; i++) {\n        this.tweens[i].pause();\n      }\n      if (this.currentTask === 'wait') {\n        this.timeout -= new Date() - this.currentTaskBegin;\n        this.currentTaskBegin = new Date();\n      }\n    }\n  }, {\n    key: 'toggle',\n    value: function toggle() {\n      if (this._pause) {\n        this.play();\n      } else {\n        this.pause();\n      }\n    }\n  }, {\n    key: 'play',\n    value: function play() {\n      this._pause = false;\n      for (var i = 0, len = this.tweens.length; i < len; i++) {\n        this.tweens[i].play();\n      }\n      var self = this;\n      if (this.currentTask === 'wait') {\n        setTimeout(function () {\n          if (self._pause) return;\n          self.index++;\n          self.start();\n          if (self.index === self.cmds.length && self.complete) self.complete();\n        }, this.timeout);\n      }\n    }\n  }, {\n    key: 'stop',\n    value: function stop() {\n      for (var i = 0, len = this.tweens.length; i < len; i++) {\n        this.tweens[i].stop();\n      }\n      this.cmds.length = 0;\n    }\n  }, {\n    key: 'animate',\n    value: function animate(name) {\n      this.cmds = this.cmds.concat(To.animationMap[name] || []);\n      return this;\n    }\n  }, {\n    key: 'exec',\n    value: function exec(cmd, last) {\n      var len = cmd.length,\n          self = this;\n      this.currentTask = cmd[0];\n      switch (this.currentTask) {\n        case 'to':\n          self.stepCompleteCount = 0;\n          for (var i = 1; i < len; i++) {\n            var task = cmd[i];\n            var ease = task[1][2];\n            var target = {};\n            var prop = task[0];\n            target[prop] = task[1][0];\n\n            var t = new _tween2.default.Tween(this.element).to(target, task[1][1]).onStart(function () {\n              if (cmd.begin) cmd.begin.call(self.element, self.element);\n            }).onUpdate(function () {\n              if (cmd.progress) cmd.progress.call(self.element, self.element);\n              // self.element[prop] = this[prop];\n            }).easing(ease || _tween2.default.Easing.Linear.None).onComplete(function () {\n              self.stepCompleteCount++;\n              if (self.stepCompleteCount === len - 1) {\n                if (cmd.end) cmd.end.call(self.element, self.element);\n                if (last && self.complete) self.complete();\n                self.index++;\n                self.start();\n              }\n            }).start();\n            this.tweens.push(t);\n          }\n          break;\n        case 'wait':\n          this.currentTaskBegin = new Date();\n          this.timeout = cmd[1][0];\n          setTimeout(function () {\n            if (self._pause) return;\n            self.index++;\n            self.start();\n            if (cmd.end) cmd.end.call(self.element, self.element);\n            if (last && self.complete) self.complete();\n          }, cmd[1][0]);\n          break;\n        case 'then':\n          var arg = cmd[1][0];\n          arg.index = 0;\n          arg.complete = function () {\n            self.index++;\n            self.start();\n            if (last && self.complete) self.complete();\n          };\n          arg.start();\n          break;\n        case 'cycle':\n          var count = cmd[1][1];\n          if (count === undefined) {\n            self.index = cmd[1][0] || 0;\n            self.start();\n          } else {\n            if (count && self.cycleCount === count) {\n              self.index++;\n              self.start();\n              if (last && self.complete) self.complete();\n            } else {\n              self.cycleCount++;\n              self.index = cmd[1][0];\n              self.start();\n            }\n          }\n          break;\n      }\n    }\n  }]);\n\n  return To;\n}();\n\nTo.get = function (element) {\n  var to = new To(element);\n  return to;\n};\n\nTo.animationMap = {};\nTo.extend = function (animationName, cmds) {\n  To.animationMap[animationName] = cmds;\n};\n\nexports.default = To;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setRafInterval = setRafInterval;\nexports.clearRafInterval = clearRafInterval;\n/*!\r\n *  raf-interval v0.3.0 By dntzhang\r\n *  Github: https://github.com/dntzhang/raf-interval\r\n *  MIT Licensed.\r\n */\n\nif (!Date.now) {\n  Date.now = function now() {\n    return new Date().getTime();\n  };\n}\n\nvar queue = [],\n    id = -1,\n    ticking = false,\n    tickId = null,\n    now = Date.now,\n    lastTime = 0,\n    vendors = ['ms', 'moz', 'webkit', 'o'],\n    x = 0,\n    isWeapp = typeof wx !== 'undefined' && !wx.createCanvas,\n    isWegame = typeof wx !== 'undefined' && wx.createCanvas,\n    isBrowser = typeof window !== 'undefined';\n\nvar raf = isBrowser ? window.requestAnimationFrame : null;\nvar caf = isBrowser ? window.cancelAnimationFrame : null;\n\nfunction mockRaf(callback, element) {\n  var currTime = now();\n  var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n  var id = setTimeout(function () {\n    callback(currTime + timeToCall);\n  }, timeToCall);\n  lastTime = currTime + timeToCall;\n  return id;\n}\n\nfunction mockCaf(id) {\n  clearTimeout(id);\n}\n\nif (isBrowser) {\n  window.setRafInterval = setRafInterval;\n  window.clearRafInterval = clearRafInterval;\n\n  for (; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n\n  if (!raf) {\n    raf = mockRaf;\n    caf = mockCaf;\n    window.requestAnimationFrame = raf;\n    window.cancelAnimationFrame = caf;\n  }\n} else if (isWeapp) {\n  raf = mockRaf;\n  caf = mockCaf;\n} else if (isWegame) {\n  raf = requestAnimationFrame;\n  caf = cancelAnimationFrame;\n}\n\nfunction setRafInterval(fn, interval) {\n  id++;\n  queue.push({ id: id, fn: fn, interval: interval, lastTime: now() });\n  if (!ticking) {\n    var tick = function tick() {\n      tickId = raf(tick);\n      each(queue, function (item) {\n        if (item.interval < 17 || now() - item.lastTime >= item.interval) {\n          item.fn();\n          item.lastTime = now();\n        }\n      });\n    };\n    ticking = true;\n    tick();\n  }\n  return id;\n}\n\nfunction clearRafInterval(id) {\n  var i = 0,\n      len = queue.length;\n\n  for (; i < len; i++) {\n    if (id === queue[i].id) {\n      queue.splice(i, 1);\n      break;\n    }\n  }\n\n  if (queue.length === 0) {\n    caf(tickId);\n    ticking = false;\n  }\n}\n\nfunction each(arr, fn) {\n  if (Array.prototype.forEach) {\n    arr.forEach(fn);\n  } else {\n    var i = 0,\n        len = arr.length;\n    for (; i < len; i++) {\n      fn(arr[i], i);\n    }\n  }\n}\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _canvasRender = __webpack_require__(24);\n\nvar _canvasRender2 = _interopRequireDefault(_canvasRender);\n\nvar _group = __webpack_require__(1);\n\nvar _group2 = _interopRequireDefault(_group);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Renderer = function () {\n  function Renderer(canvasOrContext, width, height) {\n    _classCallCheck(this, Renderer);\n\n    this.renderList = [];\n    if (arguments.length === 3) {\n      this.renderer = new _canvasRender2.default(canvasOrContext, width, height);\n      this.width = width;\n      this.height = height;\n    } else {\n      this.renderer = new _canvasRender2.default(canvasOrContext);\n      this.width = canvasOrContext.width;\n      this.height = canvasOrContext.height;\n    }\n    this.ctx = this.renderer.ctx;\n  }\n\n  _createClass(Renderer, [{\n    key: 'update',\n    value: function update(stage) {\n      this.renderer.clear(this.ctx, this.width, this.height);\n      this.renderer.render(this.ctx, stage);\n      this.ctx.draw && this.ctx.draw();\n    }\n  }, {\n    key: 'getHitRenderList',\n    value: function getHitRenderList(stage) {\n      var objs = this.renderList;\n      objs.length = 0;\n      this.computeMatrix(stage);\n      return objs;\n    }\n  }, {\n    key: 'computeMatrix',\n    value: function computeMatrix(stage) {\n      for (var i = 0, len = stage.children.length; i < len; i++) {\n        this._computeMatrix(stage.children[i]);\n      }\n    }\n  }, {\n    key: 'initComplex',\n    value: function initComplex(o) {\n      o.complexCompositeOperation = this._getCompositeOperation(o);\n      o.complexAlpha = this._getAlpha(o, 1);\n    }\n  }, {\n    key: '_computeMatrix',\n    value: function _computeMatrix(o, mtx) {\n      if (!o.isVisible()) {\n        return;\n      }\n      if (mtx && !o.fixed) {\n        o._matrix.initialize(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\n      } else {\n        o._matrix.initialize(1, 0, 0, 1, 0, 0);\n      }\n\n      o._matrix.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.originX, o.originY);\n\n      if (o instanceof _group2.default) {\n        var list = o.children,\n            len = list.length,\n            i = 0;\n        for (; i < len; i++) {\n          this._computeMatrix(list[i], o._matrix);\n        }\n      } else {\n        // if (o instanceof Graphics) {\n        //   this.renderList.push(o)\n        //   this.initComplex(o)\n        // } else {\n        o.initAABB();\n        // if (this.isInStage(o)) {\n        this.renderList.push(o);\n        this.initComplex(o);\n        // }\n        // }\n      }\n    }\n  }, {\n    key: '_getCompositeOperation',\n    value: function _getCompositeOperation(o) {\n      if (o.compositeOperation) return o.compositeOperation;\n      if (o.parent) return this._getCompositeOperation(o.parent);\n    }\n  }, {\n    key: '_getAlpha',\n    value: function _getAlpha(o, alpha) {\n      var result = o.alpha * alpha;\n      if (o.parent) {\n        return this._getAlpha(o.parent, result);\n      }\n      return result;\n    }\n  }, {\n    key: 'isInStage',\n    value: function isInStage(o) {\n      return this.collisionBetweenAABB(o.AABB, this.stage.AABB);\n    }\n  }, {\n    key: 'collisionBetweenAABB',\n    value: function collisionBetweenAABB(AABB1, AABB2) {\n      var maxX = AABB1[0] + AABB1[2];\n      if (maxX < AABB2[0]) return false;\n      var minX = AABB1[0];\n      if (minX > AABB2[0] + AABB2[2]) return false;\n      var maxY = AABB1[1] + AABB1[3];\n      if (maxY < AABB2[1]) return false;\n      var minY = AABB1[1];\n      if (minY > AABB2[1] + AABB2[3]) return false;\n      return true;\n    }\n  }]);\n\n  return Renderer;\n}();\n\nexports.default = Renderer;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _group = __webpack_require__(1);\n\nvar _group2 = _interopRequireDefault(_group);\n\nvar _renderer = __webpack_require__(13);\n\nvar _renderer2 = _interopRequireDefault(_renderer);\n\nvar _wxHitRender = __webpack_require__(38);\n\nvar _wxHitRender2 = _interopRequireDefault(_wxHitRender);\n\nvar _event = __webpack_require__(7);\n\nvar _event2 = _interopRequireDefault(_event);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar WeStage = function (_Group) {\n  _inherits(WeStage, _Group);\n\n  function WeStage(width, height, id, page) {\n    _classCallCheck(this, WeStage);\n\n    var _this = _possibleConstructorReturn(this, (WeStage.__proto__ || Object.getPrototypeOf(WeStage)).call(this));\n\n    var component = page.selectComponent('#' + id);\n    component.setData({\n      width: width,\n      height: height\n    });\n    component.stage = _this;\n    var canvasId = component.getCaxCanvasId();\n\n    var ctx = wx.createCanvasContext(canvasId, component);\n    var hitCtx = wx.createCanvasContext(canvasId + 'Hit', component);\n    _this.renderer = new _renderer2.default(ctx, width, height);\n    _this._hitRender = new _wxHitRender2.default(hitCtx, component, canvasId);\n    _this._overObject = null;\n    _this.ctx = ctx;\n    _this.hitAABB = true;\n    _this.width = width;\n    _this.height = height;\n    return _this;\n  }\n\n  _createClass(WeStage, [{\n    key: 'touchStartHandler',\n    value: function touchStartHandler(evt) {\n      var _this2 = this;\n\n      var p1 = evt.changedTouches[0];\n\n      evt.stageX = p1.x;\n      evt.stageY = p1.y;\n\n      this._getObjectUnderPoint(evt, function (obj) {\n        _this2.willDragObject = obj;\n        _this2._mouseDownX = evt.stageX;\n        _this2._mouseDownY = evt.stageY;\n        _this2.preStageX = evt.stageX;\n        _this2.preStageY = evt.stageY;\n      });\n    }\n  }, {\n    key: 'touchMoveHandler',\n    value: function touchMoveHandler(evt) {\n      var _this3 = this;\n\n      var p1 = evt.changedTouches[0];\n\n      evt.stageX = p1.x;\n      evt.stageY = p1.y;\n\n      this._getObjectUnderPoint(evt, function (obj) {\n        var mockEvt = new _event2.default();\n        mockEvt.stageX = evt.stageX;\n        mockEvt.stageY = evt.stageY;\n        mockEvt.pureEvent = evt;\n\n        if (_this3.willDragObject) {\n          mockEvt.type = 'drag';\n          mockEvt.dx = mockEvt.stageX - _this3.preStageX;\n          mockEvt.dy = mockEvt.stageY - _this3.preStageY;\n          _this3.preStageX = mockEvt.stageX;\n          _this3.preStageY = mockEvt.stageY;\n          _this3.willDragObject.dispatchEvent(mockEvt);\n        }\n\n        if (obj) {\n          if (_this3._overObject === null) {\n            _this3._overObject = obj;\n          } else {\n            if (obj.id !== _this3._overObject.id) {\n              _this3._overObject = obj;\n            } else {\n              mockEvt.type = 'touchmove';\n              obj.dispatchEvent(mockEvt);\n            }\n          }\n        } else if (_this3._overObject) {\n          _this3._overObject = null;\n        }\n      });\n    }\n  }, {\n    key: 'touchEndHandler',\n    value: function touchEndHandler(evt) {\n      var _this4 = this;\n\n      var p1 = evt.changedTouches[0];\n\n      evt.stageX = p1.x;\n      evt.stageY = p1.y;\n\n      var mockEvt = new _event2.default();\n      mockEvt.stageX = evt.stageX;\n      mockEvt.stageY = evt.stageY;\n\n      mockEvt.pureEvent = evt;\n\n      this._getObjectUnderPoint(evt, function (obj) {\n        _this4._mouseUpX = evt.stageX;\n        _this4._mouseUpY = evt.stageY;\n\n        _this4.willDragObject = null;\n        _this4.preStageX = null;\n        _this4.preStageY = null;\n\n        if (obj && Math.abs(_this4._mouseDownX - _this4._mouseUpX) < 30 && Math.abs(_this4._mouseDownY - _this4._mouseUpY) < 30) {\n          mockEvt.type = 'tap';\n          obj.dispatchEvent(mockEvt);\n        }\n      });\n    }\n  }, {\n    key: '_handleMouseOut',\n    value: function _handleMouseOut(evt) {\n      this.dispatchEvent({\n        pureEvent: evt,\n        type: 'mouseout',\n        stageX: evt.stageX,\n        stageY: evt.stageY\n      });\n    }\n  }, {\n    key: '_getObjectUnderPoint',\n    value: function _getObjectUnderPoint(evt, cb) {\n      var list = this.renderer.getHitRenderList(this);\n      if (this.hitAABB) {\n        return this._hitRender.hitAABB(list, evt, cb);\n      } else {\n        this._hitRender.clear();\n        this._hitRender.hit(list, evt, cb, list.length - 1);\n      }\n    }\n  }, {\n    key: 'on',\n    value: function on(type, cb) {\n      switch (type) {\n        case 'touchstart':\n          this.touchStart = cb;\n          break;\n        case 'touchmove':\n          this.touchMove = cb;\n          break;\n        case 'touchend':\n          this.touchEnd = cb;\n          break;\n      }\n    }\n  }, {\n    key: 'update',\n    value: function update() {\n      this.renderer.update(this);\n    }\n  }]);\n\n  return WeStage;\n}(_group2.default);\n\nexports.default = WeStage;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _shape = __webpack_require__(0);\n\nvar _shape2 = _interopRequireDefault(_shape);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar RoundedRect = function (_Shape) {\n  _inherits(RoundedRect, _Shape);\n\n  function RoundedRect(width, height, r, option) {\n    _classCallCheck(this, RoundedRect);\n\n    var _this = _possibleConstructorReturn(this, (RoundedRect.__proto__ || Object.getPrototypeOf(RoundedRect)).call(this));\n\n    _this.option = Object.assign({\n      lineWidth: 1\n    }, option);\n    _this.r = r || 0;\n    _this.width = width;\n    _this.height = height;\n    return _this;\n  }\n\n  _createClass(RoundedRect, [{\n    key: 'draw',\n    value: function draw() {\n      var width = this.width,\n          height = this.height,\n          r = this.r;\n\n      var ax = r,\n          ay = 0,\n          bx = width,\n          by = 0,\n          cx = width,\n          cy = height,\n          dx = 0,\n          dy = height,\n          ex = 0,\n          ey = 0;\n\n      this.beginPath();\n\n      this.moveTo(ax, ay);\n      this.arcTo(bx, by, cx, cy, r);\n      this.arcTo(cx, cy, dx, dy, r);\n      this.arcTo(dx, dy, ex, ey, r);\n      this.arcTo(ex, ey, ax, ay, r);\n\n      if (this.option.fillStyle) {\n        this.closePath();\n        this.fillStyle(this.option.fillStyle);\n        this.fill();\n      }\n\n      if (this.option.strokeStyle) {\n        this.lineWidth(this.option.lineWidth);\n        this.strokeStyle(this.option.strokeStyle);\n        this.stroke();\n      }\n    }\n  }]);\n\n  return RoundedRect;\n}(_shape2.default);\n\nexports.default = RoundedRect;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _tween = __webpack_require__(10);\n\nvar _tween2 = _interopRequireDefault(_tween);\n\nvar _to = __webpack_require__(11);\n\nvar _to2 = _interopRequireDefault(_to);\n\n__webpack_require__(18);\n\nvar _stage = __webpack_require__(19);\n\nvar _stage2 = _interopRequireDefault(_stage);\n\nvar _weStage = __webpack_require__(14);\n\nvar _weStage2 = _interopRequireDefault(_weStage);\n\nvar _graphics = __webpack_require__(4);\n\nvar _graphics2 = _interopRequireDefault(_graphics);\n\nvar _bitmap = __webpack_require__(2);\n\nvar _bitmap2 = _interopRequireDefault(_bitmap);\n\nvar _text = __webpack_require__(5);\n\nvar _text2 = _interopRequireDefault(_text);\n\nvar _group = __webpack_require__(1);\n\nvar _group2 = _interopRequireDefault(_group);\n\nvar _sprite = __webpack_require__(6);\n\nvar _sprite2 = _interopRequireDefault(_sprite);\n\nvar _shape = __webpack_require__(0);\n\nvar _shape2 = _interopRequireDefault(_shape);\n\nvar _roundedRect = __webpack_require__(15);\n\nvar _roundedRect2 = _interopRequireDefault(_roundedRect);\n\nvar _arrowPath = __webpack_require__(39);\n\nvar _arrowPath2 = _interopRequireDefault(_arrowPath);\n\nvar _ellipse = __webpack_require__(40);\n\nvar _ellipse2 = _interopRequireDefault(_ellipse);\n\nvar _path = __webpack_require__(41);\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _button = __webpack_require__(44);\n\nvar _button2 = _interopRequireDefault(_button);\n\nvar _rect = __webpack_require__(45);\n\nvar _rect2 = _interopRequireDefault(_rect);\n\nvar _circle = __webpack_require__(46);\n\nvar _circle2 = _interopRequireDefault(_circle);\n\nvar _polygon = __webpack_require__(47);\n\nvar _polygon2 = _interopRequireDefault(_polygon);\n\nvar _equilateralPolygon = __webpack_require__(48);\n\nvar _equilateralPolygon2 = _interopRequireDefault(_equilateralPolygon);\n\nvar _rafInterval = __webpack_require__(12);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_to2.default.easing = {\n  linear: _tween2.default.Easing.Linear.None\n};\n\nvar cax = {\n  easing: {\n    linear: _tween2.default.Easing.Linear.None\n  },\n  util: {\n    randomInt: function randomInt(min, max) {\n      return min + Math.floor(Math.random() * (max - min + 1));\n    }\n  },\n\n  Stage: _stage2.default,\n  WeStage: _weStage2.default,\n  Graphics: _graphics2.default,\n  Bitmap: _bitmap2.default,\n  Text: _text2.default,\n  Group: _group2.default,\n  Sprite: _sprite2.default,\n  Shape: _shape2.default,\n\n  ArrowPath: _arrowPath2.default,\n  Ellipse: _ellipse2.default,\n  Path: _path2.default,\n\n  Button: _button2.default,\n\n  RoundedRect: _roundedRect2.default,\n  Rect: _rect2.default,\n  Circle: _circle2.default,\n  Polygon: _polygon2.default,\n  EquilateralPolygon: _equilateralPolygon2.default,\n\n  setInterval: _rafInterval.setRafInterval,\n  clearInterval: _rafInterval.clearRafInterval,\n  tick: function tick(fn) {\n    return (0, _rafInterval.setRafInterval)(fn, 16);\n  },\n  untick: function untick(tickId) {\n    (0, _rafInterval.clearRafInterval)(tickId);\n  },\n\n  caxCanvasId: 0,\n  TWEEN: _tween2.default,\n  To: _to2.default\n};\n\n['Quadratic', 'Cubic', 'Quartic', 'Quintic', 'Sinusoidal', 'Exponential', 'Circular', 'Elastic', 'Back', 'Bounce'].forEach(function (item) {\n  var itemLower = item.toLowerCase();\n  cax.easing[itemLower + 'In'] = _tween2.default.Easing[item].In;\n  cax.easing[itemLower + 'Out'] = _tween2.default.Easing[item].Out;\n  cax.easing[itemLower + 'InOut'] = _tween2.default.Easing[item].InOut;\n\n  _to2.default.easing[itemLower + 'In'] = _tween2.default.Easing[item].In;\n  _to2.default.easing[itemLower + 'Out'] = _tween2.default.Easing[item].Out;\n  _to2.default.easing[itemLower + 'InOut'] = _tween2.default.Easing[item].InOut;\n});\n\ncax.loadImg = function (option) {\n  var img = new Image();\n  img.onload = function () {\n    option.complete(this);\n  };\n  img.src = option.img;\n};\n\ncax.loadImgs = function (option) {\n  var result = [];\n  var loaded = 0;\n  var len = option.imgs.length;\n  option.imgs.forEach(function (src, index) {\n    var img = new Image();\n    img.onload = function (i, img) {\n      return function () {\n        result[i] = img;\n        loaded++;\n        option.progress && option.progress(loaded / len, loaded, i, img, result);\n        if (loaded === len) {\n          option.complete && option.complete(result);\n        }\n      };\n    }(index, img);\n    img.src = src;\n  });\n};\n\nmodule.exports = cax;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _to = __webpack_require__(11);\n\nvar _to2 = _interopRequireDefault(_to);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_to2.default.extend('rubber', [['to', ['scaleX', {\n  '0': 1.25,\n  '1': 300\n}], ['scaleY', {\n  '0': 0.75,\n  '1': 300\n}]], ['to', ['scaleX', {\n  '0': 0.75,\n  '1': 100\n}], ['scaleY', {\n  '0': 1.25,\n  '1': 100\n}]], ['to', ['scaleX', {\n  '0': 1.15,\n  '1': 100\n}], ['scaleY', {\n  '0': 0.85,\n  '1': 100\n}]], ['to', ['scaleX', {\n  '0': 0.95,\n  '1': 150\n}], ['scaleY', {\n  '0': 1.05,\n  '1': 150\n}]], ['to', ['scaleX', {\n  '0': 1.05,\n  '1': 100\n}], ['scaleY', {\n  '0': 0.95,\n  '1': 100\n}]], ['to', ['scaleX', {\n  '0': 1,\n  '1': 250\n}], ['scaleY', {\n  '0': 1,\n  '1': 250\n}]]]);\n\n_to2.default.extend('bounceIn', [['to', ['scaleX', {\n  '0': 0,\n  '1': 0\n}], ['scaleY', {\n  '0': 0,\n  '1': 0\n}]], ['to', ['scaleX', {\n  '0': 1.35,\n  '1': 200\n}], ['scaleY', {\n  '0': 1.35,\n  '1': 200\n}]], ['to', ['scaleX', {\n  '0': 0.9,\n  '1': 100\n}], ['scaleY', {\n  '0': 0.9,\n  '1': 100\n}]], ['to', ['scaleX', {\n  '0': 1.1,\n  '1': 100\n}], ['scaleY', {\n  '0': 1.1,\n  '1': 100\n}]], ['to', ['scaleX', {\n  '0': 0.95,\n  '1': 100\n}], ['scaleY', {\n  '0': 0.95,\n  '1': 100\n}]], ['to', ['scaleX', {\n  '0': 1,\n  '1': 100\n}], ['scaleY', {\n  '0': 1,\n  '1': 100\n}]]]);\n\n_to2.default.extend('flipInX', [['to', ['rotateX', {\n  '0': -90,\n  '1': 0\n}]], ['to', ['rotateX', {\n  '0': 20,\n  '1': 300\n}]], ['to', ['rotateX', {\n  '0': -20,\n  '1': 300\n}]], ['to', ['rotateX', {\n  '0': 10,\n  '1': 300\n}]], ['to', ['rotateX', {\n  '0': -5,\n  '1': 300\n}]], ['to', ['rotateX', {\n  '0': 0,\n  '1': 300\n}]]]);\n\n_to2.default.extend('zoomOut', [['to', ['scaleX', {\n  '0': 0,\n  '1': 400\n}], ['scaleY', {\n  '0': 0,\n  '1': 400\n}]]]);\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _wegameCanvas = __webpack_require__(20);\n\nvar _wegameCanvas2 = _interopRequireDefault(_wegameCanvas);\n\nvar _group = __webpack_require__(1);\n\nvar _group2 = _interopRequireDefault(_group);\n\nvar _renderer = __webpack_require__(13);\n\nvar _renderer2 = _interopRequireDefault(_renderer);\n\nvar _hitRender = __webpack_require__(37);\n\nvar _hitRender2 = _interopRequireDefault(_hitRender);\n\nvar _event = __webpack_require__(7);\n\nvar _event2 = _interopRequireDefault(_event);\n\nvar _weStage = __webpack_require__(14);\n\nvar _weStage2 = _interopRequireDefault(_weStage);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Stage = function (_Group) {\n  _inherits(Stage, _Group);\n\n  function Stage(width, height, renderTo) {\n    _classCallCheck(this, Stage);\n\n    var _this = _possibleConstructorReturn(this, (Stage.__proto__ || Object.getPrototypeOf(Stage)).call(this));\n\n    var len = arguments.length;\n    _this.isWegame = typeof wx !== 'undefined' && wx.createCanvas;\n    _this.moveDetectionInterval = 0;\n    if (len === 0) {\n      // wegame\n      _this.canvas = _wegameCanvas2.default;\n      _this.disableMoveDetection = true;\n      _this.moveDetectionInterval = 500;\n    } else if (len === 4) {\n      var _ret;\n\n      // weapp\n      return _ret = new _weStage2.default(arguments[0], arguments[1], arguments[2], arguments[3]), _possibleConstructorReturn(_this, _ret);\n    } else {\n      if (len === 1) {\n        _this.canvas = typeof width === 'string' ? document.querySelector(width) : width;\n      } else {\n        _this.renderTo = typeof renderTo === 'string' ? document.querySelector(renderTo) : renderTo;\n        if (_this.renderTo.tagName === 'CANVAS') {\n          _this.canvas = _this.renderTo;\n          _this.canvas.width = width;\n          _this.canvas.height = height;\n        } else {\n          _this.canvas = document.createElement('canvas');\n          _this.canvas.width = width;\n          _this.canvas.height = height;\n          _this.renderTo.appendChild(_this.canvas);\n        }\n      }\n      // get rect again when trigger onscroll onresize event!?\n      _this._boundingClientRect = _this.canvas.getBoundingClientRect();\n\n      _this.offset = _this._getOffset(_this.canvas);\n    }\n    _this.renderer = new _renderer2.default(_this.canvas);\n    if (_this.isWegame) {\n      wx.onTouchStart(function (evt) {\n        return _this._handleMouseDown(evt);\n      });\n\n      wx.onTouchMove(function (evt) {\n        return _this._handleMouseMove(evt);\n      });\n\n      wx.onTouchEnd(function (evt) {\n        return _this._handleMouseUp(evt);\n      });\n    } else {\n      _this.canvas.addEventListener('click', function (evt) {\n        return _this._handleClick(evt);\n      });\n      _this.canvas.addEventListener('mousedown', function (evt) {\n        return _this._handleMouseDown(evt);\n      });\n      _this.canvas.addEventListener('mousemove', function (evt) {\n        return _this._handleMouseMove(evt);\n      });\n      _this.canvas.addEventListener('mouseup', function (evt) {\n        return _this._handleMouseUp(evt);\n      });\n      _this.canvas.addEventListener('mouseout', function (evt) {\n        return _this._handleMouseOut(evt);\n      });\n      _this.canvas.addEventListener('touchstart', function (evt) {\n        return _this._handleMouseDown(evt);\n      });\n      _this.canvas.addEventListener('touchmove', function (evt) {\n        return _this._handleMouseMove(evt);\n      });\n      _this.canvas.addEventListener('touchend', function (evt) {\n        return _this._handleMouseUp(evt);\n      });\n\n      _this.canvas.addEventListener('dblclick', function (evt) {\n        return _this._handleDblClick(evt);\n      });\n      // this.addEvent(this.canvas, \"mousewheel\", this._handleMouseWheel.bind(this));\n\n      document.addEventListener('contextmenu', function (evt) {\n        return _this._handleContextmenu(evt);\n      });\n    }\n\n    _this.borderTopWidth = 0;\n    _this.borderLeftWidth = 0;\n\n    _this.hitAABB = false;\n    _this._hitRender = new _hitRender2.default();\n\n    _this._overObject = null;\n\n    _this._scaleX = 1;\n    _this._scaleY = 1;\n\n    _this._mouseDownX = 0;\n    _this._mouseDownY = 0;\n\n    _this._mouseUpX = 0;\n    _this._mouseUpY = 0;\n\n    _this.willDragObject = null;\n    _this.preStageX = null;\n    _this.preStageY = null;\n\n    _this.width = _this.canvas.width;\n    _this.height = _this.canvas.height;\n\n    _this.___instanceof = 'Stage';\n\n    _this._moveDetectionTime = Date.now();\n    return _this;\n  }\n\n  _createClass(Stage, [{\n    key: '_handleContextmenu',\n    value: function _handleContextmenu(evt) {\n      this._getObjectUnderPoint(evt);\n    }\n  }, {\n    key: '_handleDblClick',\n    value: function _handleDblClick(evt) {\n      this._getObjectUnderPoint(evt);\n    }\n  }, {\n    key: '_handleClick',\n    value: function _handleClick(evt) {\n      if (Math.abs(this._mouseDownX - this._mouseUpX) < 20 && Math.abs(this._mouseDownY - this._mouseUpY) < 20) {\n        this._getObjectUnderPoint(evt);\n      }\n    }\n  }, {\n    key: '_handleMouseDown',\n    value: function _handleMouseDown(evt) {\n      if (this.isWegame) {\n        evt.type = 'touchstart';\n      }\n      this.offset = this._getOffset(this.canvas);\n      var obj = this._getObjectUnderPoint(evt);\n      this.willDragObject = obj;\n      this._mouseDownX = evt.stageX;\n      this._mouseDownY = evt.stageY;\n      this.preStageX = evt.stageX;\n      this.preStageY = evt.stageY;\n    }\n  }, {\n    key: 'scaleEventPoint',\n    value: function scaleEventPoint(x, y) {\n      this._scaleX = x;\n      this._scaleY = y;\n    }\n  }, {\n    key: '_handleMouseUp',\n    value: function _handleMouseUp(evt) {\n      if (this.isWegame) {\n        evt.type = 'touchend';\n      }\n      var obj = this._getObjectUnderPoint(evt);\n      this._mouseUpX = evt.stageX;\n      this._mouseUpY = evt.stageY;\n\n      var mockEvt = new _event2.default();\n      mockEvt.stageX = evt.stageX;\n      mockEvt.stageY = evt.stageY;\n      mockEvt.pureEvent = evt;\n\n      this.willDragObject = null;\n      this.preStageX = null;\n      this.preStageY = null;\n\n      if (obj && evt.type === 'touchend' && Math.abs(this._mouseDownX - this._mouseUpX) < 30 && Math.abs(this._mouseDownY - this._mouseUpY) < 30) {\n        mockEvt.type = 'tap';\n        obj.dispatchEvent(mockEvt);\n      }\n    }\n  }, {\n    key: '_handleMouseOut',\n    value: function _handleMouseOut(evt) {\n      this._computeStageXY(evt);\n      this.dispatchEvent({\n        pureEvent: evt,\n        type: 'mouseout',\n        stageX: evt.stageX,\n        stageY: evt.stageY\n      });\n    }\n  }, {\n    key: '_handleMouseMove',\n    value: function _handleMouseMove(evt) {\n      if (Date.now() - this._moveDetectionTime < this.moveDetectionInterval) {\n        return;\n      }\n      this._moveDetectionTime = Date.now();\n\n      if (this.isWegame) {\n        evt.type = 'touchmove';\n      }\n      if (this.disableMoveDetection) return;\n      var obj = this._getObjectUnderPoint(evt);\n      var mockEvt = new _event2.default();\n      mockEvt.stageX = evt.stageX;\n      mockEvt.stageY = evt.stageY;\n      mockEvt.pureEvent = evt;\n\n      if (this.willDragObject) {\n        mockEvt.type = 'drag';\n        mockEvt.dx = mockEvt.stageX - this.preStageX;\n        mockEvt.dy = mockEvt.stageY - this.preStageY;\n        this.preStageX = mockEvt.stageX;\n        this.preStageY = mockEvt.stageY;\n        this.willDragObject.dispatchEvent(mockEvt);\n      }\n\n      if (obj) {\n        if (this._overObject === null) {\n          mockEvt.type = 'mouseover';\n          obj.dispatchEvent(mockEvt);\n          this._overObject = obj;\n          this._setCursor(obj);\n        } else {\n          if (obj.id !== this._overObject.id) {\n            this._overObject.dispatchEvent({\n              pureEvent: evt,\n              type: 'mouseout',\n              stageX: evt.stageX,\n              stageY: evt.stageY\n            });\n            mockEvt.type = 'mouseover';\n            obj.dispatchEvent(mockEvt);\n            this._setCursor(obj);\n            this._overObject = obj;\n          } else {\n            mockEvt.type = 'mousemove';\n            obj.dispatchEvent(mockEvt);\n            mockEvt.type = 'touchmove';\n            obj.dispatchEvent(mockEvt);\n          }\n        }\n      } else if (this._overObject) {\n        mockEvt.type = 'mouseout';\n        this._overObject.dispatchEvent(mockEvt);\n        this._overObject = null;\n        this._setCursor({ cursor: 'default' });\n      }\n    }\n  }, {\n    key: '_setCursor',\n    value: function _setCursor(obj) {\n      if (!this.canvas.style) {\n        return;\n      }\n      if (obj.cursor) {\n        this.canvas.style.cursor = obj.cursor;\n      } else if (obj.parent) {\n        this._setCursor(obj.parent);\n      } else {\n        this._setCursor({ cursor: 'default' });\n      }\n    }\n  }, {\n    key: '_getObjectUnderPoint',\n    value: function _getObjectUnderPoint(evt) {\n      this._computeStageXY(evt);\n      if (this.hitAABB) {\n        return this._hitRender.hitAABB(this, evt);\n      } else {\n        return this._hitRender.hitPixel(this, evt);\n      }\n    }\n  }, {\n    key: '_computeStageXY',\n    value: function _computeStageXY(evt) {\n      this._boundingClientRect = this.isWegame ? { left: 0, top: 0 } : this.canvas.getBoundingClientRect();\n      if (evt.touches || evt.changedTouches) {\n        var firstTouch = evt.touches[0] || evt.changedTouches[0];\n        if (firstTouch) {\n          evt.stageX = (firstTouch.pageX - this.offset[0]) / this._scaleX;\n          evt.stageY = (firstTouch.pageY - this.offset[1]) / this._scaleY;\n        }\n      } else {\n        evt.stageX = (evt.clientX - this._boundingClientRect.left - this.borderLeftWidth) / this._scaleX;\n        evt.stageY = (evt.clientY - this._boundingClientRect.top - this.borderTopWidth) / this._scaleY;\n      }\n    }\n  }, {\n    key: '_getOffset',\n    value: function _getOffset(el) {\n      if (this.isWegame) {\n        return [0, 0];\n      }\n      var _t = 0,\n          _l = 0;\n      if (document.documentElement.getBoundingClientRect && el.getBoundingClientRect) {\n        var box = el.getBoundingClientRect();\n        _l = box.left;\n        _t = box.top;\n      } else {\n        while (el.offsetParent) {\n          _t += el.offsetTop;\n          _l += el.offsetLeft;\n          el = el.offsetParent;\n        }\n        return [_l, _t];\n      }\n      return [_l + Math.max(document.documentElement.scrollLeft, document.body.scrollLeft), _t + Math.max(document.documentElement.scrollTop, document.body.scrollTop)];\n    }\n  }, {\n    key: 'update',\n    value: function update() {\n      this.renderer.update(this);\n    }\n  }, {\n    key: 'on',\n    value: function on(type, fn) {\n      var _this2 = this;\n\n      this.canvas.addEventListener(type, function (evt) {\n        _this2._computeStageXY(evt);\n        fn(evt);\n      });\n    }\n  }, {\n    key: 'off',\n    value: function off(type, fn) {\n      this.canvas.removeEventListener(type, fn);\n    }\n  }]);\n\n  return Stage;\n}(_group2.default);\n\nexports.default = Stage;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar wegameCanvas = null;\nif (typeof wx !== 'undefined' && wx.createCanvas) {\n  wegameCanvas = wx.createCanvas();\n}\n\nexports.default = wegameCanvas;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DEG_TO_RAD = 0.017453292519943295;\nvar PI_2 = Math.PI * 2;\n\nvar Matrix2D = function () {\n  function Matrix2D(a, b, c, d, tx, ty) {\n    _classCallCheck(this, Matrix2D);\n\n    this.a = a == null ? 1 : a;\n    this.b = b || 0;\n    this.c = c || 0;\n    this.d = d == null ? 1 : d;\n    this.tx = tx || 0;\n    this.ty = ty || 0;\n    return this;\n  }\n\n  _createClass(Matrix2D, [{\n    key: \"identity\",\n    value: function identity() {\n      this.a = this.d = 1;\n      this.b = this.c = this.tx = this.ty = 0;\n      return this;\n    }\n  }, {\n    key: \"appendTransform\",\n    value: function appendTransform(x, y, scaleX, scaleY, rotation, skewX, skewY, originX, originY) {\n      if (rotation % 360) {\n        var r = rotation * DEG_TO_RAD;\n        var cos = Math.cos(r);\n        var sin = Math.sin(r);\n      } else {\n        cos = 1;\n        sin = 0;\n      }\n      if (skewX || skewY) {\n        skewX *= DEG_TO_RAD;\n        skewY *= DEG_TO_RAD;\n        this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);\n        this.append(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, 0, 0);\n      } else {\n        this.append(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, x, y);\n      }\n      if (originX || originY) {\n        this.tx -= originX * this.a + originY * this.c;\n        this.ty -= originX * this.b + originY * this.d;\n      }\n      return this;\n    }\n  }, {\n    key: \"append\",\n    value: function append(a, b, c, d, tx, ty) {\n      var a1 = this.a;\n      var b1 = this.b;\n      var c1 = this.c;\n      var d1 = this.d;\n      this.a = a * a1 + b * c1;\n      this.b = a * b1 + b * d1;\n      this.c = c * a1 + d * c1;\n      this.d = c * b1 + d * d1;\n      this.tx = tx * a1 + ty * c1 + this.tx;\n      this.ty = tx * b1 + ty * d1 + this.ty;\n      return this;\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize(a, b, c, d, tx, ty) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n      this.d = d;\n      this.tx = tx;\n      this.ty = ty;\n      return this;\n    }\n  }, {\n    key: \"setValues\",\n    value: function setValues(a, b, c, d, tx, ty) {\n      this.a = a == null ? 1 : a;\n      this.b = b || 0;\n      this.c = c || 0;\n      this.d = d == null ? 1 : d;\n      this.tx = tx || 0;\n      this.ty = ty || 0;\n      return this;\n    }\n  }, {\n    key: \"invert\",\n    value: function invert() {\n      var a1 = this.a;\n      var b1 = this.b;\n      var c1 = this.c;\n      var d1 = this.d;\n      var tx1 = this.tx;\n      var n = a1 * d1 - b1 * c1;\n\n      this.a = d1 / n;\n      this.b = -b1 / n;\n      this.c = -c1 / n;\n      this.d = a1 / n;\n      this.tx = (c1 * this.ty - d1 * tx1) / n;\n      this.ty = -(a1 * this.ty - b1 * tx1) / n;\n      return this;\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(matrix) {\n      return this.setValues(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);\n    }\n  }]);\n\n  return Matrix2D;\n}();\n\nMatrix2D.decompose = function (a, b, c, d, tx, ty, transform) {\n  var skewX = -Math.atan2(-c, d);\n  var skewY = Math.atan2(b, a);\n\n  var delta = Math.abs(skewX + skewY);\n\n  if (delta < 0.00001 || Math.abs(PI_2 - delta) < 0.00001) {\n    transform.rotation = skewY;\n\n    if (a < 0 && d >= 0) {\n      transform.rotation += transform.rotation <= 0 ? Math.PI : -Math.PI;\n    }\n\n    transform.skewX = transform.skewY = 0;\n  } else {\n    transform.rotation = 0;\n    transform.skewX = skewX;\n    transform.skewY = skewY;\n  }\n\n  // next set scale\n  transform.scaleX = Math.sqrt(a * a + b * b);\n  transform.scaleY = Math.sqrt(c * c + d * d);\n\n  // next set position\n  transform.x = tx;\n  transform.y = ty;\n};\n\nexports.default = Matrix2D;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar EventDispatcher = function () {\n  function EventDispatcher() {\n    _classCallCheck(this, EventDispatcher);\n\n    this._listeners = null;\n    this._captureListeners = null;\n  }\n\n  _createClass(EventDispatcher, [{\n    key: \"addEventListener\",\n    value: function addEventListener(type, listener, useCapture) {\n      var listeners;\n      if (useCapture) {\n        listeners = this._captureListeners = this._captureListeners || {};\n      } else {\n        listeners = this._listeners = this._listeners || {};\n      }\n      var arr = listeners[type];\n      if (arr) {\n        this.removeEventListener(type, listener, useCapture);\n      }\n      arr = listeners[type]; // remove may have deleted the array\n      if (!arr) {\n        listeners[type] = [listener];\n      } else {\n        arr.push(listener);\n      }\n      return listener;\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(type, listener, useCapture) {\n      var listeners = useCapture ? this._captureListeners : this._listeners;\n      if (!listeners) {\n        return;\n      }\n      var arr = listeners[type];\n      if (!arr) {\n        return;\n      }\n\n      arr.every(function (item, index) {\n        if (item === listener) {\n          arr.splice(index, 1);\n          return false;\n        }\n        return true;\n      });\n    }\n  }, {\n    key: \"on\",\n    value: function on(type, listener, useCapture) {\n      this.addEventListener(type, listener, useCapture);\n    }\n  }, {\n    key: \"off\",\n    value: function off(type, listener, useCapture) {\n      this.removeEventListener(type, listener, useCapture);\n    }\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(evt) {\n\n      var top = this,\n          list = [top];\n      while (top.parent) {\n        list.push(top = top.parent);\n      }\n      var i,\n          l = list.length;\n\n      // capture & atTarget\n      for (i = l - 1; i >= 0 && !evt.propagationStopped; i--) {\n        list[i]._dispatchEvent(evt, 0);\n      }\n      // bubbling\n      for (i = 0; i < l && !evt.propagationStopped; i++) {\n        list[i]._dispatchEvent(evt, 1);\n      }\n    }\n  }, {\n    key: \"_dispatchEvent\",\n    value: function _dispatchEvent(evt, type) {\n      var _this = this;\n\n      evt.target = this;\n      if (this._captureListeners && type === 0) {\n        var cls = this._captureListeners[evt.type];\n        cls && cls.forEach(function (fn) {\n          fn.call(_this, evt);\n        });\n      }\n\n      if (this._listeners && type === 1) {\n        var ls = this._listeners[evt.type];\n        ls && ls.forEach(function (fn) {\n          fn.call(_this, evt);\n        });\n      }\n    }\n  }]);\n\n  return EventDispatcher;\n}();\n\nexports.default = EventDispatcher;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar UID = {};\n\nUID._nextID = 0;\n\nUID.get = function () {\n  return UID._nextID++;\n};\n\nexports.default = UID;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _group = __webpack_require__(1);\n\nvar _group2 = _interopRequireDefault(_group);\n\nvar _graphics = __webpack_require__(4);\n\nvar _graphics2 = _interopRequireDefault(_graphics);\n\nvar _render2 = __webpack_require__(8);\n\nvar _render3 = _interopRequireDefault(_render2);\n\nvar _sprite = __webpack_require__(6);\n\nvar _sprite2 = _interopRequireDefault(_sprite);\n\nvar _bitmap = __webpack_require__(2);\n\nvar _bitmap2 = _interopRequireDefault(_bitmap);\n\nvar _text = __webpack_require__(5);\n\nvar _text2 = _interopRequireDefault(_text);\n\nvar _index = __webpack_require__(26);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar CanvasRender = function (_Render) {\n  _inherits(CanvasRender, _Render);\n\n  function CanvasRender(canvasOrContext, width, height) {\n    _classCallCheck(this, CanvasRender);\n\n    var _this = _possibleConstructorReturn(this, (CanvasRender.__proto__ || Object.getPrototypeOf(CanvasRender)).call(this));\n\n    if (arguments.length === 3) {\n      _this.ctx = canvasOrContext;\n      _this.width = width;\n      _this.height = height;\n    } else {\n      _this.ctx = canvasOrContext.getContext('2d');\n      _this.width = canvasOrContext.width;\n      _this.height = canvasOrContext.height;\n    }\n    return _this;\n  }\n\n  _createClass(CanvasRender, [{\n    key: 'clear',\n    value: function clear(ctx, width, height) {\n      ctx.clearRect(0, 0, width, height);\n    }\n  }, {\n    key: 'render',\n    value: function render(ctx, o, cacheData) {\n      var mtx = o._matrix;\n      if (o.children) {\n        var list = o.children.slice(0),\n            l = list.length;\n        for (var i = 0; i < l; i++) {\n          var child = list[i];\n          mtx.initialize(1, 0, 0, 1, 0, 0);\n          mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.originX, o.originY);\n          // if (!this.checkBoundEvent(child)) continue\n          ctx.save();\n          this._render(ctx, child, cacheData ? null : mtx, cacheData, true);\n          ctx.restore();\n        }\n      } else {\n        this._render(ctx, o, cacheData ? null : mtx, cacheData);\n      }\n    }\n  }, {\n    key: '_render',\n    value: function _render(ctx, o, mtx, cacheData, inGroup) {\n      if (!o.isVisible()) return;\n      if (mtx && !o.fixed) {\n        o._matrix.initialize(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\n      } else if (cacheData && !o.fixed) {\n        o._matrix.initialize(cacheData.scale, 0, 0, cacheData.scale, cacheData.x * -1, cacheData.y * -1);\n      } else {\n        o._matrix.initialize(1, 0, 0, 1, 0, 0);\n      }\n      mtx = o._matrix;\n\n      // group 进行 cache canvas 内部的子元素需要进行appendTransform\n      // cache canvas 渲染不叠加自身的 transform，因为进入主渲染会进行appendTransform\n      if (inGroup || !cacheData) {\n        mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.originX, o.originY);\n      }\n      var ocg = o.clipGraphics;\n      if (ocg) {\n        ctx.beginPath();\n        ocg._matrix.copy(mtx);\n        ocg._matrix.appendTransform(ocg.x, ocg.y, ocg.scaleX, ocg.scaleY, ocg.rotation, ocg.skewX, ocg.skewY, ocg.originX, ocg.originY);\n        ctx.setTransform(ocg._matrix.a, ocg._matrix.b, ocg._matrix.c, ocg._matrix.d, ocg._matrix.tx, ocg._matrix.ty);\n        ocg.render(ctx);\n        ctx.clip(o.clipRuleNonzero ? 'nonzero' : 'evenodd');\n      }\n\n      var oacg = o.absClipGraphics;\n      if (oacg) {\n        ctx.beginPath();\n        oacg._matrix.initialize(1, 0, 0, 1, 0, 0);\n        oacg._matrix.appendTransform(oacg.x, oacg.y, oacg.scaleX, oacg.scaleY, oacg.rotation, oacg.skewX, oacg.skewY, oacg.originX, oacg.originY);\n        ctx.setTransform(oacg._matrix.a, oacg._matrix.b, oacg._matrix.c, oacg._matrix.d, oacg._matrix.tx, oacg._matrix.ty);\n        oacg.render(ctx);\n        ctx.clip(o.absClipRuleNonzero ? 'nonzero' : 'evenodd');\n      }\n\n      // if(!cacheData){\n      ctx.setTransform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\n      // }\n      if (o._readyToCache || o.cacheUpdating) {\n        this.setComplexProps(ctx, o);\n        o._readyToCache = false;\n        o.cacheCtx.clearRect(0, 0, o.cacheCanvas.width, o.cacheCanvas.height);\n        o.cacheCtx.save();\n        this.render(o.cacheCtx, o, o._cacheData);\n        o.cacheCtx.restore();\n        // debug cacheCanvas\n        // document.body.appendChild(o.cacheCanvas)\n        if (o._readyToFilter) {\n          o.cacheCtx.putImageData((0, _index.filter)(o.cacheCtx.getImageData(0, 0, o.cacheCanvas.width, o.cacheCanvas.height), o._filterName), 0, 0);\n          this._readyToFilter = false;\n        }\n\n        ctx.drawImage(o.cacheCanvas, o._cacheData.x, o._cacheData.y);\n      } else if (o.cacheCanvas && !cacheData) {\n        this.setComplexProps(ctx, o);\n        ctx.drawImage(o.cacheCanvas, o._cacheData.x, o._cacheData.y);\n      } else if (o instanceof _group2.default) {\n        var list = o.children.slice(0),\n            l = list.length;\n        for (var i = 0; i < l; i++) {\n          ctx.save();\n          this._render(ctx, list[i], mtx);\n          ctx.restore();\n        }\n      } else if (o instanceof _graphics2.default) {\n        this.setComplexProps(ctx, o);\n        o.render(ctx);\n      } else if (o instanceof _sprite2.default && o.rect) {\n        this.setComplexProps(ctx, o);\n        o.updateFrame();\n        var rect = o.rect;\n        ctx.drawImage(o.img, rect[0], rect[1], rect[2], rect[3], 0, 0, rect[2], rect[3]);\n      } else if (o instanceof _bitmap2.default && o.rect) {\n        this.setComplexProps(ctx, o);\n        var bRect = o.rect;\n        ctx.drawImage(o.img, bRect[0], bRect[1], bRect[2], bRect[3], 0, 0, bRect[2], bRect[3]);\n      } else if (o instanceof _text2.default) {\n        this.setComplexProps(ctx, o);\n        ctx.font = o.font;\n        ctx.fillStyle = o.color;\n        ctx.textAlign = o.textAlign;\n        ctx.textBaseline = o.baseline;\n        ctx.fillText(o.text, 0, 0);\n      }\n    }\n  }, {\n    key: 'setComplexProps',\n    value: function setComplexProps(ctx, o) {\n      o.complexCompositeOperation = ctx.globalCompositeOperation = this.getCompositeOperation(o);\n      o.complexAlpha = ctx.globalAlpha = this.getAlpha(o, 1);\n\n      o.complexShadow = this.getShadow(o);\n      if (o.complexShadow) {\n        ctx.shadowColor = o.complexShadow.color;\n        ctx.shadowOffsetX = o.complexShadow.offsetX;\n        ctx.shadowOffsetY = o.complexShadow.offsetY;\n        ctx.shadowBlur = o.complexShadow.blur;\n      }\n    }\n  }, {\n    key: 'getCompositeOperation',\n    value: function getCompositeOperation(o) {\n      if (o.compositeOperation) return o.compositeOperation;\n      if (o.parent) return this.getCompositeOperation(o.parent);\n    }\n  }, {\n    key: 'getAlpha',\n    value: function getAlpha(o, alpha) {\n      var result = o.alpha * alpha;\n      if (o.parent) {\n        return this.getAlpha(o.parent, result);\n      }\n      return result;\n    }\n  }, {\n    key: 'getShadow',\n    value: function getShadow(o) {\n      if (o.shadow) return o.shadow;\n      if (o.parent) return this.getShadow(o.parent);\n    }\n  }]);\n\n  return CanvasRender;\n}(_render3.default);\n\nexports.default = CanvasRender;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.filter = filter;\n\nvar _invert = __webpack_require__(27);\n\nvar _blur = __webpack_require__(28);\n\nvar _brightness = __webpack_require__(30);\n\nvar _contrast = __webpack_require__(31);\n\nvar _grayscale = __webpack_require__(32);\n\nvar _sepia = __webpack_require__(33);\n\nvar _threshold = __webpack_require__(34);\n\nvar _gamma = __webpack_require__(35);\n\nvar _colorize = __webpack_require__(36);\n\nfunction filter(pixels, name) {\n  if (typeof name === 'string') {\n    var type = name.split('(')[0];\n    var num = getNumber(name);\n    switch (type) {\n      case 'invert':\n        return (0, _invert.invert)(pixels, num);\n      case 'brightness':\n        return (0, _brightness.brightness)(pixels, -255 + num * 255);\n      case 'blur':\n        return (0, _blur.blur)(pixels, num);\n      case 'contrast':\n        return (0, _contrast.contrast)(pixels, -255 + num * 255);\n      case 'grayscale':\n        return (0, _grayscale.grayscale)(pixels, num);\n      case 'sepia':\n        return (0, _sepia.sepia)(pixels, num);\n      case 'threshold':\n        return (0, _threshold.threshold)(pixels, num);\n      case 'gamma':\n        return (0, _gamma.gamma)(pixels, num);\n    }\n  } else {\n    switch (name.type) {\n      case 'colorize':\n        return (0, _colorize.colorize)(pixels, name);\n    }\n  }\n}\n\nfunction getNumber(str) {\n  str = str.replace(/(invert)|(brightness)|(blur)|(contrast)|(grayscale)|(sepia)|(threshold)|(gamma)?\\(/g, '').replace(')', '');\n  if (str.indexOf('%') !== -1) {\n    return Number(str.replace('%', '')) / 100;\n  } else if (str.indexOf('px') !== -1) {\n    return Number(str.replace('px', ''));\n  } else {\n    return Number(str);\n  }\n}\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.invert = invert;\nfunction invert(pixels, ratio) {\n  var d = pixels.data;\n  ratio = ratio === undefined ? 1 : ratio;\n  for (var i = 0; i < d.length; i += 4) {\n    d[i] = d[i] + ratio * (255 - 2 * d[i]);\n    d[i + 1] = d[i + 1] + ratio * (255 - 2 * d[i + 1]);\n    d[i + 2] = d[i + 2] + ratio * (255 - 2 * d[i + 2]);\n  }\n  return pixels;\n}\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.blur = blur;\n\nvar _createImageData = __webpack_require__(29);\n\nfunction blur(pixels, diameter) {\n  diameter = Math.abs(diameter);\n  if (diameter <= 1) return pixels;\n  var radius = diameter / 2;\n  var len = Math.ceil(diameter) + (1 - Math.ceil(diameter) % 2);\n  var weights = new Float32Array(len);\n  var rho = (radius + 0.5) / 3;\n  var rhoSq = rho * rho;\n  var gaussianFactor = 1 / Math.sqrt(2 * Math.PI * rhoSq);\n  var rhoFactor = -1 / (2 * rho * rho);\n  var wsum = 0;\n  var middle = Math.floor(len / 2);\n  for (var i = 0; i < len; i++) {\n    var x = i - middle;\n    var gx = gaussianFactor * Math.exp(x * x * rhoFactor);\n    weights[i] = gx;\n    wsum += gx;\n  }\n  for (var i = 0; i < weights.length; i++) {\n    weights[i] /= wsum;\n  }\n  return separableConvolve(pixels, weights, weights, false);\n}\n\nfunction separableConvolve(pixels, horizWeights, vertWeights, opaque) {\n  return horizontalConvolve(verticalConvolve(pixels, vertWeights, opaque), horizWeights, opaque);\n}\n\nfunction horizontalConvolve(pixels, weightsVector, opaque) {\n  var side = weightsVector.length;\n  var halfSide = Math.floor(side / 2);\n\n  var src = pixels.data;\n  var sw = pixels.width;\n  var sh = pixels.height;\n\n  var w = sw;\n  var h = sh;\n  var output = (0, _createImageData.createImageData)(w, h);\n  var dst = output.data;\n\n  var alphaFac = opaque ? 1 : 0;\n\n  for (var y = 0; y < h; y++) {\n    for (var x = 0; x < w; x++) {\n      var sy = y;\n      var sx = x;\n      var dstOff = (y * w + x) * 4;\n      var r = 0,\n          g = 0,\n          b = 0,\n          a = 0;\n      for (var cx = 0; cx < side; cx++) {\n        var scy = sy;\n        var scx = Math.min(sw - 1, Math.max(0, sx + cx - halfSide));\n        var srcOff = (scy * sw + scx) * 4;\n        var wt = weightsVector[cx];\n        r += src[srcOff] * wt;\n        g += src[srcOff + 1] * wt;\n        b += src[srcOff + 2] * wt;\n        a += src[srcOff + 3] * wt;\n      }\n      dst[dstOff] = r;\n      dst[dstOff + 1] = g;\n      dst[dstOff + 2] = b;\n      dst[dstOff + 3] = a + alphaFac * (255 - a);\n    }\n  }\n  return output;\n}\n\nfunction verticalConvolve(pixels, weightsVector, opaque) {\n  var side = weightsVector.length;\n  var halfSide = Math.floor(side / 2);\n\n  var src = pixels.data;\n  var sw = pixels.width;\n  var sh = pixels.height;\n\n  var w = sw;\n  var h = sh;\n  var output = (0, _createImageData.createImageData)(w, h);\n  var dst = output.data;\n\n  var alphaFac = opaque ? 1 : 0;\n\n  for (var y = 0; y < h; y++) {\n    for (var x = 0; x < w; x++) {\n      var sy = y;\n      var sx = x;\n      var dstOff = (y * w + x) * 4;\n      var r = 0,\n          g = 0,\n          b = 0,\n          a = 0;\n      for (var cy = 0; cy < side; cy++) {\n        var scy = Math.min(sh - 1, Math.max(0, sy + cy - halfSide));\n        var scx = sx;\n        var srcOff = (scy * sw + scx) * 4;\n        var wt = weightsVector[cy];\n        r += src[srcOff] * wt;\n        g += src[srcOff + 1] * wt;\n        b += src[srcOff + 2] * wt;\n        a += src[srcOff + 3] * wt;\n      }\n      dst[dstOff] = r;\n      dst[dstOff + 1] = g;\n      dst[dstOff + 2] = b;\n      dst[dstOff + 3] = a + alphaFac * (255 - a);\n    }\n  }\n  return output;\n};\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createImageData = createImageData;\nvar tmpCtx = null;\n\nif (typeof document !== 'undefined') {\n  tmpCtx = document.createElement('canvas').getContext('2d');\n} else if (typeof wx !== 'undefined' && wx.createCanvas) {\n  tmpCtx = wx.createCanvas().getContext('2d');\n}\n\nfunction createImageData(w, h) {\n  return tmpCtx.createImageData(w, h);\n}\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.brightness = brightness;\nfunction brightness(pixels, adjustment) {\n  var data = pixels.data;\n  var length = data.length;\n  for (var i = 0; i < length; i += 4) {\n    data[i] += adjustment;\n    data[i + 1] += adjustment;\n    data[i + 2] += adjustment;\n  }\n  return pixels;\n}\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.contrast = contrast;\nfunction contrast(pixels, contrast) {\n  var data = pixels.data;\n  var length = data.length;\n  var factor = 259 * (contrast + 255) / (255 * (259 - contrast));\n\n  for (var i = 0; i < length; i += 4) {\n    data[i] = factor * (data[i] - 128) + 128;\n    data[i + 1] = factor * (data[i + 1] - 128) + 128;\n    data[i + 2] = factor * (data[i + 2] - 128) + 128;\n  }\n\n  return pixels;\n};\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.grayscale = grayscale;\nfunction grayscale(pixels, adjustment) {\n  var data = pixels.data;\n  var length = data.length;\n  for (var i = 0; i < length; i += 4) {\n    var r = data[i];\n    var g = data[i + 1];\n    var b = data[i + 2];\n\n    // CIE luminance for the RGB\n    // The human eye is bad at seeing red and blue, so we de-emphasize them.\n    var v = 0.2126 * r + 0.7152 * g + 0.0722 * b;\n    data[i] = r + (v - r) * adjustment;\n    data[i + 1] = g + (v - g) * adjustment;\n    data[i + 2] = b + (v - b) * adjustment;\n  }\n  return pixels;\n};\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sepia = sepia;\nfunction sepia(pixels, adjustment) {\n  var data = pixels.data;\n  var length = data.length;\n  for (var i = 0; i < length; i += 4) {\n    var r = data[i];\n    var g = data[i + 1];\n    var b = data[i + 2];\n\n    var sr = r * 0.393 + g * 0.769 + b * 0.189;\n    var sg = r * 0.349 + g * 0.686 + b * 0.168;\n    var sb = r * 0.272 + g * 0.534 + b * 0.131;\n\n    data[i] = r + (sr - r) * adjustment;\n    data[i + 1] = g + (sg - g) * adjustment;\n    data[i + 2] = b + (sb - b) * adjustment;\n  }\n\n  return pixels;\n};\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.threshold = threshold;\nfunction threshold(pixels, threshold) {\n  var data = pixels.data;\n  var length = data.length;\n  for (var i = 0; i < length; i += 4) {\n    var r = data[i];\n    var g = data[i + 1];\n    var b = data[i + 2];\n    var v = 0.2126 * r + 0.7152 * g + 0.0722 * b >= threshold ? 255 : 0;\n    data[i] = data[i + 1] = data[i + 2] = v;\n  }\n  return pixels;\n};\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.gamma = gamma;\nfunction gamma(pixels, adjustment) {\n  var data = pixels.data;\n  var length = data.length;\n  for (var i = 0; i < length; i += 4) {\n    data[i] = Math.pow(data[i] / 255, adjustment) * 255;\n    data[i + 1] = Math.pow(data[i + 1] / 255, adjustment) * 255;\n    data[i + 2] = Math.pow(data[i + 2] / 255, adjustment) * 255;\n  }\n  return pixels;\n};\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.colorize = colorize;\nfunction colorize(pixels, option) {\n  var data = pixels.data;\n  var length = data.length;\n  var hex = option.color.charAt(0) === '#' ? option.color.substr(1) : option.color;\n  var colorRGB = {\n    r: parseInt(hex.substr(0, 2), 16),\n    g: parseInt(hex.substr(2, 2), 16),\n    b: parseInt(hex.substr(4, 2), 16)\n  };\n\n  for (var i = 0; i < length; i += 4) {\n    data[i] -= (data[i] - colorRGB.r) * option.amount;\n    data[i + 1] -= (data[i + 1] - colorRGB.g) * option.amount;\n    data[i + 2] -= (data[i + 2] - colorRGB.b) * option.amount;\n  }\n\n  return pixels;\n};\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _group = __webpack_require__(1);\n\nvar _group2 = _interopRequireDefault(_group);\n\nvar _graphics = __webpack_require__(4);\n\nvar _graphics2 = _interopRequireDefault(_graphics);\n\nvar _render = __webpack_require__(8);\n\nvar _render2 = _interopRequireDefault(_render);\n\nvar _event = __webpack_require__(7);\n\nvar _event2 = _interopRequireDefault(_event);\n\nvar _sprite = __webpack_require__(6);\n\nvar _sprite2 = _interopRequireDefault(_sprite);\n\nvar _bitmap = __webpack_require__(2);\n\nvar _bitmap2 = _interopRequireDefault(_bitmap);\n\nvar _text = __webpack_require__(5);\n\nvar _text2 = _interopRequireDefault(_text);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar HitRender = function (_Render) {\n  _inherits(HitRender, _Render);\n\n  function HitRender() {\n    _classCallCheck(this, HitRender);\n\n    var _this = _possibleConstructorReturn(this, (HitRender.__proto__ || Object.getPrototypeOf(HitRender)).call(this));\n\n    if (typeof wx !== 'undefined' && wx.createCanvas) {\n      _this.canvas = wx.createCanvas();\n    } else {\n      _this.canvas = document.createElement('canvas');\n    }\n\n    _this.canvas.width = 1;\n    _this.canvas.height = 1;\n    _this.ctx = _this.canvas.getContext('2d');\n\n    // debug event\n    // this.canvas.width = 441\n    // this.canvas.height = 441\n    // this.ctx = this.canvas.getContext('2d')\n    // document.body.appendChild(this.canvas)\n\n    _this.disableEvents = ['mouseover', 'mouseout', 'mousemove', 'touchmove'];\n    return _this;\n  }\n\n  _createClass(HitRender, [{\n    key: 'clear',\n    value: function clear() {\n      this.ctx.clearRect(0, 0, this.width, this.height);\n    }\n  }, {\n    key: 'hitAABB',\n    value: function hitAABB(o, evt) {\n      var list = o.children.slice(0),\n          l = list.length;\n      for (var i = l - 1; i >= 0; i--) {\n        var child = list[i];\n        // if (!this.isbindingEvent(child)) continue;\n        var target = this._hitAABB(child, evt);\n        if (target) return target;\n      }\n    }\n  }, {\n    key: '_hitAABB',\n    value: function _hitAABB(o, evt) {\n      if (o.ignoreHit || !o.isVisible()) {\n        return;\n      }\n      if (o instanceof _group2.default) {\n        var list = o.children.slice(0),\n            l = list.length;\n        for (var i = l - 1; i >= 0; i--) {\n          var child = list[i];\n          var target = this._hitAABB(child, evt);\n          if (target) return target;\n        }\n      } else {\n        if (o.AABB && this.checkPointInAABB(evt.stageX, evt.stageY, o.AABB)) {\n          // this._bubbleEvent(o, type, evt);\n          this._dispatchEvent(o, evt);\n          return o;\n        }\n      }\n    }\n  }, {\n    key: 'checkPointInAABB',\n    value: function checkPointInAABB(x, y, AABB) {\n      var minX = AABB[0];\n      if (x < minX) return false;\n      var minY = AABB[1];\n      if (y < minY) return false;\n      var maxX = minX + AABB[2];\n      if (x > maxX) return false;\n      var maxY = minY + AABB[3];\n      if (y > maxY) return false;\n      return true;\n    }\n  }, {\n    key: 'hitPixel',\n    value: function hitPixel(o, evt) {\n      var ctx = this.ctx;\n      ctx.clearRect(0, 0, 2, 2);\n      var mtx = o._hitMatrix;\n      var list = o.children.slice(0),\n          l = list.length;\n      for (var i = l - 1; i >= 0; i--) {\n        var child = list[i];\n        mtx.initialize(1, 0, 0, 1, 0, 0);\n        mtx.appendTransform(o.x - evt.stageX, o.y - evt.stageY, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.originX, o.originY);\n        // if (!this.checkBoundEvent(child)) continue\n        ctx.save();\n        var target = this._hitPixel(child, evt, mtx);\n        ctx.restore();\n        if (target) return target;\n      }\n    }\n  }, {\n    key: '_hitPixel',\n    value: function _hitPixel(o, evt, mtx) {\n      if (o.ignoreHit || !o.isVisible()) return;\n      var ctx = this.ctx;\n      if (mtx && !o.fixed) {\n        o._hitMatrix.initialize(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\n      } else {\n        o._hitMatrix.initialize(1, 0, 0, 1, 0, 0);\n      }\n      mtx = o._hitMatrix;\n      mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.originX, o.originY);\n\n      var ocg = o.clipGraphics;\n      if (ocg) {\n        ctx.beginPath();\n        ocg._matrix.copy(mtx);\n        ocg._matrix.appendTransform(ocg.x, ocg.y, ocg.scaleX, ocg.scaleY, ocg.rotation, ocg.skewX, ocg.skewY, ocg.originX, ocg.originY);\n        ctx.setTransform(ocg._matrix.a, ocg._matrix.b, ocg._matrix.c, ocg._matrix.d, ocg._matrix.tx, ocg._matrix.ty);\n        ocg.render(ctx);\n        ctx.clip(o.clipRuleNonzero ? 'nonzero' : 'evenodd');\n      }\n\n      var oacg = o.absClipGraphics;\n      if (oacg) {\n        ctx.beginPath();\n        oacg._matrix.initialize(1, 0, 0, 1, 0, 0);\n        oacg._matrix.appendTransform(oacg.x, oacg.y, oacg.scaleX, oacg.scaleY, oacg.rotation, oacg.skewX, oacg.skewY, oacg.originX, oacg.originY);\n        ctx.setTransform(oacg._matrix.a, oacg._matrix.b, oacg._matrix.c, oacg._matrix.d, oacg._matrix.tx, oacg._matrix.ty);\n        oacg.render(ctx);\n        ctx.clip(o.absClipRuleNonzero ? 'nonzero' : 'evenodd');\n      }\n\n      if (o.cacheCanvas) {\n        ctx.setTransform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\n        ctx.drawImage(o.cacheCanvas, o._cacheData.x, o._cacheData.y);\n      } else if (o instanceof _group2.default) {\n        var list = o.children.slice(0),\n            l = list.length;\n        for (var i = l - 1; i >= 0; i--) {\n          ctx.save();\n          var target = this._hitPixel(list[i], evt, mtx);\n          ctx.restore();\n          if (target) return target;\n        }\n      } else {\n        ctx.setTransform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\n        if (o instanceof _graphics2.default) {\n          this.setComplexProps(ctx, o);\n\n          o.render(ctx);\n        } else if (o instanceof _sprite2.default && o.rect) {\n          this.setComplexProps(ctx, o);\n\n          o.updateFrame();\n          var rect = o.rect;\n          ctx.drawImage(o.img, rect[0], rect[1], rect[2], rect[3], 0, 0, rect[2], rect[3]);\n        } else if (o instanceof _bitmap2.default && o.rect) {\n          this.setComplexProps(ctx, o);\n\n          var bRect = o.rect;\n          ctx.drawImage(o.img, bRect[0], bRect[1], bRect[2], bRect[3], 0, 0, bRect[2], bRect[3]);\n        } else if (o instanceof _text2.default) {\n          this.setComplexProps(ctx, o);\n\n          ctx.font = o.font;\n          ctx.fillStyle = o.color;\n          ctx.textAlign = o.textAlign;\n          ctx.textBaseline = o.baseline;\n          ctx.fillText(o.text, 0, 0);\n        }\n      }\n\n      if (ctx.getImageData(0, 0, 1, 1).data[3] > 1) {\n        this._dispatchEvent(o, evt);\n        return o;\n      }\n    }\n  }, {\n    key: 'setComplexProps',\n    value: function setComplexProps(ctx, o) {\n      ctx.globalCompositeOperation = o.complexCompositeOperation;\n      ctx.globalAlpha = o.complexAlpha;\n      // The shadow does not trigger the event, so remove it\n      // if(o.complexShadow){\n      //   ctx.shadowColor = o.complexShadow.color\n      //   ctx.shadowOffsetX = o.complexShadow.offsetX\n      //   ctx.shadowOffsetY = o.complexShadow.offsetY\n      //   ctx.shadowBlur = o.complexShadow.blur\n      // }\n    }\n  }, {\n    key: '_dispatchEvent',\n    value: function _dispatchEvent(obj, evt) {\n      if (this.disableEvents.indexOf(evt.type) !== -1) return;\n      var mockEvt = new _event2.default();\n      mockEvt.stageX = evt.stageX;\n      mockEvt.stageY = evt.stageY;\n      mockEvt.pureEvent = evt;\n      mockEvt.type = evt.type;\n      obj.dispatchEvent(mockEvt);\n    }\n  }]);\n\n  return HitRender;\n}(_render2.default);\n\nexports.default = HitRender;\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _graphics = __webpack_require__(4);\n\nvar _graphics2 = _interopRequireDefault(_graphics);\n\nvar _render = __webpack_require__(8);\n\nvar _render2 = _interopRequireDefault(_render);\n\nvar _event = __webpack_require__(7);\n\nvar _event2 = _interopRequireDefault(_event);\n\nvar _sprite = __webpack_require__(6);\n\nvar _sprite2 = _interopRequireDefault(_sprite);\n\nvar _bitmap = __webpack_require__(2);\n\nvar _bitmap2 = _interopRequireDefault(_bitmap);\n\nvar _text = __webpack_require__(5);\n\nvar _text2 = _interopRequireDefault(_text);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar WxHitRender = function (_Render) {\n  _inherits(WxHitRender, _Render);\n\n  function WxHitRender(ctx, component, canvasId) {\n    _classCallCheck(this, WxHitRender);\n\n    var _this = _possibleConstructorReturn(this, (WxHitRender.__proto__ || Object.getPrototypeOf(WxHitRender)).call(this));\n\n    _this.ctx = ctx;\n    _this._isWeapp = true;\n    _this._component = component;\n    _this._hitCanvasId = canvasId + 'Hit';\n\n    _this.disableEvents = ['mouseover', 'mouseout', 'mousemove', 'touchmove'];\n    return _this;\n  }\n\n  _createClass(WxHitRender, [{\n    key: 'clear',\n    value: function clear() {\n      this.ctx.clearRect(0, 0, 2, 2);\n    }\n  }, {\n    key: 'hitAABB',\n    value: function hitAABB(list, evt, cb) {\n      var len = list.length;\n      for (var i = len - 1; i >= 0; i--) {\n        var o = list[i];\n\n        if (o.AABB && this.checkPointInAABB(evt.stageX, evt.stageY, o.AABB)) {\n          this._dispatchEvent(o, evt);\n          cb(o);\n          return o;\n        }\n      }\n    }\n  }, {\n    key: 'checkPointInAABB',\n    value: function checkPointInAABB(x, y, AABB) {\n      var minX = AABB[0];\n      if (x < minX) return false;\n      var minY = AABB[1];\n      if (y < minY) return false;\n      var maxX = minX + AABB[2];\n      if (x > maxX) return false;\n      var maxY = minY + AABB[3];\n      if (y > maxY) return false;\n      return true;\n    }\n  }, {\n    key: 'hit',\n    value: function hit(list, evt, cb, current) {\n      var _this2 = this;\n\n      var ctx = this.ctx;\n      var obj = list[current];\n      var mtx = obj._hitMatrix.initialize(1, 0, 0, 1, 0, 0);\n      ctx.save();\n      mtx.appendTransform(obj.x - evt.stageX, obj.y - evt.stageY, obj.scaleX, obj.scaleY, obj.rotation, obj.skewX, obj.skewY, obj.originX, obj.originY);\n      ctx.globalCompositeOperation = obj.complexCompositeOperation;\n      ctx.globalAlpha = obj.complexAlpha;\n      ctx.setTransform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\n      if (obj instanceof _graphics2.default) {\n        obj.render(ctx);\n      } else if (obj instanceof _sprite2.default && obj.rect) {\n        obj.updateFrame();\n        var rect = obj.rect;\n        ctx.drawImage(obj.img, rect[0], rect[1], rect[2], rect[3], 0, 0, rect[2], rect[3]);\n      } else if (obj instanceof _bitmap2.default && obj.rect) {\n        var bRect = obj.rect;\n        ctx.drawImage(obj.img, bRect[0], bRect[1], bRect[2], bRect[3], 0, 0, bRect[2], bRect[3]);\n      } else if (obj instanceof _text2.default) {\n        ctx.font = obj.font;\n        ctx.fillStyle = obj.color;\n        ctx.textAlign = obj.textAlign;\n        ctx.fillText(obj.text, 0, 0);\n      }\n      ctx.restore();\n      current--;\n      ctx.draw(false, function () {\n        wx.canvasGetImageData({\n          canvasId: _this2._hitCanvasId,\n          x: 0,\n          y: 0,\n          width: 1,\n          height: 1,\n          success: function success(res) {\n            if (res.data[3] > 1) {\n              _this2._dispatchEvent(obj, evt);\n              cb(obj);\n            } else {\n              if (current > -1) {\n                _this2.hit(list, evt, cb, current);\n              }\n            }\n          }\n        }, _this2._component);\n      });\n    }\n  }, {\n    key: '_dispatchEvent',\n    value: function _dispatchEvent(obj, evt) {\n      if (this.disableEvents.indexOf(evt.type) !== -1) return;\n      var mockEvt = new _event2.default();\n      mockEvt.stageX = evt.stageX;\n      mockEvt.stageY = evt.stageY;\n      mockEvt.pureEvent = evt;\n      mockEvt.type = evt.type;\n      obj.dispatchEvent(mockEvt);\n    }\n  }]);\n\n  return WxHitRender;\n}(_render2.default);\n\nexports.default = WxHitRender;\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _shape = __webpack_require__(0);\n\nvar _shape2 = _interopRequireDefault(_shape);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ArrowPath = function (_Shape) {\n  _inherits(ArrowPath, _Shape);\n\n  function ArrowPath(path, option) {\n    _classCallCheck(this, ArrowPath);\n\n    var _this = _possibleConstructorReturn(this, (ArrowPath.__proto__ || Object.getPrototypeOf(ArrowPath)).call(this));\n\n    _this.path = path;\n    _this.option = Object.assign({\n      strokeStyle: 'black',\n      lineWidth: 1,\n      headSize: 10\n    }, option);\n    return _this;\n  }\n\n  _createClass(ArrowPath, [{\n    key: 'draw',\n    value: function draw() {\n      var path = this.path;\n      this.beginPath();\n      var len = path.length;\n      if (len === 2) {\n        this.drawArrow(path[0].x, path[0].y, path[1].x, path[1].y, 30);\n      } else {\n        this.moveTo(path[0].x, path[0].y);\n        for (var i = 1; i < len - 1; i++) {\n          this.lineTo(path[i].x, path[i].y);\n        }\n        this.drawArrow(path[len - 2].x, path[len - 2].y, path[len - 1].x, path[len - 1].y, 30);\n      }\n\n      this.stroke();\n    }\n  }, {\n    key: 'drawArrow',\n    value: function drawArrow(fromX, fromY, toX, toY, theta) {\n      var angle = Math.atan2(fromY - toY, fromX - toX) * 180 / Math.PI,\n          angle1 = (angle + theta) * Math.PI / 180,\n          angle2 = (angle - theta) * Math.PI / 180,\n          hs = this.option.headSize,\n          topX = hs * Math.cos(angle1),\n          topY = hs * Math.sin(angle1),\n          botX = hs * Math.cos(angle2),\n          botY = hs * Math.sin(angle2);\n\n      var arrowX = fromX - topX,\n          arrowY = fromY - topY;\n\n      this.moveTo(arrowX, arrowY);\n      this.moveTo(fromX, fromY);\n      this.lineTo(toX, toY);\n      arrowX = toX + topX;\n      arrowY = toY + topY;\n      this.moveTo(arrowX, arrowY);\n      this.lineTo(toX, toY);\n      arrowX = toX + botX;\n      arrowY = toY + botY;\n      this.lineTo(arrowX, arrowY);\n      this.strokeStyle(this.option.strokeStyle);\n      this.lineWidth(this.option.lineWidth);\n    }\n  }]);\n\n  return ArrowPath;\n}(_shape2.default);\n\nexports.default = ArrowPath;\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _shape = __webpack_require__(0);\n\nvar _shape2 = _interopRequireDefault(_shape);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Ellipse = function (_Shape) {\n  _inherits(Ellipse, _Shape);\n\n  function Ellipse(width, height, option) {\n    _classCallCheck(this, Ellipse);\n\n    var _this = _possibleConstructorReturn(this, (Ellipse.__proto__ || Object.getPrototypeOf(Ellipse)).call(this));\n\n    _this.option = option || {};\n    _this.width = width;\n    _this.height = height;\n    return _this;\n  }\n\n  _createClass(Ellipse, [{\n    key: 'draw',\n    value: function draw() {\n      var w = this.width;\n      var h = this.height;\n      var k = 0.5522848;\n      var ox = w / 2 * k;\n      var oy = h / 2 * k;\n      var xe = w;\n      var ye = h;\n      var xm = w / 2;\n      var ym = h / 2;\n\n      this.beginPath();\n      this.moveTo(0, ym);\n      this.bezierCurveTo(0, ym - oy, xm - ox, 0, xm, 0);\n      this.bezierCurveTo(xm + ox, 0, xe, ym - oy, xe, ym);\n      this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n      this.bezierCurveTo(xm - ox, ye, 0, ym + oy, 0, ym);\n\n      if (this.option.strokeStyle) {\n        if (this.option.lineWidth !== undefined) {\n          this.lineWidth(this.option.lineWidth);\n        }\n        this.strokeStyle(this.option.strokeStyle);\n        this.stroke();\n      }\n\n      if (this.option.fillStyle) {\n        this.fillStyle(this.option.fillStyle);\n        this.fill();\n      }\n    }\n  }]);\n\n  return Ellipse;\n}(_shape2.default);\n\nexports.default = Ellipse;\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _pathParser = __webpack_require__(42);\n\nvar _pathParser2 = _interopRequireDefault(_pathParser);\n\nvar _shape = __webpack_require__(0);\n\nvar _shape2 = _interopRequireDefault(_shape);\n\nvar _arcToBezier = __webpack_require__(43);\n\nvar _arcToBezier2 = _interopRequireDefault(_arcToBezier);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Path = function (_Shape) {\n  _inherits(Path, _Shape);\n\n  function Path(d, option) {\n    _classCallCheck(this, Path);\n\n    var _this = _possibleConstructorReturn(this, (Path.__proto__ || Object.getPrototypeOf(Path)).call(this));\n\n    _this.d = d;\n\n    option = Object.assign({\n      lineWidth: 1\n    }, option);\n    _this.option = option;\n    return _this;\n  }\n\n  _createClass(Path, [{\n    key: 'draw',\n    value: function draw() {\n      var _this2 = this;\n\n      var cmds = (0, _pathParser2.default)(this.d);\n\n      this.beginPath();\n      // https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths\n      // M = moveto\n      // L = lineto\n      // H = horizontal lineto\n      // V = vertical lineto\n      // C = curveto\n      // S = smooth curveto\n      // Q = quadratic Belzier curve\n      // T = smooth quadratic Belzier curveto\n      // A = elliptical Arc  暂时未实现，用贝塞尔拟合椭圆\n      // Z = closepath\n      // 以上所有命令均允许小写字母。大写表示绝对定位，小写表示相对定位(从上一个点开始)。\n      var preX = void 0,\n          preY = void 0,\n          curves = void 0,\n          lastCurve = void 0;\n\n      // 参考我的 pasition https://github.com/AlloyTeam/pasition/blob/master/src/index.js\n      for (var j = 0, cmdLen = cmds.length; j < cmdLen; j++) {\n        var item = cmds[j];\n        var action = item[0];\n        var preItem = cmds[j - 1];\n\n        switch (action) {\n          case 'M':\n            preX = item[1];\n            preY = item[2];\n            this.moveTo(preX, preY);\n            break;\n          case 'L':\n            preX = item[1];\n            preY = item[2];\n            this.lineTo(preX, preY);\n            break;\n          case 'H':\n            preX = item[1];\n            this.lineTo(preX, preY);\n            break;\n          case 'V':\n            preY = item[1];\n            this.lineTo(preX, preY);\n            break;\n          case 'C':\n            preX = item[5];\n            preY = item[6];\n            this.bezierCurveTo(item[1], item[2], item[3], item[4], preX, preY);\n            break;\n          case 'S':\n\n            if (preItem[0] === 'C' || preItem[0] === 'c') {\n              this.bezierCurveTo(preX + preItem[5] - preItem[3], preY + preItem[6] - preItem[4], item[1], item[2], item[3], item[4]);\n            } else if (preItem[0] === 'S' || preItem[0] === 's') {\n              this.bezierCurveTo(preX + preItem[3] - preItem[1], preY + preItem[4] - preItem[2], item[1], item[2], item[3], item[4]);\n            }\n            preX = item[3];\n            preY = item[4];\n            break;\n\n          case 'Q':\n            preX = item[3];\n            preY = item[4];\n            this.quadraticCurveTo(item[1], item[2], preX, preY);\n            break;\n\n          case 'm':\n            preX += item[1];\n            preY += item[2];\n            this.moveTo(preX, preY);\n            break;\n          case 'l':\n            preX += item[1];\n            preY += item[2];\n            this.lineTo(preX, preY);\n            break;\n          case 'h':\n            preX += item[1];\n            this.lineTo(preX, preY);\n            break;\n          case 'v':\n            preY += item[1];\n            this.lineTo(preX, preY);\n            break;\n          case 'c':\n            this.bezierCurveTo(preX + item[1], preY + item[2], preX + item[3], preY + item[4], preX + item[5], preY + item[6]);\n            preX = preX + item[5];\n            preY = preY + item[6];\n            break;\n          case 's':\n            if (preItem[0] === 'C' || preItem[0] === 'c') {\n              this.bezierCurveTo(preX + preItem[5] - preItem[3], preY + preItem[6] - preItem[4], preX + item[1], preY + item[2], preX + item[3], preY + item[4]);\n            } else if (preItem[0] === 'S' || preItem[0] === 's') {\n              this.bezierCurveTo(preX + preItem[3] - preItem[1], preY + preItem[4] - preItem[2], preX + item[1], preY + item[2], preX + item[3], preY + item[4]);\n            }\n\n            preX += item[3];\n            preY += item[4];\n            break;\n          case 'q':\n\n            this.quadraticCurveTo(preX + item[1], preY + item[2], item[3] + preX, item[4] + preY);\n            preX += item[3];\n            preY += item[4];\n            break;\n          case 'Z':\n            this.closePath();\n            break;\n          case 'z':\n            this.closePath();\n            break;\n\n          case 'a':\n            curves = (0, _arcToBezier2.default)({\n              rx: item[1],\n              ry: item[2],\n              px: preX,\n              py: preY,\n              xAxisRotation: item[3],\n              largeArcFlag: item[4],\n              sweepFlag: item[5],\n              cx: preX + item[6],\n              cy: preX + item[7]\n            });\n            lastCurve = curves[curves.length - 1];\n\n            curves.forEach(function (curve, index) {\n              if (index === 0) {\n                _this2.moveTo(preX, preY);\n                _this2.bezierCurveTo(curve.x1, curve.y1, curve.x2, curve.y2, curve.x, curve.y);\n              } else {\n                //curves[index - 1].x, curves[index - 1].y, \n                _this2.bezierCurveTo(curve.x1, curve.y1, curve.x2, curve.y2, curve.x, curve.y);\n              }\n            });\n\n            preX = lastCurve.x;\n            preY = lastCurve.y;\n\n            break;\n\n          case 'A':\n\n            curves = (0, _arcToBezier2.default)({\n              rx: item[1],\n              ry: item[2],\n              px: preX,\n              py: preY,\n              xAxisRotation: item[3],\n              largeArcFlag: item[4],\n              sweepFlag: item[5],\n              cx: item[6],\n              cy: item[7]\n            });\n            lastCurve = curves[curves.length - 1];\n\n            curves.forEach(function (curve, index) {\n              if (index === 0) {\n                _this2.moveTo(preX, preY);\n                _this2.bezierCurveTo(curve.x1, curve.y1, curve.x2, curve.y2, curve.x, curve.y);\n              } else {\n                //curves[index - 1].x, curves[index - 1].y\n                _this2.bezierCurveTo(curve.x1, curve.y1, curve.x2, curve.y2, curve.x, curve.y);\n              }\n            });\n\n            preX = lastCurve.x;\n            preY = lastCurve.y;\n\n            break;\n\n          case 'T':\n\n            if (preItem[0] === 'Q' || preItem[0] === 'q') {\n              preCX = preX + preItem[3] - preItem[1];\n              preCY = preY + preItem[4] - preItem[2];\n              this.quadraticCurveTo(preX, preY, preCX, preCY, item[1], item[2]);\n            } else if (preItem[0] === 'T' || preItem[0] === 't') {\n              this.quadraticCurveTo(preX, preY, preX + preX - preCX, preY + preY - preCY, item[1], item[2]);\n              preCX = preX + preX - preCX;\n              preCY = preY + preY - preCY;\n            }\n\n            preX = item[1];\n            preY = item[2];\n            break;\n\n          case 't':\n            if (preItem[0] === 'Q' || preItem[0] === 'q') {\n              preCX = preX + preItem[3] - preItem[1];\n              preCY = preY + preItem[4] - preItem[2];\n              this.quadraticCurveTo(preX, preY, preCX, preCY, preX + item[1], preY + item[2]);\n            } else if (preItem[0] === 'T' || preItem[0] === 't') {\n              this.quadraticCurveTo(preX, preY, preX + preX - preCX, preY + preY - preCY, preX + item[1], preY + item[2]);\n              preCX = preX + preX - preCX;\n              preCY = preY + preY - preCY;\n            }\n\n            preX += item[1];\n            preY += item[2];\n            break;\n        }\n      }\n      if (this.option.fillStyle) {\n        this.fillStyle(this.option.fillStyle);\n        this.fill();\n      }\n\n      if (this.option.strokeStyle) {\n        this.lineWidth(this.option.lineWidth);\n        this.strokeStyle(this.option.strokeStyle);\n        this.stroke();\n      }\n    }\n  }]);\n\n  return Path;\n}(_shape2.default);\n\nexports.default = Path;\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// https://github.com/jkroso/parse-svg-path/blob/master/index.js\n/**\r\n * expected argument lengths\r\n * @type {Object}\r\n */\n\nvar length = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0\n\n  /**\r\n   * segment pattern\r\n   * @type {RegExp}\r\n   */\n\n};var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;\n\n/**\r\n * parse an svg path data string. Generates an Array\r\n * of commands where each command is an Array of the\r\n * form `[command, arg1, arg2, ...]`\r\n *\r\n * @param {String} path\r\n * @return {Array}\r\n */\n\nfunction parse(path) {\n  var data = [];\n  path.replace(segment, function (_, command, args) {\n    var type = command.toLowerCase();\n    args = parseValues(args);\n\n    // overloaded moveTo\n    if (type === 'm' && args.length > 2) {\n      data.push([command].concat(args.splice(0, 2)));\n      type = 'l';\n      command = command === 'm' ? 'l' : 'L';\n    }\n\n    while (true) {\n      if (args.length === length[type]) {\n        args.unshift(command);\n        return data.push(args);\n      }\n      if (args.length < length[type]) throw new Error('malformed path data');\n      data.push([command].concat(args.splice(0, length[type])));\n    }\n  });\n  return data;\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig;\n\nfunction parseValues(args) {\n  var numbers = args.match(number);\n  return numbers ? numbers.map(Number) : [];\n}\n\nexports.default = parse;\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n// https://github.com/colinmeinke/svg-arc-to-cubic-bezier\n\nvar TAU = Math.PI * 2;\n\nvar mapToEllipse = function mapToEllipse(_ref, rx, ry, cosphi, sinphi, centerx, centery) {\n  var x = _ref.x,\n      y = _ref.y;\n\n  x *= rx;\n  y *= ry;\n\n  var xp = cosphi * x - sinphi * y;\n  var yp = sinphi * x + cosphi * y;\n\n  return {\n    x: xp + centerx,\n    y: yp + centery\n  };\n};\n\nvar approxUnitArc = function approxUnitArc(ang1, ang2) {\n  var a = 4 / 3 * Math.tan(ang2 / 4);\n\n  var x1 = Math.cos(ang1);\n  var y1 = Math.sin(ang1);\n  var x2 = Math.cos(ang1 + ang2);\n  var y2 = Math.sin(ang1 + ang2);\n\n  return [{\n    x: x1 - y1 * a,\n    y: y1 + x1 * a\n  }, {\n    x: x2 + y2 * a,\n    y: y2 - x2 * a\n  }, {\n    x: x2,\n    y: y2\n  }];\n};\n\nvar vectorAngle = function vectorAngle(ux, uy, vx, vy) {\n  var sign = ux * vy - uy * vx < 0 ? -1 : 1;\n  var umag = Math.sqrt(ux * ux + uy * uy);\n  var vmag = Math.sqrt(ux * ux + uy * uy);\n  var dot = ux * vx + uy * vy;\n\n  var div = dot / (umag * vmag);\n\n  if (div > 1) {\n    div = 1;\n  }\n\n  if (div < -1) {\n    div = -1;\n  }\n\n  return sign * Math.acos(div);\n};\n\nvar getArcCenter = function getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {\n  var rxsq = Math.pow(rx, 2);\n  var rysq = Math.pow(ry, 2);\n  var pxpsq = Math.pow(pxp, 2);\n  var pypsq = Math.pow(pyp, 2);\n\n  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;\n\n  if (radicant < 0) {\n    radicant = 0;\n  }\n\n  radicant /= rxsq * pypsq + rysq * pxpsq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n\n  var centerxp = radicant * rx / ry * pyp;\n  var centeryp = radicant * -ry / rx * pxp;\n\n  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;\n  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;\n\n  var vx1 = (pxp - centerxp) / rx;\n  var vy1 = (pyp - centeryp) / ry;\n  var vx2 = (-pxp - centerxp) / rx;\n  var vy2 = (-pyp - centeryp) / ry;\n\n  var ang1 = vectorAngle(1, 0, vx1, vy1);\n  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n\n  return [centerx, centery, ang1, ang2];\n};\n\nvar arcToBezier = function arcToBezier(_ref2) {\n  var px = _ref2.px,\n      py = _ref2.py,\n      cx = _ref2.cx,\n      cy = _ref2.cy,\n      rx = _ref2.rx,\n      ry = _ref2.ry,\n      _ref2$xAxisRotation = _ref2.xAxisRotation,\n      xAxisRotation = _ref2$xAxisRotation === undefined ? 0 : _ref2$xAxisRotation,\n      _ref2$largeArcFlag = _ref2.largeArcFlag,\n      largeArcFlag = _ref2$largeArcFlag === undefined ? 0 : _ref2$largeArcFlag,\n      _ref2$sweepFlag = _ref2.sweepFlag,\n      sweepFlag = _ref2$sweepFlag === undefined ? 0 : _ref2$sweepFlag;\n\n  var curves = [];\n\n  if (rx === 0 || ry === 0) {\n    return [];\n  }\n\n  var sinphi = Math.sin(xAxisRotation * TAU / 360);\n  var cosphi = Math.cos(xAxisRotation * TAU / 360);\n\n  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;\n  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;\n\n  if (pxp === 0 && pyp === 0) {\n    return [];\n  }\n\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n\n  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n\n  var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp),\n      _getArcCenter2 = _slicedToArray(_getArcCenter, 4),\n      centerx = _getArcCenter2[0],\n      centery = _getArcCenter2[1],\n      ang1 = _getArcCenter2[2],\n      ang2 = _getArcCenter2[3];\n\n  var segments = Math.max(Math.ceil(Math.abs(ang2) / (TAU / 4)), 1);\n\n  ang2 /= segments;\n\n  for (var i = 0; i < segments; i++) {\n    curves.push(approxUnitArc(ang1, ang2));\n    ang1 += ang2;\n  }\n\n  return curves.map(function (curve) {\n    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery),\n        x1 = _mapToEllipse.x,\n        y1 = _mapToEllipse.y;\n\n    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery),\n        x2 = _mapToEllipse2.x,\n        y2 = _mapToEllipse2.y;\n\n    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery),\n        x = _mapToEllipse3.x,\n        y = _mapToEllipse3.y;\n\n    return { x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y };\n  });\n};\n\nexports.default = arcToBezier;\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _group = __webpack_require__(1);\n\nvar _group2 = _interopRequireDefault(_group);\n\nvar _text = __webpack_require__(5);\n\nvar _text2 = _interopRequireDefault(_text);\n\nvar _roundedRect = __webpack_require__(15);\n\nvar _roundedRect2 = _interopRequireDefault(_roundedRect);\n\nvar _bitmap2 = __webpack_require__(2);\n\nvar _bitmap3 = _interopRequireDefault(_bitmap2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/*\r\nOptions\r\n  font:\r\n  text: \r\n  textColor:\r\n  image: [path, width, height]\r\n  bgColor: \r\n  bgImage: [path, width, height]\r\n  borderRadius:\r\n  borderColor:\r\n*/\n\nvar Button = function (_Group) {\n  _inherits(Button, _Group);\n\n  function Button(option) {\n    _classCallCheck(this, Button);\n\n    var _this = _possibleConstructorReturn(this, (Button.__proto__ || Object.getPrototypeOf(Button)).call(this));\n\n    _this.width = option.width;\n    _this.height = option.height;\n    _this.x = option.x;\n    _this.y = option.y;\n\n    var textHeight = 0;\n    var textGroup;\n\n    if (option.text) {\n      textGroup = new _group2.default();\n      _this.text = new _text2.default(option.text, {\n        font: option.font,\n        color: option.color\n      });\n      var textWidth = _this.text.getWidth();\n\n      if (textWidth > option.width) {\n        var step = Math.round(option.text.length * option.width / textWidth / 2);\n\n        var textList = _this.stringSplit(option.text, step);\n        var lineHeight = option.lineHeight || 12;\n        textHeight = textList.length * lineHeight + 6;\n\n        textList.forEach(function (text, index) {\n          _this.text = new _text2.default(text, {\n            font: option.font,\n            color: option.color\n          });\n\n          _this.text.x = option.width / 2 - _this.text.getWidth() / 2 * _this.text.scaleX + (option.textX || 0);\n          _this.text.y = Math.max(textHeight, option.height) / 2 - 10 + 5 * _this.text.scaleY + (option.textY || 0) + index * 12 - textHeight / 2 + lineHeight / 2;\n          textGroup.add(_this.text);\n        });\n      } else {\n        _this.text.x = option.width / 2 - _this.text.getWidth() / 2 * _this.text.scaleX + (option.textX || 0);\n        _this.text.y = option.height / 2 - 10 + 5 * _this.text.scaleY + (option.textY || 0);\n        textGroup.add(_this.text);\n      }\n    }\n\n    if (option.bgImage) {\n      var ratio = SCALE_RATIO;\n      var bitmap = new _bitmap3.default(option.bgImage[0]);\n      bitmap.scaleX = ratio;\n      bitmap.scaleY = ratio;\n      bitmap.width = option.bgImage[1];\n      bitmap.height = option.bgImage[2];\n      bitmap.x = (_this.width - bitmap.width) / 2;\n      bitmap.y = (_this.height - bitmap.height) / 2;\n      _this.add(bitmap);\n    } else if (option.bgColor || option.borderColor) {\n      _this.roundedRect = new _roundedRect2.default(option.width, option.autoHeight ? Math.max(textHeight, option.height) : option.height, option.borderRadius, {\n        strokeStyle: option.borderColor || 'black',\n        fillStyle: option.backgroundColor || '#F5F5F5'\n      });\n      _this.add(_this.roundedRect);\n    }\n\n    if (option.image) {\n      var ratio = SCALE_RATIO;\n      var _bitmap = new _bitmap3.default(option.image[0]);\n      _bitmap.scaleX = ratio;\n      _bitmap.scaleY = ratio;\n      _bitmap.width = option.image[1];\n      _bitmap.height = option.image[2];\n      _bitmap.x = (_this.width - _bitmap.width) / 2;\n      _bitmap.y = (_this.height - _bitmap.height) / 2;\n      _this.add(_bitmap);\n    }\n\n    if (textGroup) {\n      _this.add(textGroup);\n    }\n    return _this;\n  }\n\n  _createClass(Button, [{\n    key: 'stringSplit',\n    value: function stringSplit(str, len) {\n      var arr = [],\n          offset = 0,\n          char_length = 0;\n      for (var i = 0; i < str.length; i++) {\n        var son_str = str.charAt(i);\n        encodeURI(son_str).length > 2 ? char_length += 1 : char_length += 0.5;\n        if (char_length >= len || char_length < len && i === str.length - 1) {\n          var sub_len = char_length == len ? i + 1 : i;\n          arr.push(str.substr(offset, sub_len - offset + (char_length < len && i === str.length - 1 ? 1 : 0)));\n          offset = i + 1;\n          char_length = 0;\n        }\n      }\n      return arr;\n    }\n  }]);\n\n  return Button;\n}(_group2.default);\n\nexports.default = Button;\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _shape = __webpack_require__(0);\n\nvar _shape2 = _interopRequireDefault(_shape);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Rect = function (_Shape) {\n  _inherits(Rect, _Shape);\n\n  function Rect(width, height, option) {\n    _classCallCheck(this, Rect);\n\n    var _this = _possibleConstructorReturn(this, (Rect.__proto__ || Object.getPrototypeOf(Rect)).call(this));\n\n    _this.width = width;\n    _this.height = height;\n    _this.option = option || {};\n    return _this;\n  }\n\n  _createClass(Rect, [{\n    key: 'draw',\n    value: function draw() {\n      if (this.option.fillStyle) {\n        this.fillStyle(this.option.fillStyle);\n        this.fillRect(0, 0, this.width, this.height);\n      }\n\n      if (this.option.strokeStyle) {\n        this.strokeStyle(this.option.strokeStyle);\n        this.strokeRect(0, 0, this.width, this.height);\n      }\n    }\n  }]);\n\n  return Rect;\n}(_shape2.default);\n\nexports.default = Rect;\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _shape = __webpack_require__(0);\n\nvar _shape2 = _interopRequireDefault(_shape);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Circle = function (_Shape) {\n  _inherits(Circle, _Shape);\n\n  function Circle(r, option) {\n    _classCallCheck(this, Circle);\n\n    var _this = _possibleConstructorReturn(this, (Circle.__proto__ || Object.getPrototypeOf(Circle)).call(this));\n\n    _this.option = option || {};\n    _this.r = r;\n\n    _this._dp = Math.PI * 2;\n    return _this;\n  }\n\n  _createClass(Circle, [{\n    key: 'draw',\n    value: function draw() {\n      this.beginPath();\n      this.arc(0, 0, this.r, 0, this._dp, false);\n\n      if (this.option.strokeStyle) {\n        if (this.option.lineWidth !== undefined) {\n          this.lineWidth(this.option.lineWidth);\n        }\n        this.strokeStyle(this.option.strokeStyle);\n        this.stroke();\n      }\n\n      if (this.option.fillStyle) {\n        this.fillStyle(this.option.fillStyle);\n        this.fill();\n      }\n    }\n  }]);\n\n  return Circle;\n}(_shape2.default);\n\nexports.default = Circle;\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _shape = __webpack_require__(0);\n\nvar _shape2 = _interopRequireDefault(_shape);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Polygon = function (_Shape) {\n  _inherits(Polygon, _Shape);\n\n  function Polygon(vertex, options) {\n    _classCallCheck(this, Polygon);\n\n    var _this = _possibleConstructorReturn(this, (Polygon.__proto__ || Object.getPrototypeOf(Polygon)).call(this));\n\n    _this.vertex = vertex || [];\n    _this.options = options || {};\n    _this.strokeColor = _this.options.strokeColor;\n    _this.fillColor = _this.options.fillColor;\n    return _this;\n  }\n\n  _createClass(Polygon, [{\n    key: 'draw',\n    value: function draw() {\n      this.clear().beginPath();\n      this.strokeStyle(this.strokeColor);\n      this.moveTo(this.vertex[0][0], this.vertex[0][1]);\n\n      for (var i = 1, len = this.vertex.length; i < len; i++) {\n        this.lineTo(this.vertex[i][0], this.vertex[i][1]);\n      }\n      this.closePath();\n      // 路径闭合\n      //  if (this.options.strokeStyle) {\n      //    this.strokeStyle = strokeStyle;\n      // this.lineWidth(this.options.width);\n      // this.lineJoin('round');\n      // this.stroke();\n      //  }\n      if (this.strokeColor) {\n        this.strokeStyle(this.strokeColor);\n        this.stroke();\n      }\n      if (this.fillColor) {\n        this.fillStyle(this.fillColor);\n        this.fill();\n      }\n    }\n  }]);\n\n  return Polygon;\n}(_shape2.default);\n\nexports.default = Polygon;\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _shape = __webpack_require__(0);\n\nvar _shape2 = _interopRequireDefault(_shape);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar EquilateralPolygon = function (_Shape) {\n  _inherits(EquilateralPolygon, _Shape);\n\n  function EquilateralPolygon(num, r, options) {\n    _classCallCheck(this, EquilateralPolygon);\n\n    var _this = _possibleConstructorReturn(this, (EquilateralPolygon.__proto__ || Object.getPrototypeOf(EquilateralPolygon)).call(this));\n\n    _this.num = num;\n    _this.r = r;\n    _this.options = options || {};\n\n    _this.vertex = [];\n    _this.initVertex();\n    return _this;\n  }\n\n  _createClass(EquilateralPolygon, [{\n    key: 'initVertex',\n    value: function initVertex() {\n      this.vertex.length = [];\n      var num = this.num;\n      var r = this.r;\n      var i = void 0,\n          startX = void 0,\n          startY = void 0,\n          newX = void 0,\n          newY = void 0;\n\n      if (num % 2 === 0) {\n        startX = r * Math.cos(2 * Math.PI * 0 / num);\n        startY = r * Math.sin(2 * Math.PI * 0 / num);\n\n        this.vertex.push([startX, startY]);\n        for (i = 1; i < num; i++) {\n          newX = r * Math.cos(2 * Math.PI * i / num);\n          newY = r * Math.sin(2 * Math.PI * i / num);\n\n          this.vertex.push([newX, newY]);\n        }\n      } else {\n        startX = r * Math.cos(2 * Math.PI * 0 / num - Math.PI / 2);\n        startY = r * Math.sin(2 * Math.PI * 0 / num - Math.PI / 2);\n\n        this.vertex.push([startX, startY]);\n        for (i = 1; i < num; i++) {\n          newX = r * Math.cos(2 * Math.PI * i / num - Math.PI / 2);\n          newY = r * Math.sin(2 * Math.PI * i / num - Math.PI / 2);\n\n          this.vertex.push([newX, newY]);\n        }\n      }\n    }\n  }, {\n    key: 'draw',\n    value: function draw() {\n      this.beginPath();\n\n      this.moveTo(this.vertex[0][0], this.vertex[0][1]);\n\n      for (var i = 1, len = this.vertex.length; i < len; i++) {\n        this.lineTo(this.vertex[i][0], this.vertex[i][1]);\n      }\n      this.closePath();\n\n      if (this.options.fillStyle) {\n        this.fillStyle(this.options.fillStyle);\n        this.fill();\n      }\n\n      if (this.options.strokeStyle) {\n        this.strokeStyle(this.options.strokeStyle);\n        if (typeof this.options.lineWidth === 'number') {\n          this.lineWidth(this.options.lineWidth);\n        }\n        this.stroke();\n      }\n    }\n  }]);\n\n  return EquilateralPolygon;\n}(_shape2.default);\n\nexports.default = EquilateralPolygon;\n\n/***/ })\n/******/ ]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLjEuMi45QGNheC9kaXN0L2NheC5qcz82YmE5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBS0E7QUFDQSxDQUFDO0FBQ0Qsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBCQUEwQixFQUFFO0FBQy9ELHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsK0RBQStEO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsZ0NBQWdDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRTs7QUFFampCLHFEQUFxRCxrREFBa0QsOERBQThELDBCQUEwQiw0Q0FBNEMsdUJBQXVCLGtCQUFrQixFQUFFLE9BQU8sd0NBQXdDLEVBQUUsRUFBRSw0QkFBNEIsbUJBQW1CLEVBQUUsT0FBTyx1QkFBdUIsNEJBQTRCLGtCQUFrQixFQUFFLDhCQUE4QixFQUFFOztBQUV4ZTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNB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Q0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGdDQUFnQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRSxFQUFFLHlEQUF5RCxxRUFBcUUsNkRBQTZELG9CQUFvQixHQUFHLEVBQUU7O0FBRWpqQjs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0YsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosaURBQWlELGFBQWEsdUZBQXVGLEVBQUUsdUZBQXVGOztBQUU5TywwQ0FBMEMsK0RBQStELHFHQUFxRyxFQUFFLHlFQUF5RSxlQUFlLHlFQUF5RSxFQUFFLEVBQUUsdUhBQXVIOztBQUU1ZTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsZ0NBQWdDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRTs7QUFFampCOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SixpREFBaUQsYUFBYSx1RkFBdUYsRUFBRSx1RkFBdUY7O0FBRTlPLDBDQUEwQywrREFBK0QscUdBQXFHLEVBQUUseUVBQXlFLGVBQWUseUVBQXlFLEVBQUUsRUFBRSx1SEFBdUg7O0FBRTVlOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsZ0NBQWdDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRTs7QUFFampCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SixpREFBaUQsYUFBYSx1RkFBdUYsRUFBRSx1RkFBdUY7O0FBRTlPLDBDQUEwQywrREFBK0QscUdBQXFHLEVBQUUseUVBQXlFLGVBQWUseUVBQXlFLEVBQUUsRUFBRSx1SEFBdUg7O0FBRTVlO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsZ0NBQWdDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRTs7QUFFampCLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsZ0NBQWdDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRTs7QUFFampCLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVELG9HQUFvRyxtQkFBbUIsRUFBRSxtQkFBbUIsOEhBQThIOztBQUUxUTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUIsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvR0FBb0csbUJBQW1CLEVBQUUsbUJBQW1CLDhIQUE4SDs7QUFFMVE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLHFCQUFxQjtBQUMxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esa0VBQWtFLHNCQUFzQjtBQUN4RjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEsc0VBQXNFLHNCQUFzQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFFBQVEscURBQXFEO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsc0RBQXNEO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Es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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7O0FBR3RDLE9BQU87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QUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNB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RCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRTs7QUFFampCOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SixpREFBaUQsYUFBYSx1RkFBdUYsRUFBRSx1RkFBdUY7O0FBRTlPLDBDQUEwQywrREFBK0QscUdBQXFHLEVBQUUseUVBQXlFLGVBQWUseUVBQXlFLEVBQUUsRUFBRSx1SEFBdUg7O0FBRTVlO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy8uMS4yLjlAY2F4L2Rpc3QvY2F4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiAgY2F4IHYxLjIuOVxyXG4gKiAgQnkgaHR0cHM6Ly9naXRodWIuY29tL2RudHpoYW5nIFxyXG4gKiAgR2l0aHViOiBodHRwczovL2dpdGh1Yi5jb20vZG50emhhbmcvY2F4XHJcbiAqICBNSVQgTGljZW5zZWQuXG4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImNheFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJjYXhcIl0gPSBmYWN0b3J5KCk7XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDE2KTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX2dyYXBoaWNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9ncmFwaGljczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ncmFwaGljcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFNoYXBlID0gZnVuY3Rpb24gKF9HcmFwaGljcykge1xuICBfaW5oZXJpdHMoU2hhcGUsIF9HcmFwaGljcyk7XG5cbiAgZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNoYXBlKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU2hhcGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTaGFwZSkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNoYXBlLCBbe1xuICAgIGtleTogJ2RyYXcnLFxuXG4gICAgLy8gY29uc3RydWN0b3IoKSB7XG4gICAgLy8gICAgIHN1cGVyKClcbiAgICAvLyB9XG5cbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdygpIHt9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoY3R4KSB7XG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB0aGlzLmRyYXcoKTtcbiAgICAgIF9nZXQoU2hhcGUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU2hhcGUucHJvdG90eXBlKSwgJ3JlbmRlcicsIHRoaXMpLmNhbGwodGhpcywgY3R4KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2hhcGU7XG59KF9ncmFwaGljczIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFNoYXBlO1xuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX2Rpc3BsYXlPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2Rpc3BsYXlPYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzcGxheU9iamVjdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEdyb3VwID0gZnVuY3Rpb24gKF9EaXNwbGF5T2JqZWN0KSB7XG4gIF9pbmhlcml0cyhHcm91cCwgX0Rpc3BsYXlPYmplY3QpO1xuXG4gIGZ1bmN0aW9uIEdyb3VwKGRhdGEpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR3JvdXApO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEdyb3VwLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoR3JvdXApKS5jYWxsKHRoaXMsIGRhdGEpKTtcblxuICAgIF90aGlzLmNoaWxkcmVuID0gW107XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEdyb3VwLCBbe1xuICAgIGtleTogJ2FkZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChjaGlsZCkge1xuICAgICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHZhciBwYXJlbnQgPSBjLnBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZEF0KHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKGMpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goYyk7XG4gICAgICAgIGMucGFyZW50ID0gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhZGRDaGlsZEF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQ2hpbGRBdChjaGlsZCwgaW5kZXgpIHtcbiAgICAgIHZhciBwYXIgPSBjaGlsZC5wYXJlbnQ7XG4gICAgICBwYXIgJiYgcGFyLnJlbW92ZUNoaWxkQXQocGFyLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpKTtcbiAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZUNoaWxkQXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVDaGlsZEF0KGluZGV4KSB7XG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2luZGV4XTtcbiAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlcGxhY2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlKGN1cnJlbnQsIHByZSkge1xuICAgICAgdmFyIGluZGV4ID0gcHJlLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHByZSk7XG4gICAgICB0aGlzLnJlbW92ZUNoaWxkQXQoaW5kZXgpO1xuICAgICAgdGhpcy5hZGRDaGlsZEF0KGN1cnJlbnQsIGluZGV4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoY2hpbGQpIHtcbiAgICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgdmFyIGNMZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNMZW47IGorKykge1xuICAgICAgICAgIGlmIChjaGlsZC5pZCA9PT0gdGhpcy5jaGlsZHJlbltqXS5pZCkge1xuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgY0xlbi0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2VtcHR5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuZW1wdHkoKTtcbiAgICAgIC8vIFN0YWdlIGRvZXMgbm90IGhhdmUgYSBwYXJlbnRcbiAgICAgIHRoaXMucGFyZW50ICYmIF9nZXQoR3JvdXAucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoR3JvdXAucHJvdG90eXBlKSwgJ2Rlc3Ryb3knLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBHcm91cDtcbn0oX2Rpc3BsYXlPYmplY3QyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBHcm91cDtcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZGlzcGxheU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfZGlzcGxheU9iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kaXNwbGF5T2JqZWN0KTtcblxudmFyIF91dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIF91dGlsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWwpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBCaXRtYXAgPSBmdW5jdGlvbiAoX0Rpc3BsYXlPYmplY3QpIHtcbiAgX2luaGVyaXRzKEJpdG1hcCwgX0Rpc3BsYXlPYmplY3QpO1xuXG4gIGZ1bmN0aW9uIEJpdG1hcChpbWcsIG9uTG9hZCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCaXRtYXApO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEJpdG1hcC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJpdG1hcCkpLmNhbGwodGhpcykpO1xuXG4gICAgaWYgKHR5cGVvZiBpbWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoQml0bWFwLmNhY2hlW2ltZ10pIHtcbiAgICAgICAgaWYgKF91dGlsMi5kZWZhdWx0LmlzV2VhcHApIHtcbiAgICAgICAgICBfdGhpcy5pbWcgPSBCaXRtYXAuY2FjaGVbaW1nXS5pbWc7XG4gICAgICAgICAgX3RoaXMucmVjdCA9IFswLCAwLCBCaXRtYXAuY2FjaGVbaW1nXS53aWR0aCwgQml0bWFwLmNhY2hlW2ltZ10uaGVpZ2h0XTtcbiAgICAgICAgICBfdGhpcy53aWR0aCA9IF90aGlzLnJlY3RbMl07XG4gICAgICAgICAgX3RoaXMuaGVpZ2h0ID0gX3RoaXMucmVjdFszXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5pbWcgPSBCaXRtYXAuY2FjaGVbaW1nXTtcbiAgICAgICAgICBfdGhpcy5yZWN0ID0gWzAsIDAsIF90aGlzLmltZy53aWR0aCwgX3RoaXMuaW1nLmhlaWdodF07XG4gICAgICAgICAgX3RoaXMud2lkdGggPSBfdGhpcy5pbWcud2lkdGg7XG4gICAgICAgICAgX3RoaXMuaGVpZ2h0ID0gX3RoaXMuaW1nLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBvbkxvYWQgJiYgb25Mb2FkLmNhbGwoX3RoaXMpO1xuICAgICAgfSBlbHNlIGlmIChfdXRpbDIuZGVmYXVsdC5pc1dlYXBwKSB7XG4gICAgICAgIF91dGlsMi5kZWZhdWx0LmdldEltYWdlSW5XeChpbWcsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICBfdGhpcy5pbWcgPSByZXN1bHQuaW1nO1xuICAgICAgICAgIGlmICghX3RoaXMucmVjdCkge1xuICAgICAgICAgICAgX3RoaXMucmVjdCA9IFswLCAwLCByZXN1bHQud2lkdGgsIHJlc3VsdC5oZWlnaHRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpcy53aWR0aCA9IHJlc3VsdC53aWR0aDtcbiAgICAgICAgICBfdGhpcy5oZWlnaHQgPSByZXN1bHQuaGVpZ2h0O1xuICAgICAgICAgIG9uTG9hZCAmJiBvbkxvYWQuY2FsbChfdGhpcyk7XG4gICAgICAgICAgQml0bWFwLmNhY2hlW2ltZ10gPSByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuaW1nID0gX3V0aWwyLmRlZmF1bHQuaXNXZWdhbWUgPyB3eC5jcmVhdGVJbWFnZSgpIDogbmV3IHdpbmRvdy5JbWFnZSgpO1xuICAgICAgICBfdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgaWYgKCFfdGhpcy5yZWN0KSB7XG4gICAgICAgICAgICBfdGhpcy5yZWN0ID0gWzAsIDAsIF90aGlzLmltZy53aWR0aCwgX3RoaXMuaW1nLmhlaWdodF07XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzLndpZHRoID0gX3RoaXMuaW1nLndpZHRoO1xuICAgICAgICAgIF90aGlzLmhlaWdodCA9IF90aGlzLmltZy5oZWlnaHQ7XG4gICAgICAgICAgb25Mb2FkICYmIG9uTG9hZC5jYWxsKF90aGlzKTtcbiAgICAgICAgICBCaXRtYXAuY2FjaGVbaW1nXSA9IF90aGlzLmltZztcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaW1nLnNyYyA9IGltZztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuaW1nID0gaW1nO1xuICAgICAgX3RoaXMucmVjdCA9IFswLCAwLCBpbWcud2lkdGgsIGltZy5oZWlnaHRdO1xuICAgICAgX3RoaXMud2lkdGggPSBpbWcud2lkdGg7XG4gICAgICBfdGhpcy5oZWlnaHQgPSBpbWcuaGVpZ2h0O1xuICAgICAgQml0bWFwLmNhY2hlW2ltZy5zcmNdID0gaW1nO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQml0bWFwLCBbe1xuICAgIGtleTogJ2Nsb25lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAvLyDlpI3liLblroxpbWflrr3luqYw77yf77yf5omA5Lul55u05o6l5Lyg5a2X56ym5LiyXG4gICAgICB2YXIgYml0bWFwID0gbmV3IEJpdG1hcCh0eXBlb2YgdGhpcy5pbWcgPT09ICdzdHJpbmcnID8gdGhpcy5pbWcgOiB0aGlzLmltZy5zcmMpO1xuICAgICAgYml0bWFwLnggPSB0aGlzLng7XG4gICAgICBiaXRtYXAueSA9IHRoaXMueTtcbiAgICAgIGJpdG1hcC5zY2FsZVggPSB0aGlzLnNjYWxlWDtcbiAgICAgIGJpdG1hcC5zY2FsZVkgPSB0aGlzLnNjYWxlWTtcbiAgICAgIGJpdG1hcC5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XG4gICAgICBiaXRtYXAuc2tld1ggPSB0aGlzLnNrZXdYO1xuICAgICAgYml0bWFwLnNrZXdZID0gdGhpcy5za2V3WTtcbiAgICAgIGJpdG1hcC5vcmlnaW5YID0gdGhpcy5vcmlnaW5YO1xuICAgICAgYml0bWFwLm9yaWdpblkgPSB0aGlzLm9yaWdpblk7XG4gICAgICBiaXRtYXAud2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgYml0bWFwLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgYml0bWFwLmN1cnNvciA9IHRoaXMuY3Vyc29yO1xuXG4gICAgICByZXR1cm4gYml0bWFwO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCaXRtYXA7XG59KF9kaXNwbGF5T2JqZWN0Mi5kZWZhdWx0KTtcblxuQml0bWFwLmNhY2hlID0ge307XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEJpdG1hcDtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfbWF0cml4MmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcblxudmFyIF9tYXRyaXgyZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRyaXgyZCk7XG5cbnZhciBfZXZlbnREaXNwYXRjaGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cbnZhciBfZXZlbnREaXNwYXRjaGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50RGlzcGF0Y2hlcik7XG5cbnZhciBfdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cbnZhciBfdWlkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VpZCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIERpc3BsYXlPYmplY3QgPSBmdW5jdGlvbiAoX0V2ZW50RGlzcGF0Y2hlcikge1xuICBfaW5oZXJpdHMoRGlzcGxheU9iamVjdCwgX0V2ZW50RGlzcGF0Y2hlcik7XG5cbiAgZnVuY3Rpb24gRGlzcGxheU9iamVjdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGlzcGxheU9iamVjdCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRGlzcGxheU9iamVjdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERpc3BsYXlPYmplY3QpKS5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzLmFscGhhID0gX3RoaXMuY29tcGxleEFscGhhID0gX3RoaXMuc2NhbGVYID0gX3RoaXMuc2NhbGVZID0gMTtcbiAgICBfdGhpcy54ID0gX3RoaXMueSA9IF90aGlzLnJvdGF0aW9uID0gX3RoaXMuc2tld1ggPSBfdGhpcy5za2V3WSA9IF90aGlzLm9yaWdpblggPSBfdGhpcy5vcmlnaW5ZID0gMDtcbiAgICBfdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgIF90aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIF90aGlzLl9tYXRyaXggPSBuZXcgX21hdHJpeDJkMi5kZWZhdWx0KCk7XG4gICAgX3RoaXMuX2hpdE1hdHJpeCA9IG5ldyBfbWF0cml4MmQyLmRlZmF1bHQoKTtcbiAgICBfdGhpcy5pZCA9IF91aWQyLmRlZmF1bHQuZ2V0KCk7XG4gICAgX3RoaXMuY2xpcEdyYXBoaWNzID0gbnVsbDtcbiAgICBfdGhpcy5jbGlwUnVsZU5vbnplcm8gPSB0cnVlO1xuICAgIF90aGlzLmZpeGVkID0gZmFsc2U7XG4gICAgX3RoaXMuc2hhZG93ID0gbnVsbDtcbiAgICBfdGhpcy5jb21wb3NpdGVPcGVyYXRpb24gPSBudWxsO1xuICAgIF90aGlzLmFic0NsaXBHcmFwaGljcyA9IG51bGw7XG4gICAgX3RoaXMuYWJzQ2xpcFJ1bGVOb256ZXJvID0gdHJ1ZTtcbiAgICBfdGhpcy5jYWNoZVVwZGF0aW5nID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXMsIHtcbiAgICAgICAgc3RhZ2U6IHsgZ2V0OiBfdGhpcy5fZ2V0U3RhZ2UgfSxcbiAgICAgICAgc2NhbGU6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYWxlWDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHNjYWxlKSB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlWCA9IHRoaXMuc2NhbGVZID0gc2NhbGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhEaXNwbGF5T2JqZWN0LCBbe1xuICAgIGtleTogJ2lzVmlzaWJsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzVmlzaWJsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpc2libGUgJiYgdGhpcy5hbHBoYSA+IDAgJiYgdGhpcy5zY2FsZVggIT09IDAgJiYgdGhpcy5zY2FsZVkgIT09IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaW5pdEFBQkInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0QUFCQigpIHtcbiAgICAgIGlmICh0aGlzLndpZHRoID09PSB1bmRlZmluZWQgfHwgdGhpcy5oZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB4ID0gdm9pZCAwLFxuICAgICAgICAgIHkgPSB2b2lkIDAsXG4gICAgICAgICAgd2lkdGggPSB0aGlzLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgIG10eCA9IHRoaXMuX21hdHJpeCxcbiAgICAgICAgICB4QSA9IHdpZHRoICogbXR4LmEsXG4gICAgICAgICAgeEIgPSB3aWR0aCAqIG10eC5iLFxuICAgICAgICAgIHlDID0gaGVpZ2h0ICogbXR4LmMsXG4gICAgICAgICAgeUQgPSBoZWlnaHQgKiBtdHguZCxcbiAgICAgICAgICB0eCA9IG10eC50eCxcbiAgICAgICAgICB0eSA9IG10eC50eSxcbiAgICAgICAgICBtaW5YID0gdHgsXG4gICAgICAgICAgbWF4WCA9IHR4LFxuICAgICAgICAgIG1pblkgPSB0eSxcbiAgICAgICAgICBtYXhZID0gdHk7XG5cbiAgICAgIGlmICgoeCA9IHhBICsgdHgpIDwgbWluWCkge1xuICAgICAgICBtaW5YID0geDtcbiAgICAgIH0gZWxzZSBpZiAoeCA+IG1heFgpIHtcbiAgICAgICAgbWF4WCA9IHg7XG4gICAgICB9XG4gICAgICBpZiAoKHggPSB4QSArIHlDICsgdHgpIDwgbWluWCkge1xuICAgICAgICBtaW5YID0geDtcbiAgICAgIH0gZWxzZSBpZiAoeCA+IG1heFgpIHtcbiAgICAgICAgbWF4WCA9IHg7XG4gICAgICB9XG4gICAgICBpZiAoKHggPSB5QyArIHR4KSA8IG1pblgpIHtcbiAgICAgICAgbWluWCA9IHg7XG4gICAgICB9IGVsc2UgaWYgKHggPiBtYXhYKSB7XG4gICAgICAgIG1heFggPSB4O1xuICAgICAgfVxuICAgICAgaWYgKCh5ID0geEIgKyB0eSkgPCBtaW5ZKSB7XG4gICAgICAgIG1pblkgPSB5O1xuICAgICAgfSBlbHNlIGlmICh5ID4gbWF4WSkge1xuICAgICAgICBtYXhZID0geTtcbiAgICAgIH1cbiAgICAgIGlmICgoeSA9IHhCICsgeUQgKyB0eSkgPCBtaW5ZKSB7XG4gICAgICAgIG1pblkgPSB5O1xuICAgICAgfSBlbHNlIGlmICh5ID4gbWF4WSkge1xuICAgICAgICBtYXhZID0geTtcbiAgICAgIH1cbiAgICAgIGlmICgoeSA9IHlEICsgdHkpIDwgbWluWSkge1xuICAgICAgICBtaW5ZID0geTtcbiAgICAgIH0gZWxzZSBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgbWF4WSA9IHk7XG4gICAgICB9XG4gICAgICB0aGlzLkFBQkIgPSBbbWluWCwgbWluWSwgbWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZXTtcbiAgICAgIHRoaXMucmVjdFBvaW50cyA9IFt7XG4gICAgICAgIHg6IHR4LFxuICAgICAgICB5OiB0eVxuICAgICAgfSwge1xuICAgICAgICB4OiB4QSArIHR4LFxuICAgICAgICB5OiB4QiArIHR5XG4gICAgICB9LCB7XG4gICAgICAgIHg6IHhBICsgeUMgKyB0eCxcbiAgICAgICAgeTogeEIgKyB5RCArIHR5XG4gICAgICB9LCB7XG4gICAgICAgIHg6IHlDICsgdHgsXG4gICAgICAgIHk6IHlEICsgdHlcbiAgICAgIH1dO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2hvdmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaG92ZXIob3Zlciwgb3V0LCBtb3ZlKSB7XG4gICAgICB0aGlzLm9uKCdtb3VzZW92ZXInLCBvdmVyKTtcbiAgICAgIHRoaXMub24oJ21vdXNlb3V0Jywgb3V0KTtcbiAgICAgIG1vdmUgJiYgdGhpcy5vbignbW91c2Vtb3ZlJywgbW92ZSk7XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9jbGlwXG5cbiAgfSwge1xuICAgIGtleTogJ2NsaXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGlwKGdyYXBoaWNzLCBub3RDbGlwUnVsZU5vbnplcm8pIHtcbiAgICAgIHRoaXMuY2xpcEdyYXBoaWNzID0gZ3JhcGhpY3M7XG4gICAgICB0aGlzLmNsaXBSdWxlTm9uemVybyA9ICFub3RDbGlwUnVsZU5vbnplcm87XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW5jbGlwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5jbGlwKCkge1xuICAgICAgdGhpcy5jbGlwR3JhcGhpY3MgPSBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Fic0NsaXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhYnNDbGlwKGdyYXBoaWNzLCBub3RDbGlwUnVsZU5vbnplcm8pIHtcbiAgICAgIHRoaXMuYWJzQ2xpcEdyYXBoaWNzID0gZ3JhcGhpY3M7XG4gICAgICB0aGlzLmFic0NsaXBSdWxlTm9uemVybyA9ICFub3RDbGlwUnVsZU5vbnplcm87XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndW5BYnNDbGlwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5BYnNDbGlwKCkge1xuICAgICAgdGhpcy5hYnNDbGlwR3JhcGhpY3MgPSBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhY2hlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FjaGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgc2NhbGUsIGNhY2hlVXBkYXRpbmcpIHtcbiAgICAgIHRoaXMuX2NhY2hlRGF0YSA9IHtcbiAgICAgICAgeDogeCB8fCAwLFxuICAgICAgICB5OiB5IHx8IDAsXG4gICAgICAgIHdpZHRoOiB3aWR0aCB8fCB0aGlzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCB8fCB0aGlzLmhlaWdodCxcbiAgICAgICAgc2NhbGU6IHNjYWxlIHx8IDFcbiAgICAgIH07XG4gICAgICB0aGlzLmNhY2hlVXBkYXRpbmcgPSBjYWNoZVVwZGF0aW5nO1xuICAgICAgaWYgKCF0aGlzLmNhY2hlQ2FudmFzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd3ggIT09ICd1bmRlZmluZWQnICYmIHd4LmNyZWF0ZUNhbnZhcykge1xuICAgICAgICAgIHRoaXMuY2FjaGVDYW52YXMgPSB3eC5jcmVhdGVDYW52YXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNhY2hlQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWNoZUN0eCA9IHRoaXMuY2FjaGVDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGVDYW52YXMud2lkdGggPSB0aGlzLl9jYWNoZURhdGEud2lkdGggKiB0aGlzLl9jYWNoZURhdGEuc2NhbGU7XG4gICAgICB0aGlzLmNhY2hlQ2FudmFzLmhlaWdodCA9IHRoaXMuX2NhY2hlRGF0YS5oZWlnaHQgKiB0aGlzLl9jYWNoZURhdGEuc2NhbGU7XG5cbiAgICAgIC8vIGRlYnVnIGNhY2hlIGNhbnZhc1xuICAgICAgLy8gdGhpcy5jYWNoZUN0eC5maWxsUmVjdCgwLDAsMTAwMCwxMDAwKVxuICAgICAgdGhpcy5fcmVhZHlUb0NhY2hlID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1bmNhY2hlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5jYWNoZSgpIHtcbiAgICAgIHRoaXMuY2FjaGVDYW52YXMgPSBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ZpbHRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbHRlcihmaWx0ZXJOYW1lLCBmaWx0ZXJCb3gpIHtcbiAgICAgIGZpbHRlckJveCA9IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICAgIH0sIGZpbHRlckJveCk7XG4gICAgICB0aGlzLmNhY2hlKGZpbHRlckJveC54LCBmaWx0ZXJCb3gueSwgZmlsdGVyQm94LndpZHRoLCBmaWx0ZXJCb3guaGVpZ2h0KTtcbiAgICAgIHRoaXMuX3JlYWR5VG9GaWx0ZXIgPSB0cnVlO1xuICAgICAgdGhpcy5fZmlsdGVyTmFtZSA9IGZpbHRlck5hbWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0VHJhbnNmb3JtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VHJhbnNmb3JtKHgsIHksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbiwgc2tld1gsIHNrZXdZLCBvcmlnaW5YLCBvcmlnaW5ZKSB7XG4gICAgICB0aGlzLnggPSB4IHx8IDA7XG4gICAgICB0aGlzLnkgPSB5IHx8IDA7XG4gICAgICB0aGlzLnNjYWxlWCA9IHNjYWxlWCA9PSBudWxsID8gMSA6IHNjYWxlWDtcbiAgICAgIHRoaXMuc2NhbGVZID0gc2NhbGVZID09IG51bGwgPyAxIDogc2NhbGVZO1xuICAgICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uIHx8IDA7XG4gICAgICB0aGlzLnNrZXdYID0gc2tld1ggfHwgMDtcbiAgICAgIHRoaXMuc2tld1kgPSBza2V3WSB8fCAwO1xuICAgICAgdGhpcy5vcmlnaW5YID0gb3JpZ2luWCB8fCAwO1xuICAgICAgdGhpcy5vcmlnaW5ZID0gb3JpZ2luWSB8fCAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldE1hdHJpeCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1hdHJpeChhLCBiLCBjLCBkLCB0eCwgdHkpIHtcbiAgICAgIF9tYXRyaXgyZDIuZGVmYXVsdC5kZWNvbXBvc2UoYSwgYiwgYywgZCwgdHgsIHR5LCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1bmZpbHRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuZmlsdGVyKCkge1xuICAgICAgdGhpcy51bmNhY2hlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2dldFN0YWdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFN0YWdlKCkge1xuICAgICAgdmFyIG8gPSB0aGlzO1xuICAgICAgd2hpbGUgKG8ucGFyZW50KSB7XG4gICAgICAgIG8gPSBvLnBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmIChvLl9fX2luc3RhbmNlb2YgPT09ICdTdGFnZScpIHtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGlzcGxheU9iamVjdDtcbn0oX2V2ZW50RGlzcGF0Y2hlcjIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IERpc3BsYXlPYmplY3Q7XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2Rpc3BsYXlPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2Rpc3BsYXlPYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzcGxheU9iamVjdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGFzc01hcCA9IHtcbiAgZmlsbFN0eWxlOiB0cnVlLFxuICBzdHJva2VTdHlsZTogdHJ1ZSxcbiAgbGluZVdpZHRoOiB0cnVlLFxuICBsaW5lQ2FwOiB0cnVlLFxuICBsaW5lRGFzaE9mZnNldDogdHJ1ZSxcbiAgbGluZUpvaW46IHRydWUsXG4gIG1pdGVyTGltaXQ6IHRydWVcbn07XG5cbnZhciBHcmFwaGljcyA9IGZ1bmN0aW9uIChfRGlzcGxheU9iamVjdCkge1xuICBfaW5oZXJpdHMoR3JhcGhpY3MsIF9EaXNwbGF5T2JqZWN0KTtcblxuICBmdW5jdGlvbiBHcmFwaGljcygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR3JhcGhpY3MpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEdyYXBoaWNzLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoR3JhcGhpY3MpKS5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzLmNtZHMgPSBbXTtcbiAgICBfdGhpcy5jdXJyZW50R3JhZGllbnQgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhHcmFwaGljcywgW3tcbiAgICBrZXk6ICdjbGVhclJlY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhclJlY3QoKSB7XG4gICAgICB0aGlzLmNtZHMucHVzaChbJ2NsZWFyUmVjdCcsIGFyZ3VtZW50c10pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlY3QoKSB7XG4gICAgICB0aGlzLmNtZHMucHVzaChbJ3JlY3QnLCBhcmd1bWVudHNdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NsZWFyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLmNtZHMubGVuZ3RoID0gMDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldExpbmVEYXNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TGluZURhc2goKSB7XG4gICAgICB0aGlzLmNtZHMucHVzaChbJ3NldExpbmVEYXNoJywgYXJndW1lbnRzXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzdHJva2VSZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3Ryb2tlUmVjdCgpIHtcbiAgICAgIHRoaXMuY21kcy5wdXNoKFsnc3Ryb2tlUmVjdCcsIGFyZ3VtZW50c10pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZmlsbFJlY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWxsUmVjdCgpIHtcbiAgICAgIHRoaXMuY21kcy5wdXNoKFsnZmlsbFJlY3QnLCBhcmd1bWVudHNdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2JlZ2luUGF0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJlZ2luUGF0aCgpIHtcbiAgICAgIHRoaXMuY21kcy5wdXNoKFsnYmVnaW5QYXRoJywgYXJndW1lbnRzXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhcmMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcmMoKSB7XG4gICAgICB0aGlzLmNtZHMucHVzaChbJ2FyYycsIGFyZ3VtZW50c10pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2xvc2VQYXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VQYXRoKCkge1xuICAgICAgdGhpcy5jbWRzLnB1c2goWydjbG9zZVBhdGgnLCBhcmd1bWVudHNdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ZpbGxTdHlsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbGxTdHlsZSgpIHtcbiAgICAgIHRoaXMuY21kcy5wdXNoKFsnZmlsbFN0eWxlJywgYXJndW1lbnRzXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmaWxsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlsbCgpIHtcbiAgICAgIHRoaXMuY21kcy5wdXNoKFsnZmlsbCcsIGFyZ3VtZW50c10pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3Ryb2tlU3R5bGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdHJva2VTdHlsZSgpIHtcbiAgICAgIHRoaXMuY21kcy5wdXNoKFsnc3Ryb2tlU3R5bGUnLCBhcmd1bWVudHNdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xpbmVXaWR0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpbmVXaWR0aCgpIHtcbiAgICAgIHRoaXMuY21kcy5wdXNoKFsnbGluZVdpZHRoJywgYXJndW1lbnRzXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsaW5lQ2FwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGluZUNhcCgpIHtcbiAgICAgIHRoaXMuY21kcy5wdXNoKFsnbGluZUNhcCcsIGFyZ3VtZW50c10pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbGluZURhc2hPZmZzZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5lRGFzaE9mZnNldCgpIHtcbiAgICAgIHRoaXMuY21kcy5wdXNoKFsnbGluZURhc2hPZmZzZXQnLCBhcmd1bWVudHNdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2xpbmVKb2luJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGluZUpvaW4oKSB7XG4gICAgICB0aGlzLmNtZHMucHVzaChbJ2xpbmVKb2luJywgYXJndW1lbnRzXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdtaXRlckxpbWl0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWl0ZXJMaW1pdCgpIHtcbiAgICAgIHRoaXMuY21kcy5wdXNoKFsnbWl0ZXJMaW1pdCcsIGFyZ3VtZW50c10pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3Ryb2tlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3Ryb2tlKCkge1xuICAgICAgdGhpcy5jbWRzLnB1c2goWydzdHJva2UnLCBhcmd1bWVudHNdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ21vdmVUbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVUbygpIHtcbiAgICAgIHRoaXMuY21kcy5wdXNoKFsnbW92ZVRvJywgYXJndW1lbnRzXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsaW5lVG8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5lVG8oKSB7XG4gICAgICB0aGlzLmNtZHMucHVzaChbJ2xpbmVUbycsIGFyZ3VtZW50c10pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYmV6aWVyQ3VydmVUbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJlemllckN1cnZlVG8oKSB7XG4gICAgICB0aGlzLmNtZHMucHVzaChbJ2JlemllckN1cnZlVG8nLCBhcmd1bWVudHNdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3F1YWRyYXRpY0N1cnZlVG8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBxdWFkcmF0aWNDdXJ2ZVRvKCkge1xuICAgICAgdGhpcy5jbWRzLnB1c2goWydxdWFkcmF0aWNDdXJ2ZVRvJywgYXJndW1lbnRzXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjcmVhdGVSYWRpYWxHcmFkaWVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVJhZGlhbEdyYWRpZW50KCkge1xuICAgICAgdGhpcy5jbWRzLnB1c2goWydjcmVhdGVSYWRpYWxHcmFkaWVudCcsIGFyZ3VtZW50c10pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlTGluZWFyR3JhZGllbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVMaW5lYXJHcmFkaWVudCgpIHtcbiAgICAgIHRoaXMuY21kcy5wdXNoKFsnY3JlYXRlTGluZWFyR3JhZGllbnQnLCBhcmd1bWVudHNdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FkZENvbG9yU3RvcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZENvbG9yU3RvcCgpIHtcbiAgICAgIHRoaXMuY21kcy5wdXNoKFsnYWRkQ29sb3JTdG9wJywgYXJndW1lbnRzXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdmaWxsR3JhZGllbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWxsR3JhZGllbnQoKSB7XG4gICAgICB0aGlzLmNtZHMucHVzaChbJ2ZpbGxHcmFkaWVudCddKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FyY1RvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXJjVG8oKSB7XG4gICAgICB0aGlzLmNtZHMucHVzaChbJ2FyY1RvJywgYXJndW1lbnRzXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoY3R4KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5jbWRzLmZvckVhY2goZnVuY3Rpb24gKGNtZCkge1xuICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGNtZFswXTtcbiAgICAgICAgaWYgKGFzc01hcFttZXRob2ROYW1lXSkge1xuICAgICAgICAgIGN0eFttZXRob2ROYW1lXSA9IGNtZFsxXVswXTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAnYWRkQ29sb3JTdG9wJykge1xuICAgICAgICAgIF90aGlzMi5jdXJyZW50R3JhZGllbnQgJiYgX3RoaXMyLmN1cnJlbnRHcmFkaWVudC5hZGRDb2xvclN0b3AoY21kWzFdWzBdLCBjbWRbMV1bMV0pO1xuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZE5hbWUgPT09ICdmaWxsR3JhZGllbnQnKSB7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IF90aGlzMi5jdXJyZW50R3JhZGllbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGN0eFttZXRob2ROYW1lXS5hcHBseShjdHgsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNtZFsxXSkpO1xuICAgICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnY3JlYXRlUmFkaWFsR3JhZGllbnQnIHx8IG1ldGhvZE5hbWUgPT09ICdjcmVhdGVMaW5lYXJHcmFkaWVudCcpIHtcbiAgICAgICAgICAgIF90aGlzMi5jdXJyZW50R3JhZGllbnQgPSByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gR3JhcGhpY3M7XG59KF9kaXNwbGF5T2JqZWN0Mi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gR3JhcGhpY3M7XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2Rpc3BsYXlPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgX2Rpc3BsYXlPYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzcGxheU9iamVjdCk7XG5cbnZhciBfdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfdXRpbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlsKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgbWVhc3VyZUN0eCA9IHZvaWQgMDtcblxuaWYgKF91dGlsMi5kZWZhdWx0LmlzV2VhcHApIHtcbiAgbWVhc3VyZUN0eCA9IHd4LmNyZWF0ZUNhbnZhc0NvbnRleHQoJ21lYXN1cmUwJyk7XG59IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgbWVhc3VyZUN0eCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJyk7XG59XG5cbnZhciBUZXh0ID0gZnVuY3Rpb24gKF9EaXNwbGF5T2JqZWN0KSB7XG4gIF9pbmhlcml0cyhUZXh0LCBfRGlzcGxheU9iamVjdCk7XG5cbiAgZnVuY3Rpb24gVGV4dCh0ZXh0LCBvcHRpb24pIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVGV4dC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRleHQpKS5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzLnRleHQgPSB0ZXh0O1xuICAgIG9wdGlvbiA9IG9wdGlvbiB8fCB7fTtcbiAgICBfdGhpcy5mb250ID0gb3B0aW9uLmZvbnQgfHwgJzEwcHggc2Fucy1zZXJpZic7XG4gICAgX3RoaXMuY29sb3IgPSBvcHRpb24uY29sb3IgfHwgJ2JsYWNrJztcbiAgICBfdGhpcy50ZXh0QWxpZ24gPSBvcHRpb24udGV4dEFsaWduIHx8ICdsZWZ0JztcbiAgICBfdGhpcy5iYXNlbGluZSA9IG9wdGlvbi5iYXNlbGluZSB8fCAndG9wJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVGV4dCwgW3tcbiAgICBrZXk6ICdnZXRXaWR0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFdpZHRoKCkge1xuICAgICAgaWYgKCFtZWFzdXJlQ3R4KSB7XG4gICAgICAgIGlmIChfdXRpbDIuZGVmYXVsdC5pc1dlZ2FtZSkge1xuICAgICAgICAgIG1lYXN1cmVDdHggPSB3eC5jcmVhdGVDYW52YXMoKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmZvbnQpIHtcbiAgICAgICAgbWVhc3VyZUN0eC5mb250ID0gdGhpcy5mb250O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lYXN1cmVDdHgubWVhc3VyZVRleHQodGhpcy50ZXh0KS53aWR0aDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGV4dDtcbn0oX2Rpc3BsYXlPYmplY3QyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBUZXh0O1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9kaXNwbGF5T2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9kaXNwbGF5T2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Rpc3BsYXlPYmplY3QpO1xuXG52YXIgX3V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgX3V0aWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbCk7XG5cbnZhciBfYml0bWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9iaXRtYXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYml0bWFwKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgU3ByaXRlID0gZnVuY3Rpb24gKF9EaXNwbGF5T2JqZWN0KSB7XG4gIF9pbmhlcml0cyhTcHJpdGUsIF9EaXNwbGF5T2JqZWN0KTtcblxuICBmdW5jdGlvbiBTcHJpdGUob3B0aW9uKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNwcml0ZSk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU3ByaXRlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3ByaXRlKSkuY2FsbCh0aGlzKSk7XG5cbiAgICBfdGhpcy5vcHRpb24gPSBvcHRpb247XG4gICAgdmFyIGxlbiA9IF90aGlzLm9wdGlvbi5pbWdzLmxlbmd0aDtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBmaXJzdEltZyA9IF90aGlzLm9wdGlvbi5pbWdzWzBdO1xuICAgIF90aGlzLmltZ01hcCA9IHt9O1xuXG4gICAgaWYgKF91dGlsMi5kZWZhdWx0LmlzV2VhcHApIHtcbiAgICAgIF90aGlzLm9wdGlvbi5pbWdzLmZvckVhY2goZnVuY3Rpb24gKGltZykge1xuICAgICAgICBfdXRpbDIuZGVmYXVsdC5nZXRJbWFnZUluV3goaW1nLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgX3RoaXMuaW1nTWFwW2ltZ10gPSByZXN1bHQuaW1nO1xuICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgaWYgKGNvdW50ID09PSBsZW4pIHtcbiAgICAgICAgICAgIF90aGlzLmltZyA9IF90aGlzLmltZ01hcFtmaXJzdEltZ107XG4gICAgICAgICAgICBfdGhpcy5yZWN0ID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBmaXJzdEltZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIF9sZW4gPSBfdGhpcy5vcHRpb24uaW1ncy5sZW5ndGg7XG4gICAgICAgIHZhciBsb2FkZWRDb3VudCA9IDA7XG4gICAgICAgIF90aGlzLm9wdGlvbi5pbWdzLmZvckVhY2goZnVuY3Rpb24gKHNyYykge1xuICAgICAgICAgIGlmIChfYml0bWFwMi5kZWZhdWx0LmNhY2hlW3NyY10pIHtcbiAgICAgICAgICAgIF90aGlzLmltZ01hcFtzcmNdID0gX2JpdG1hcDIuZGVmYXVsdC5jYWNoZVtzcmNdO1xuICAgICAgICAgICAgbG9hZGVkQ291bnQrKztcbiAgICAgICAgICAgIGlmIChsb2FkZWRDb3VudCA9PT0gX2xlbikge1xuICAgICAgICAgICAgICBfdGhpcy5pbWcgPSBfdGhpcy5pbWdNYXBbZmlyc3RJbWddO1xuICAgICAgICAgICAgICBfdGhpcy5yZWN0ID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW1nID0gX3V0aWwyLmRlZmF1bHQuaXNXZWdhbWUgPyB3eC5jcmVhdGVJbWFnZSgpIDogbmV3IHdpbmRvdy5JbWFnZSgpO1xuICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMuaW1nTWFwW3NyY10gPSBpbWc7XG4gICAgICAgICAgICAgIGxvYWRlZENvdW50Kys7XG4gICAgICAgICAgICAgIGlmIChsb2FkZWRDb3VudCA9PT0gX2xlbikge1xuICAgICAgICAgICAgICAgIF90aGlzLmltZyA9IF90aGlzLmltZ01hcFtmaXJzdEltZ107XG4gICAgICAgICAgICAgICAgX3RoaXMucmVjdCA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfYml0bWFwMi5kZWZhdWx0LmNhY2hlW3NyY10gPSBpbWc7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW1nLnNyYyA9IHNyYztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChmaXJzdEltZyBpbnN0YW5jZW9mIF9iaXRtYXAyLmRlZmF1bHQpIHtcbiAgICAgICAgX3RoaXMucmVjdCA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgX3RoaXMuaW1nID0gZmlyc3RJbWcuaW1nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMucmVjdCA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgX3RoaXMuaW1nID0gZmlyc3RJbWc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3RoaXMueCA9IG9wdGlvbi54IHx8IDA7XG4gICAgX3RoaXMueSA9IG9wdGlvbi55IHx8IDA7XG4gICAgX3RoaXMuY3VycmVudEZyYW1lSW5kZXggPSAwO1xuICAgIF90aGlzLmFuaW1hdGlvbkZyYW1lSW5kZXggPSAwO1xuICAgIF90aGlzLmN1cnJlbnRBbmltYXRpb24gPSBvcHRpb24uY3VycmVudEFuaW1hdGlvbiB8fCBudWxsO1xuXG4gICAgX3RoaXMuaW50ZXJ2YWwgPSAxZTMgLyBvcHRpb24uZnJhbWVyYXRlO1xuXG4gICAgX3RoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgX3RoaXMuYW5pbWF0aW9uRW5kID0gb3B0aW9uLmFuaW1hdGlvbkVuZCB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICBpZiAoX3RoaXMuY3VycmVudEFuaW1hdGlvbikge1xuICAgICAgaWYgKG9wdGlvbi5wbGF5T25jZSkge1xuICAgICAgICBfdGhpcy5nb3RvQW5kUGxheU9uY2UoX3RoaXMuY3VycmVudEFuaW1hdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5nb3RvQW5kUGxheShfdGhpcy5jdXJyZW50QW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNwcml0ZSwgW3tcbiAgICBrZXk6ICdwbGF5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGxheSgpIHtcbiAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncGF1c2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZXNldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5jdXJyZW50RnJhbWVJbmRleCA9IDA7XG4gICAgICB0aGlzLmFuaW1hdGlvbkZyYW1lSW5kZXggPSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZUZyYW1lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRnJhbWUoKSB7XG4gICAgICBpZiAoIXRoaXMucGF1c2VkKSB7XG4gICAgICAgIHZhciBvcHQgPSB0aGlzLm9wdGlvbjtcbiAgICAgICAgdGhpcy5kdCA9IERhdGUubm93KCkgLSB0aGlzLnN0YXJ0VGltZTtcbiAgICAgICAgdmFyIGZyYW1lcyA9IG9wdC5hbmltYXRpb25zW3RoaXMuY3VycmVudEFuaW1hdGlvbl0uZnJhbWVzO1xuICAgICAgICB2YXIgbGVuID0gZnJhbWVzLmxlbmd0aDtcbiAgICAgICAgdmFyIGluZGV4ID0gTWF0aC5mbG9vcih0aGlzLmR0IC8gdGhpcy5pbnRlcnZhbCAlIGxlbik7XG4gICAgICAgIHRoaXMucmVjdCA9IG9wdC5mcmFtZXNbZnJhbWVzW2luZGV4XV07XG4gICAgICAgIHZhciByZWN0TGVuID0gdGhpcy5yZWN0Lmxlbmd0aDtcblxuICAgICAgICByZWN0TGVuID4gNCAmJiAodGhpcy5vcmlnaW5YID0gdGhpcy5yZWN0WzJdICogdGhpcy5yZWN0WzRdKTtcbiAgICAgICAgcmVjdExlbiA+IDUgJiYgKHRoaXMub3JpZ2luWSA9IHRoaXMucmVjdFszXSAqIHRoaXMucmVjdFs1XSk7XG4gICAgICAgIGlmIChyZWN0TGVuID4gNikge1xuICAgICAgICAgIHZhciBpbWcgPSB0aGlzLm9wdGlvbi5pbWdzW3RoaXMucmVjdFs2XV07XG4gICAgICAgICAgdGhpcy5pbWcgPSB0eXBlb2YgaW1nID09PSAnc3RyaW5nJyA/IHRoaXMuaW1nTWFwW2ltZ10gOiBpbWc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPT09IGxlbiAtIDEgJiYgKCF0aGlzLmVuZFRpbWUgfHwgRGF0ZS5ub3coKSAtIHRoaXMuZW5kVGltZSA+IHRoaXMuaW50ZXJ2YWwpKSB7XG4gICAgICAgICAgdGhpcy5lbmRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICB0aGlzLmFuaW1hdGlvbkVuZCgpO1xuICAgICAgICAgIGlmICh0aGlzLl93aWxsRGVzdHJveSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ290b0FuZFBsYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnb3RvQW5kUGxheShhbmltYXRpb24pIHtcbiAgICAgIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBhbmltYXRpb247XG4gICAgICB0aGlzLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ290b0FuZFN0b3AnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnb3RvQW5kU3RvcChhbmltYXRpb24pIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcbiAgICAgIHZhciBvcHQgPSB0aGlzLm9wdGlvbjtcbiAgICAgIHZhciBmcmFtZXMgPSBvcHQuYW5pbWF0aW9uc1t0aGlzLmN1cnJlbnRBbmltYXRpb25dLmZyYW1lcztcbiAgICAgIHRoaXMucmVjdCA9IG9wdC5mcmFtZXNbZnJhbWVzW3RoaXMuYW5pbWF0aW9uRnJhbWVJbmRleF1dO1xuICAgICAgdmFyIHJlY3QgPSB0aGlzLnJlY3Q7XG4gICAgICB0aGlzLndpZHRoID0gcmVjdFsyXTtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gcmVjdFszXTtcbiAgICAgIHZhciByZWN0TGVuID0gcmVjdC5sZW5ndGg7XG4gICAgICByZWN0TGVuID4gNCAmJiAodGhpcy5vcmlnaW5YID0gcmVjdFsyXSAqIHJlY3RbNF0pO1xuICAgICAgcmVjdExlbiA+IDUgJiYgKHRoaXMub3JpZ2luWSA9IHJlY3RbM10gKiByZWN0WzVdKTtcbiAgICAgIGlmIChyZWN0TGVuID4gNikge1xuICAgICAgICB2YXIgaW1nID0gdGhpcy5vcHRpb24uaW1nc1tyZWN0WzZdXTtcbiAgICAgICAgdGhpcy5pbWcgPSB0eXBlb2YgaW1nID09PSAnc3RyaW5nJyA/IHRoaXMuaW1nTWFwW2ltZ10gOiBpbWc7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ290b0FuZFBsYXlPbmNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ290b0FuZFBsYXlPbmNlKGFuaW1hdGlvbikge1xuICAgICAgdGhpcy5nb3RvQW5kUGxheShhbmltYXRpb24pO1xuICAgICAgdGhpcy5fd2lsbERlc3Ryb3kgPSB0cnVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTcHJpdGU7XG59KF9kaXNwbGF5T2JqZWN0Mi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU3ByaXRlO1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFdmVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXZlbnQpO1xuXG4gICAgdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YWdlWCA9IG51bGw7XG4gICAgdGhpcy5zdGFnZVkgPSBudWxsO1xuICAgIHRoaXMucHVyZUV2ZW50ID0gbnVsbDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFdmVudCwgW3tcbiAgICBrZXk6IFwic3RvcFByb3BhZ2F0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICAgIHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJldmVudERlZmF1bHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG4gICAgICB0aGlzLnB1cmVFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFdmVudDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnQ7XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZW5kZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlbmRlcik7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmVuZGVyLCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge31cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJHcmFwaGljc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJHcmFwaGljcygpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7fVxuICB9XSk7XG5cbiAgcmV0dXJuIFJlbmRlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUmVuZGVyO1xuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5nZXRJbWFnZUluV3ggPSBnZXRJbWFnZUluV3g7XG5mdW5jdGlvbiBnZXRJbWFnZUluV3goaW1nLCBjYWxsYmFjaykge1xuICBpZiAoaW1nLmluZGV4T2YoJ2h0dHBzOi8vJykgPT09IC0xICYmIGltZy5pbmRleE9mKCdodHRwOi8vJykgPT09IC0xIHx8IGltZy5pbmRleE9mKCdodHRwOi8vdG1wLycpID09PSAwKSB7XG4gICAgd3guZ2V0SW1hZ2VJbmZvKHtcbiAgICAgIHNyYzogaW1nLFxuICAgICAgc3VjY2VzczogZnVuY3Rpb24gc3VjY2VzcyhpbmZvKSB7XG4gICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICBpbWc6IGltZyxcbiAgICAgICAgICB3aWR0aDogaW5mby53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGluZm8uaGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHd4LmRvd25sb2FkRmlsZSh7XG4gICAgICB1cmw6IGltZyxcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIHN1Y2Nlc3MocmVzKSB7XG4gICAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICAgICAgd3guZ2V0SW1hZ2VJbmZvKHtcbiAgICAgICAgICAgIHNyYzogcmVzLnRlbXBGaWxlUGF0aCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIHN1Y2Nlc3MoaW5mbykge1xuICAgICAgICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgaW1nOiByZXMudGVtcEZpbGVQYXRoLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBpbmZvLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaW5mby5oZWlnaHRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRHbG9iYWwoKSB7XG4gIGlmICgodHlwZW9mIGdsb2JhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZ2xvYmFsKSkgIT09ICdvYmplY3QnIHx8ICFnbG9iYWwgfHwgZ2xvYmFsLk1hdGggIT09IE1hdGggfHwgZ2xvYmFsLkFycmF5ICE9PSBBcnJheSkge1xuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0oKTtcbiAgfVxuICByZXR1cm4gZ2xvYmFsO1xufVxuXG52YXIgcm9vdCA9IGdldEdsb2JhbCgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGdldEltYWdlSW5XeDogZ2V0SW1hZ2VJbld4LFxuICByb290OiByb290LFxuICBpc1dlYXBwOiB0eXBlb2Ygd3ggIT09ICd1bmRlZmluZWQnICYmICF3eC5jcmVhdGVDYW52YXMsXG4gIGlzV2VnYW1lOiB0eXBlb2Ygd3ggIT09ICd1bmRlZmluZWQnICYmIHd4LmNyZWF0ZUNhbnZhc1xufTtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KSkpXG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24ocHJvY2Vzcykge1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbi8qKlxyXG4gKiBUd2Vlbi5qcyAtIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdHdlZW5qcy90d2Vlbi5qc1xyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqXHJcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdHdlZW5qcy90d2Vlbi5qcy9ncmFwaHMvY29udHJpYnV0b3JzIGZvciB0aGUgZnVsbCBsaXN0IG9mIGNvbnRyaWJ1dG9ycy5cclxuICogVGhhbmsgeW91IGFsbCwgeW91J3JlIGF3ZXNvbWUhXHJcbiAqL1xuXG52YXIgX0dyb3VwID0gZnVuY3Rpb24gX0dyb3VwKCkge1xuICB0aGlzLl90d2VlbnMgPSB7fTtcbiAgdGhpcy5fdHdlZW5zQWRkZWREdXJpbmdVcGRhdGUgPSB7fTtcbn07XG5cbl9Hcm91cC5wcm90b3R5cGUgPSB7XG4gIGdldEFsbDogZnVuY3Rpb24gZ2V0QWxsKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl90d2VlbnMpLm1hcChmdW5jdGlvbiAodHdlZW5JZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3R3ZWVuc1t0d2VlbklkXTtcbiAgICB9LmJpbmQodGhpcykpO1xuICB9LFxuXG4gIHJlbW92ZUFsbDogZnVuY3Rpb24gcmVtb3ZlQWxsKCkge1xuICAgIHRoaXMuX3R3ZWVucyA9IHt9O1xuICB9LFxuXG4gIGFkZDogZnVuY3Rpb24gYWRkKHR3ZWVuKSB7XG4gICAgdGhpcy5fdHdlZW5zW3R3ZWVuLmdldElkKCldID0gdHdlZW47XG4gICAgdGhpcy5fdHdlZW5zQWRkZWREdXJpbmdVcGRhdGVbdHdlZW4uZ2V0SWQoKV0gPSB0d2VlbjtcbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSh0d2Vlbikge1xuICAgIGRlbGV0ZSB0aGlzLl90d2VlbnNbdHdlZW4uZ2V0SWQoKV07XG4gICAgZGVsZXRlIHRoaXMuX3R3ZWVuc0FkZGVkRHVyaW5nVXBkYXRlW3R3ZWVuLmdldElkKCldO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHRpbWUsIHByZXNlcnZlKSB7XG4gICAgdmFyIHR3ZWVuSWRzID0gT2JqZWN0LmtleXModGhpcy5fdHdlZW5zKTtcblxuICAgIGlmICh0d2Vlbklkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aW1lID0gdGltZSAhPT0gdW5kZWZpbmVkID8gdGltZSA6IFRXRUVOLm5vdygpO1xuXG4gICAgLy8gVHdlZW5zIGFyZSB1cGRhdGVkIGluIFwiYmF0Y2hlc1wiLiBJZiB5b3UgYWRkIGEgbmV3IHR3ZWVuIGR1cmluZyBhbiB1cGRhdGUsIHRoZW4gdGhlXG4gICAgLy8gbmV3IHR3ZWVuIHdpbGwgYmUgdXBkYXRlZCBpbiB0aGUgbmV4dCBiYXRjaC5cbiAgICAvLyBJZiB5b3UgcmVtb3ZlIGEgdHdlZW4gZHVyaW5nIGFuIHVwZGF0ZSwgaXQgbWF5IG9yIG1heSBub3QgYmUgdXBkYXRlZC4gSG93ZXZlcixcbiAgICAvLyBpZiB0aGUgcmVtb3ZlZCB0d2VlbiB3YXMgYWRkZWQgZHVyaW5nIHRoZSBjdXJyZW50IGJhdGNoLCB0aGVuIGl0IHdpbGwgbm90IGJlIHVwZGF0ZWQuXG4gICAgd2hpbGUgKHR3ZWVuSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuX3R3ZWVuc0FkZGVkRHVyaW5nVXBkYXRlID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHdlZW5JZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHR3ZWVuID0gdGhpcy5fdHdlZW5zW3R3ZWVuSWRzW2ldXTtcblxuICAgICAgICBpZiAodHdlZW4gJiYgdHdlZW4udXBkYXRlKHRpbWUpID09PSBmYWxzZSkge1xuICAgICAgICAgIHR3ZWVuLl9pc1BsYXlpbmcgPSBmYWxzZTtcblxuICAgICAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl90d2VlbnNbdHdlZW5JZHNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0d2VlbklkcyA9IE9iamVjdC5rZXlzKHRoaXMuX3R3ZWVuc0FkZGVkRHVyaW5nVXBkYXRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxudmFyIFRXRUVOID0gbmV3IF9Hcm91cCgpO1xuXG5UV0VFTi5Hcm91cCA9IF9Hcm91cDtcblRXRUVOLl9uZXh0SWQgPSAwO1xuVFdFRU4ubmV4dElkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gVFdFRU4uX25leHRJZCsrO1xufTtcblxuLy8gSW5jbHVkZSBhIHBlcmZvcm1hbmNlLm5vdyBwb2x5ZmlsbC5cbi8vIEluIG5vZGUuanMsIHVzZSBwcm9jZXNzLmhydGltZS5cbmlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgaWYgKHR5cGVvZiB3eCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBUV0VFTi5ub3cgPSBEYXRlLm5vdztcbiAgfSBlbHNlIHtcbiAgICBUV0VFTi5ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGltZSA9IHByb2Nlc3MuaHJ0aW1lKCk7XG5cbiAgICAgIC8vIENvbnZlcnQgW3NlY29uZHMsIG5hbm9zZWNvbmRzXSB0byBtaWxsaXNlY29uZHMuXG4gICAgICByZXR1cm4gdGltZVswXSAqIDEwMDAgKyB0aW1lWzFdIC8gMTAwMDAwMDtcbiAgICB9O1xuICB9XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4vLyBJbiBhIGJyb3dzZXIsIHVzZSB3aW5kb3cucGVyZm9ybWFuY2Uubm93IGlmIGl0IGlzIGF2YWlsYWJsZS5cbndpbmRvdy5wZXJmb3JtYW5jZSAhPT0gdW5kZWZpbmVkICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgIT09IHVuZGVmaW5lZCkge1xuICAvLyBUaGlzIG11c3QgYmUgYm91bmQsIGJlY2F1c2UgZGlyZWN0bHkgYXNzaWduaW5nIHRoaXMgZnVuY3Rpb25cbiAgLy8gbGVhZHMgdG8gYW4gaW52b2NhdGlvbiBleGNlcHRpb24gaW4gQ2hyb21lLlxuICBUV0VFTi5ub3cgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93LmJpbmQod2luZG93LnBlcmZvcm1hbmNlKTtcbn0gZWxzZSBpZiAoRGF0ZS5ub3cgIT09IHVuZGVmaW5lZCkge1xuICAvLyBVc2UgRGF0ZS5ub3cgaWYgaXQgaXMgYXZhaWxhYmxlLlxuICBUV0VFTi5ub3cgPSBEYXRlLm5vdztcbn0gZWxzZSB7XG4gIC8vIE90aGVyd2lzZSwgdXNlICduZXcgRGF0ZSgpLmdldFRpbWUoKScuXG4gIFRXRUVOLm5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG59XG5cblRXRUVOLlR3ZWVuID0gZnVuY3Rpb24gKG9iamVjdCwgZ3JvdXApIHtcbiAgdGhpcy5fb2JqZWN0ID0gb2JqZWN0O1xuICB0aGlzLl92YWx1ZXNTdGFydCA9IHt9O1xuICB0aGlzLl92YWx1ZXNFbmQgPSB7fTtcbiAgdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXQgPSB7fTtcbiAgdGhpcy5fZHVyYXRpb24gPSAxMDAwO1xuICB0aGlzLl9yZXBlYXQgPSAwO1xuICB0aGlzLl9yZXBlYXREZWxheVRpbWUgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX3lveW8gPSBmYWxzZTtcbiAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG4gIHRoaXMuX3JldmVyc2VkID0gZmFsc2U7XG4gIHRoaXMuX2RlbGF5VGltZSA9IDA7XG4gIHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG4gIHRoaXMuX2Vhc2luZ0Z1bmN0aW9uID0gVFdFRU4uRWFzaW5nLkxpbmVhci5Ob25lO1xuICB0aGlzLl9pbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSBUV0VFTi5JbnRlcnBvbGF0aW9uLkxpbmVhcjtcbiAgdGhpcy5fY2hhaW5lZFR3ZWVucyA9IFtdO1xuICB0aGlzLl9vblN0YXJ0Q2FsbGJhY2sgPSBudWxsO1xuICB0aGlzLl9vblN0YXJ0Q2FsbGJhY2tGaXJlZCA9IGZhbHNlO1xuICB0aGlzLl9vblVwZGF0ZUNhbGxiYWNrID0gbnVsbDtcbiAgdGhpcy5fb25Db21wbGV0ZUNhbGxiYWNrID0gbnVsbDtcbiAgdGhpcy5fb25TdG9wQ2FsbGJhY2sgPSBudWxsO1xuICB0aGlzLl9ncm91cCA9IGdyb3VwIHx8IFRXRUVOO1xuICB0aGlzLl9pZCA9IFRXRUVOLm5leHRJZCgpO1xuXG4gIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICB0aGlzLl9wYXNzVGltZSA9IG51bGw7XG59O1xuXG5UV0VFTi5Ud2Vlbi5wcm90b3R5cGUgPSB7XG4gIGdldElkOiBmdW5jdGlvbiBnZXRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faWQ7XG4gIH0sXG5cbiAgdG9nZ2xlOiBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgaWYgKHRoaXMuX3BhdXNlZCkge1xuICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICB9XG4gIH0sXG5cblxuICBwYXVzZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICB2YXIgcGF1c2VUaW1lID0gVFdFRU4ubm93KCk7XG4gICAgdGhpcy5fcGFzc1RpbWUgPSBwYXVzZVRpbWUgLSB0aGlzLl9zdGFydFRpbWU7XG4gIH0sXG5cbiAgcGxheTogZnVuY3Rpb24gcGxheSgpIHtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB2YXIgbm93VGltZSA9IFRXRUVOLm5vdygpO1xuICAgIHRoaXMuX3N0YXJ0VGltZSA9IG5vd1RpbWUgLSB0aGlzLl9wYXNzVGltZTtcbiAgfSxcblxuICBpc1BsYXlpbmc6IGZ1bmN0aW9uIGlzUGxheWluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faXNQbGF5aW5nO1xuICB9LFxuXG4gIHRvOiBmdW5jdGlvbiB0byhwcm9wZXJ0aWVzLCBkdXJhdGlvbikge1xuICAgIHRoaXMuX3ZhbHVlc0VuZCA9IHByb3BlcnRpZXM7XG5cbiAgICBpZiAoZHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBzdGFydDogZnVuY3Rpb24gc3RhcnQodGltZSkge1xuICAgIHRoaXMuX2dyb3VwLmFkZCh0aGlzKTtcblxuICAgIHRoaXMuX2lzUGxheWluZyA9IHRydWU7XG5cbiAgICB0aGlzLl9vblN0YXJ0Q2FsbGJhY2tGaXJlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5fc3RhcnRUaW1lID0gdGltZSAhPT0gdW5kZWZpbmVkID8gdHlwZW9mIHRpbWUgPT09ICdzdHJpbmcnID8gVFdFRU4ubm93KCkgKyBwYXJzZUZsb2F0KHRpbWUpIDogdGltZSA6IFRXRUVOLm5vdygpO1xuICAgIHRoaXMuX3N0YXJ0VGltZSArPSB0aGlzLl9kZWxheVRpbWU7XG5cbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzLl92YWx1ZXNFbmQpIHtcbiAgICAgIC8vIENoZWNrIGlmIGFuIEFycmF5IHdhcyBwcm92aWRlZCBhcyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgaWYgKHRoaXMuX3ZhbHVlc0VuZFtwcm9wZXJ0eV0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBpZiAodGhpcy5fdmFsdWVzRW5kW3Byb3BlcnR5XS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBhIGxvY2FsIGNvcHkgb2YgdGhlIEFycmF5IHdpdGggdGhlIHN0YXJ0IHZhbHVlIGF0IHRoZSBmcm9udFxuICAgICAgICB0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldID0gW3RoaXMuX29iamVjdFtwcm9wZXJ0eV1dLmNvbmNhdCh0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYHRvKClgIHNwZWNpZmllcyBhIHByb3BlcnR5IHRoYXQgZG9lc24ndCBleGlzdCBpbiB0aGUgc291cmNlIG9iamVjdCxcbiAgICAgIC8vIHdlIHNob3VsZCBub3Qgc2V0IHRoYXQgcHJvcGVydHkgaW4gdGhlIG9iamVjdFxuICAgICAgaWYgKHRoaXMuX29iamVjdFtwcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2F2ZSB0aGUgc3RhcnRpbmcgdmFsdWUuXG4gICAgICB0aGlzLl92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gPSB0aGlzLl9vYmplY3RbcHJvcGVydHldO1xuXG4gICAgICBpZiAodGhpcy5fdmFsdWVzU3RhcnRbcHJvcGVydHldIGluc3RhbmNlb2YgQXJyYXkgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSAqPSAxLjA7IC8vIEVuc3VyZXMgd2UncmUgdXNpbmcgbnVtYmVycywgbm90IHN0cmluZ3NcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldID0gdGhpcy5fdmFsdWVzU3RhcnRbcHJvcGVydHldIHx8IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBpZiAoIXRoaXMuX2lzUGxheWluZykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5fZ3JvdXAucmVtb3ZlKHRoaXMpO1xuICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMuX29uU3RvcENhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9vblN0b3BDYWxsYmFjayh0aGlzLl9vYmplY3QpO1xuICAgIH1cblxuICAgIHRoaXMuc3RvcENoYWluZWRUd2VlbnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBlbmQ6IGZ1bmN0aW9uIGVuZCgpIHtcbiAgICB0aGlzLnVwZGF0ZSh0aGlzLl9zdGFydFRpbWUgKyB0aGlzLl9kdXJhdGlvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgc3RvcENoYWluZWRUd2VlbnM6IGZ1bmN0aW9uIHN0b3BDaGFpbmVkVHdlZW5zKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBudW1DaGFpbmVkVHdlZW5zID0gdGhpcy5fY2hhaW5lZFR3ZWVucy5sZW5ndGg7IGkgPCBudW1DaGFpbmVkVHdlZW5zOyBpKyspIHtcbiAgICAgIHRoaXMuX2NoYWluZWRUd2VlbnNbaV0uc3RvcCgpO1xuICAgIH1cbiAgfSxcblxuICBncm91cDogZnVuY3Rpb24gZ3JvdXAoZ3JvdXApIHtcbiAgICB0aGlzLl9ncm91cCA9IGdyb3VwO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGRlbGF5OiBmdW5jdGlvbiBkZWxheShhbW91bnQpIHtcbiAgICB0aGlzLl9kZWxheVRpbWUgPSBhbW91bnQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVwZWF0OiBmdW5jdGlvbiByZXBlYXQodGltZXMpIHtcbiAgICB0aGlzLl9yZXBlYXQgPSB0aW1lcztcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZXBlYXREZWxheTogZnVuY3Rpb24gcmVwZWF0RGVsYXkoYW1vdW50KSB7XG4gICAgdGhpcy5fcmVwZWF0RGVsYXlUaW1lID0gYW1vdW50O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHlveW86IGZ1bmN0aW9uIHlveW8oeXkpIHtcbiAgICB0aGlzLl95b3lvID0geXk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZWFzaW5nOiBmdW5jdGlvbiBlYXNpbmcoZWFzKSB7XG4gICAgdGhpcy5fZWFzaW5nRnVuY3Rpb24gPSBlYXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgaW50ZXJwb2xhdGlvbjogZnVuY3Rpb24gaW50ZXJwb2xhdGlvbihpbnRlcikge1xuICAgIHRoaXMuX2ludGVycG9sYXRpb25GdW5jdGlvbiA9IGludGVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNoYWluOiBmdW5jdGlvbiBjaGFpbigpIHtcbiAgICB0aGlzLl9jaGFpbmVkVHdlZW5zID0gYXJndW1lbnRzO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG9uU3RhcnQ6IGZ1bmN0aW9uIG9uU3RhcnQoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9vblN0YXJ0Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9vblVwZGF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZShjYWxsYmFjaykge1xuICAgIHRoaXMuX29uQ29tcGxldGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG9uU3RvcDogZnVuY3Rpb24gb25TdG9wKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fb25TdG9wQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSh0aW1lKSB7XG4gICAgaWYgKHRoaXMuX3BhdXNlZCkgcmV0dXJuIHRydWU7XG4gICAgdmFyIHByb3BlcnR5O1xuICAgIHZhciBlbGFwc2VkO1xuICAgIHZhciB2YWx1ZTtcblxuICAgIGlmICh0aW1lIDwgdGhpcy5fc3RhcnRUaW1lKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb25TdGFydENhbGxiYWNrRmlyZWQgPT09IGZhbHNlKSB7XG4gICAgICBpZiAodGhpcy5fb25TdGFydENhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX29uU3RhcnRDYWxsYmFjayh0aGlzLl9vYmplY3QpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9vblN0YXJ0Q2FsbGJhY2tGaXJlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgZWxhcHNlZCA9ICh0aW1lIC0gdGhpcy5fc3RhcnRUaW1lKSAvIHRoaXMuX2R1cmF0aW9uO1xuICAgIGVsYXBzZWQgPSB0aGlzLl9kdXJhdGlvbiA9PT0gMCB8fCBlbGFwc2VkID4gMSA/IDEgOiBlbGFwc2VkO1xuXG4gICAgdmFsdWUgPSB0aGlzLl9lYXNpbmdGdW5jdGlvbihlbGFwc2VkKTtcblxuICAgIGZvciAocHJvcGVydHkgaW4gdGhpcy5fdmFsdWVzRW5kKSB7XG4gICAgICAvLyBEb24ndCB1cGRhdGUgcHJvcGVydGllcyB0aGF0IGRvIG5vdCBleGlzdCBpbiB0aGUgc291cmNlIG9iamVjdFxuICAgICAgaWYgKHRoaXMuX3ZhbHVlc1N0YXJ0W3Byb3BlcnR5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLl92YWx1ZXNTdGFydFtwcm9wZXJ0eV0gfHwgMDtcbiAgICAgIHZhciBlbmQgPSB0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldO1xuXG4gICAgICBpZiAoZW5kIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0W3Byb3BlcnR5XSA9IHRoaXMuX2ludGVycG9sYXRpb25GdW5jdGlvbihlbmQsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFBhcnNlcyByZWxhdGl2ZSBlbmQgdmFsdWVzIHdpdGggc3RhcnQgYXMgYmFzZSAoZS5nLjogKzEwLCAtMylcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKGVuZC5jaGFyQXQoMCkgPT09ICcrJyB8fCBlbmQuY2hhckF0KDApID09PSAnLScpIHtcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0ICsgcGFyc2VGbG9hdChlbmQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmQgPSBwYXJzZUZsb2F0KGVuZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJvdGVjdCBhZ2FpbnN0IG5vbiBudW1lcmljIHByb3BlcnRpZXMuXG4gICAgICAgIGlmICh0eXBlb2YgZW5kID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMuX29iamVjdFtwcm9wZXJ0eV0gPSBzdGFydCArIChlbmQgLSBzdGFydCkgKiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9vblVwZGF0ZUNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9vblVwZGF0ZUNhbGxiYWNrKHRoaXMuX29iamVjdCk7XG4gICAgfVxuXG4gICAgaWYgKGVsYXBzZWQgPT09IDEpIHtcbiAgICAgIGlmICh0aGlzLl9yZXBlYXQgPiAwKSB7XG4gICAgICAgIGlmIChpc0Zpbml0ZSh0aGlzLl9yZXBlYXQpKSB7XG4gICAgICAgICAgdGhpcy5fcmVwZWF0LS07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWFzc2lnbiBzdGFydGluZyB2YWx1ZXMsIHJlc3RhcnQgYnkgbWFraW5nIHN0YXJ0VGltZSA9IG5vd1xuICAgICAgICBmb3IgKHByb3BlcnR5IGluIHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldID0gdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldICsgcGFyc2VGbG9hdCh0aGlzLl92YWx1ZXNFbmRbcHJvcGVydHldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5feW95bykge1xuICAgICAgICAgICAgdmFyIHRtcCA9IHRoaXMuX3ZhbHVlc1N0YXJ0UmVwZWF0W3Byb3BlcnR5XTtcblxuICAgICAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldID0gdGhpcy5fdmFsdWVzRW5kW3Byb3BlcnR5XTtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlc0VuZFtwcm9wZXJ0eV0gPSB0bXA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fdmFsdWVzU3RhcnRbcHJvcGVydHldID0gdGhpcy5fdmFsdWVzU3RhcnRSZXBlYXRbcHJvcGVydHldO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3lveW8pIHtcbiAgICAgICAgICB0aGlzLl9yZXZlcnNlZCA9ICF0aGlzLl9yZXZlcnNlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9yZXBlYXREZWxheVRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IHRpbWUgKyB0aGlzLl9yZXBlYXREZWxheVRpbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gdGltZSArIHRoaXMuX2RlbGF5VGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX29uQ29tcGxldGVDYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuX29uQ29tcGxldGVDYWxsYmFjayh0aGlzLl9vYmplY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG51bUNoYWluZWRUd2VlbnMgPSB0aGlzLl9jaGFpbmVkVHdlZW5zLmxlbmd0aDsgaSA8IG51bUNoYWluZWRUd2VlbnM7IGkrKykge1xuICAgICAgICAgIC8vIE1ha2UgdGhlIGNoYWluZWQgdHdlZW5zIHN0YXJ0IGV4YWN0bHkgYXQgdGhlIHRpbWUgdGhleSBzaG91bGQsXG4gICAgICAgICAgLy8gZXZlbiBpZiB0aGUgYHVwZGF0ZSgpYCBtZXRob2Qgd2FzIGNhbGxlZCB3YXkgcGFzdCB0aGUgZHVyYXRpb24gb2YgdGhlIHR3ZWVuXG4gICAgICAgICAgdGhpcy5fY2hhaW5lZFR3ZWVuc1tpXS5zdGFydCh0aGlzLl9zdGFydFRpbWUgKyB0aGlzLl9kdXJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblRXRUVOLkVhc2luZyA9IHtcblxuICBMaW5lYXI6IHtcblxuICAgIE5vbmU6IGZ1bmN0aW9uIE5vbmUoaykge1xuICAgICAgcmV0dXJuIGs7XG4gICAgfVxuXG4gIH0sXG5cbiAgUXVhZHJhdGljOiB7XG5cbiAgICBJbjogZnVuY3Rpb24gSW4oaykge1xuICAgICAgcmV0dXJuIGsgKiBrO1xuICAgIH0sXG5cbiAgICBPdXQ6IGZ1bmN0aW9uIE91dChrKSB7XG4gICAgICByZXR1cm4gayAqICgyIC0gayk7XG4gICAgfSxcblxuICAgIEluT3V0OiBmdW5jdGlvbiBJbk91dChrKSB7XG4gICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgIHJldHVybiAwLjUgKiBrICogaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC0wLjUgKiAoLS1rICogKGsgLSAyKSAtIDEpO1xuICAgIH1cblxuICB9LFxuXG4gIEN1YmljOiB7XG5cbiAgICBJbjogZnVuY3Rpb24gSW4oaykge1xuICAgICAgcmV0dXJuIGsgKiBrICogaztcbiAgICB9LFxuXG4gICAgT3V0OiBmdW5jdGlvbiBPdXQoaykge1xuICAgICAgcmV0dXJuIC0tayAqIGsgKiBrICsgMTtcbiAgICB9LFxuXG4gICAgSW5PdXQ6IGZ1bmN0aW9uIEluT3V0KGspIHtcbiAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICsgMik7XG4gICAgfVxuXG4gIH0sXG5cbiAgUXVhcnRpYzoge1xuXG4gICAgSW46IGZ1bmN0aW9uIEluKGspIHtcbiAgICAgIHJldHVybiBrICogayAqIGsgKiBrO1xuICAgIH0sXG5cbiAgICBPdXQ6IGZ1bmN0aW9uIE91dChrKSB7XG4gICAgICByZXR1cm4gMSAtIC0tayAqIGsgKiBrICogaztcbiAgICB9LFxuXG4gICAgSW5PdXQ6IGZ1bmN0aW9uIEluT3V0KGspIHtcbiAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAtMC41ICogKChrIC09IDIpICogayAqIGsgKiBrIC0gMik7XG4gICAgfVxuXG4gIH0sXG5cbiAgUXVpbnRpYzoge1xuXG4gICAgSW46IGZ1bmN0aW9uIEluKGspIHtcbiAgICAgIHJldHVybiBrICogayAqIGsgKiBrICogaztcbiAgICB9LFxuXG4gICAgT3V0OiBmdW5jdGlvbiBPdXQoaykge1xuICAgICAgcmV0dXJuIC0tayAqIGsgKiBrICogayAqIGsgKyAxO1xuICAgIH0sXG5cbiAgICBJbk91dDogZnVuY3Rpb24gSW5PdXQoaykge1xuICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrICogayAqIGs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgKiBrICsgMik7XG4gICAgfVxuXG4gIH0sXG5cbiAgU2ludXNvaWRhbDoge1xuXG4gICAgSW46IGZ1bmN0aW9uIEluKGspIHtcbiAgICAgIHJldHVybiAxIC0gTWF0aC5jb3MoayAqIE1hdGguUEkgLyAyKTtcbiAgICB9LFxuXG4gICAgT3V0OiBmdW5jdGlvbiBPdXQoaykge1xuICAgICAgcmV0dXJuIE1hdGguc2luKGsgKiBNYXRoLlBJIC8gMik7XG4gICAgfSxcblxuICAgIEluT3V0OiBmdW5jdGlvbiBJbk91dChrKSB7XG4gICAgICByZXR1cm4gMC41ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogaykpO1xuICAgIH1cblxuICB9LFxuXG4gIEV4cG9uZW50aWFsOiB7XG5cbiAgICBJbjogZnVuY3Rpb24gSW4oaykge1xuICAgICAgcmV0dXJuIGsgPT09IDAgPyAwIDogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuICAgIH0sXG5cbiAgICBPdXQ6IGZ1bmN0aW9uIE91dChrKSB7XG4gICAgICByZXR1cm4gayA9PT0gMSA/IDEgOiAxIC0gTWF0aC5wb3coMiwgLTEwICogayk7XG4gICAgfSxcblxuICAgIEluT3V0OiBmdW5jdGlvbiBJbk91dChrKSB7XG4gICAgICBpZiAoayA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgcmV0dXJuIDAuNSAqIE1hdGgucG93KDEwMjQsIGsgLSAxKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKGsgLSAxKSkgKyAyKTtcbiAgICB9XG5cbiAgfSxcblxuICBDaXJjdWxhcjoge1xuXG4gICAgSW46IGZ1bmN0aW9uIEluKGspIHtcbiAgICAgIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSBrICogayk7XG4gICAgfSxcblxuICAgIE91dDogZnVuY3Rpb24gT3V0KGspIHtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoMSAtIC0tayAqIGspO1xuICAgIH0sXG5cbiAgICBJbk91dDogZnVuY3Rpb24gSW5PdXQoaykge1xuICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICByZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIGsgKiBrKSAtIDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKGsgLT0gMikgKiBrKSArIDEpO1xuICAgIH1cblxuICB9LFxuXG4gIEVsYXN0aWM6IHtcblxuICAgIEluOiBmdW5jdGlvbiBJbihrKSB7XG4gICAgICBpZiAoayA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAtTWF0aC5wb3coMiwgMTAgKiAoayAtIDEpKSAqIE1hdGguc2luKChrIC0gMS4xKSAqIDUgKiBNYXRoLlBJKTtcbiAgICB9LFxuXG4gICAgT3V0OiBmdW5jdGlvbiBPdXQoaykge1xuICAgICAgaWYgKGsgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChrID09PSAxKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTWF0aC5wb3coMiwgLTEwICogaykgKiBNYXRoLnNpbigoayAtIDAuMSkgKiA1ICogTWF0aC5QSSkgKyAxO1xuICAgIH0sXG5cbiAgICBJbk91dDogZnVuY3Rpb24gSW5PdXQoaykge1xuICAgICAgaWYgKGsgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChrID09PSAxKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICBrICo9IDI7XG5cbiAgICAgIGlmIChrIDwgMSkge1xuICAgICAgICByZXR1cm4gLTAuNSAqIE1hdGgucG93KDIsIDEwICogKGsgLSAxKSkgKiBNYXRoLnNpbigoayAtIDEuMSkgKiA1ICogTWF0aC5QSSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwLjUgKiBNYXRoLnBvdygyLCAtMTAgKiAoayAtIDEpKSAqIE1hdGguc2luKChrIC0gMS4xKSAqIDUgKiBNYXRoLlBJKSArIDE7XG4gICAgfVxuXG4gIH0sXG5cbiAgQmFjazoge1xuXG4gICAgSW46IGZ1bmN0aW9uIEluKGspIHtcbiAgICAgIHZhciBzID0gMS43MDE1ODtcblxuICAgICAgcmV0dXJuIGsgKiBrICogKChzICsgMSkgKiBrIC0gcyk7XG4gICAgfSxcblxuICAgIE91dDogZnVuY3Rpb24gT3V0KGspIHtcbiAgICAgIHZhciBzID0gMS43MDE1ODtcblxuICAgICAgcmV0dXJuIC0tayAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDE7XG4gICAgfSxcblxuICAgIEluT3V0OiBmdW5jdGlvbiBJbk91dChrKSB7XG4gICAgICB2YXIgcyA9IDEuNzAxNTggKiAxLjUyNTtcblxuICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICByZXR1cm4gMC41ICogKGsgKiBrICogKChzICsgMSkgKiBrIC0gcykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqICgocyArIDEpICogayArIHMpICsgMik7XG4gICAgfVxuXG4gIH0sXG5cbiAgQm91bmNlOiB7XG5cbiAgICBJbjogZnVuY3Rpb24gSW4oaykge1xuICAgICAgcmV0dXJuIDEgLSBUV0VFTi5FYXNpbmcuQm91bmNlLk91dCgxIC0gayk7XG4gICAgfSxcblxuICAgIE91dDogZnVuY3Rpb24gT3V0KGspIHtcbiAgICAgIGlmIChrIDwgMSAvIDIuNzUpIHtcbiAgICAgICAgcmV0dXJuIDcuNTYyNSAqIGsgKiBrO1xuICAgICAgfSBlbHNlIGlmIChrIDwgMiAvIDIuNzUpIHtcbiAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09IDEuNSAvIDIuNzUpICogayArIDAuNzU7XG4gICAgICB9IGVsc2UgaWYgKGsgPCAyLjUgLyAyLjc1KSB7XG4gICAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAyLjI1IC8gMi43NSkgKiBrICsgMC45Mzc1O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09IDIuNjI1IC8gMi43NSkgKiBrICsgMC45ODQzNzU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIEluT3V0OiBmdW5jdGlvbiBJbk91dChrKSB7XG4gICAgICBpZiAoayA8IDAuNSkge1xuICAgICAgICByZXR1cm4gVFdFRU4uRWFzaW5nLkJvdW5jZS5JbihrICogMikgKiAwLjU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBUV0VFTi5FYXNpbmcuQm91bmNlLk91dChrICogMiAtIDEpICogMC41ICsgMC41O1xuICAgIH1cblxuICB9XG5cbn07XG5cblRXRUVOLkludGVycG9sYXRpb24gPSB7XG5cbiAgTGluZWFyOiBmdW5jdGlvbiBMaW5lYXIodiwgaykge1xuICAgIHZhciBtID0gdi5sZW5ndGggLSAxO1xuICAgIHZhciBmID0gbSAqIGs7XG4gICAgdmFyIGkgPSBNYXRoLmZsb29yKGYpO1xuICAgIHZhciBmbiA9IFRXRUVOLkludGVycG9sYXRpb24uVXRpbHMuTGluZWFyO1xuXG4gICAgaWYgKGsgPCAwKSB7XG4gICAgICByZXR1cm4gZm4odlswXSwgdlsxXSwgZik7XG4gICAgfVxuXG4gICAgaWYgKGsgPiAxKSB7XG4gICAgICByZXR1cm4gZm4odlttXSwgdlttIC0gMV0sIG0gLSBmKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm4odltpXSwgdltpICsgMSA+IG0gPyBtIDogaSArIDFdLCBmIC0gaSk7XG4gIH0sXG5cbiAgQmV6aWVyOiBmdW5jdGlvbiBCZXppZXIodiwgaykge1xuICAgIHZhciBiID0gMDtcbiAgICB2YXIgbiA9IHYubGVuZ3RoIC0gMTtcbiAgICB2YXIgcHcgPSBNYXRoLnBvdztcbiAgICB2YXIgYm4gPSBUV0VFTi5JbnRlcnBvbGF0aW9uLlV0aWxzLkJlcm5zdGVpbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IG47IGkrKykge1xuICAgICAgYiArPSBwdygxIC0gaywgbiAtIGkpICogcHcoaywgaSkgKiB2W2ldICogYm4obiwgaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGI7XG4gIH0sXG5cbiAgQ2F0bXVsbFJvbTogZnVuY3Rpb24gQ2F0bXVsbFJvbSh2LCBrKSB7XG4gICAgdmFyIG0gPSB2Lmxlbmd0aCAtIDE7XG4gICAgdmFyIGYgPSBtICogaztcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoZik7XG4gICAgdmFyIGZuID0gVFdFRU4uSW50ZXJwb2xhdGlvbi5VdGlscy5DYXRtdWxsUm9tO1xuXG4gICAgaWYgKHZbMF0gPT09IHZbbV0pIHtcbiAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICBpID0gTWF0aC5mbG9vcihmID0gbSAqICgxICsgaykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4odlsoaSAtIDEgKyBtKSAlIG1dLCB2W2ldLCB2WyhpICsgMSkgJSBtXSwgdlsoaSArIDIpICUgbV0sIGYgLSBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgIHJldHVybiB2WzBdIC0gKGZuKHZbMF0sIHZbMF0sIHZbMV0sIHZbMV0sIC1mKSAtIHZbMF0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoayA+IDEpIHtcbiAgICAgICAgcmV0dXJuIHZbbV0gLSAoZm4odlttXSwgdlttXSwgdlttIC0gMV0sIHZbbSAtIDFdLCBmIC0gbSkgLSB2W21dKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZuKHZbaSA/IGkgLSAxIDogMF0sIHZbaV0sIHZbbSA8IGkgKyAxID8gbSA6IGkgKyAxXSwgdlttIDwgaSArIDIgPyBtIDogaSArIDJdLCBmIC0gaSk7XG4gICAgfVxuICB9LFxuXG4gIFV0aWxzOiB7XG5cbiAgICBMaW5lYXI6IGZ1bmN0aW9uIExpbmVhcihwMCwgcDEsIHQpIHtcbiAgICAgIHJldHVybiAocDEgLSBwMCkgKiB0ICsgcDA7XG4gICAgfSxcblxuICAgIEJlcm5zdGVpbjogZnVuY3Rpb24gQmVybnN0ZWluKG4sIGkpIHtcbiAgICAgIHZhciBmYyA9IFRXRUVOLkludGVycG9sYXRpb24uVXRpbHMuRmFjdG9yaWFsO1xuXG4gICAgICByZXR1cm4gZmMobikgLyBmYyhpKSAvIGZjKG4gLSBpKTtcbiAgICB9LFxuXG4gICAgRmFjdG9yaWFsOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYSA9IFsxXTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHZhciBzID0gMTtcblxuICAgICAgICBpZiAoYVtuXSkge1xuICAgICAgICAgIHJldHVybiBhW25dO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IG47IGkgPiAxOyBpLS0pIHtcbiAgICAgICAgICBzICo9IGk7XG4gICAgICAgIH1cblxuICAgICAgICBhW25dID0gcztcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9O1xuICAgIH0oKSxcblxuICAgIENhdG11bGxSb206IGZ1bmN0aW9uIENhdG11bGxSb20ocDAsIHAxLCBwMiwgcDMsIHQpIHtcbiAgICAgIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNTtcbiAgICAgIHZhciB2MSA9IChwMyAtIHAxKSAqIDAuNTtcbiAgICAgIHZhciB0MiA9IHQgKiB0O1xuICAgICAgdmFyIHQzID0gdCAqIHQyO1xuXG4gICAgICByZXR1cm4gKDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEpICogdDMgKyAoLTMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxKSAqIHQyICsgdjAgKiB0ICsgcDE7XG4gICAgfVxuXG4gIH1cblxufTtcblxuLy8gVU1EIChVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24pXG4oZnVuY3Rpb24gKHJvb3QpIHtcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmICggZmFsc2UgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZXhwb3J0cykpID09PSAnb2JqZWN0Jykge1xuICAgIC8vIE5vZGUuanNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRXRUVOO1xuICB9IGVsc2UgaWYgKHJvb3QgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIEdsb2JhbCB2YXJpYWJsZVxuICAgIHJvb3QuVFdFRU4gPSBUV0VFTjtcbiAgfVxufSkodW5kZWZpbmVkKTtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSkpXG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF90d2VlbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG52YXIgX3R3ZWVuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R3ZWVuKTtcblxudmFyIF9yYWZJbnRlcnZhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgVG8gPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRvKGVsZW1lbnQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG8pO1xuXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmNtZHMgPSBbXTtcbiAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB0aGlzLnR3ZWVucyA9IFtdO1xuICAgIHRoaXMuX3BhdXNlID0gZmFsc2U7XG4gICAgdGhpcy5sb29wID0gKDAsIF9yYWZJbnRlcnZhbC5zZXRSYWZJbnRlcnZhbCkoZnVuY3Rpb24gKCkge1xuICAgICAgX3R3ZWVuMi5kZWZhdWx0LnVwZGF0ZSgpO1xuICAgIH0sIDE1KTtcbiAgICB0aGlzLmN5Y2xlQ291bnQgPSAwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRvLCBbe1xuICAgIGtleTogJ3RvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG8odGFyZ2V0LCBkdXJhdGlvbiwgZWFzaW5nKSB7XG4gICAgICB0aGlzLmNtZHMucHVzaChbJ3RvJ10pO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRhcmdldCkge1xuICAgICAgICAgIHRoaXMuc2V0KGtleSwgdGFyZ2V0W2tleV0sIGR1cmF0aW9uIHx8IDAsIGVhc2luZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChwcm9wLCB2YWx1ZSwgZHVyYXRpb24sIGVhc2luZykge1xuICAgICAgdGhpcy5jbWRzW3RoaXMuY21kcy5sZW5ndGggLSAxXS5wdXNoKFtwcm9wLCBbdmFsdWUsIGR1cmF0aW9uLCBlYXNpbmddXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24geCgpIHtcbiAgICAgIHRoaXMuY21kc1t0aGlzLmNtZHMubGVuZ3RoIC0gMV0ucHVzaChbJ3gnLCBhcmd1bWVudHNdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB5KCkge1xuICAgICAgdGhpcy5jbWRzW3RoaXMuY21kcy5sZW5ndGggLSAxXS5wdXNoKFsneScsIGFyZ3VtZW50c10pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAneicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHooKSB7XG4gICAgICB0aGlzLmNtZHNbdGhpcy5jbWRzLmxlbmd0aCAtIDFdLnB1c2goWyd6JywgYXJndW1lbnRzXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyb3RhdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJvdGF0aW9uKCkge1xuICAgICAgdGhpcy5jbWRzW3RoaXMuY21kcy5sZW5ndGggLSAxXS5wdXNoKFsncm90YXRpb24nLCBhcmd1bWVudHNdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NjYWxlWCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjYWxlWCgpIHtcbiAgICAgIHRoaXMuY21kc1t0aGlzLmNtZHMubGVuZ3RoIC0gMV0ucHVzaChbJ3NjYWxlWCcsIGFyZ3VtZW50c10pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2NhbGVZJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2NhbGVZKCkge1xuICAgICAgdGhpcy5jbWRzW3RoaXMuY21kcy5sZW5ndGggLSAxXS5wdXNoKFsnc2NhbGVZJywgYXJndW1lbnRzXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdza2V3WCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNrZXdYKCkge1xuICAgICAgdGhpcy5jbWRzW3RoaXMuY21kcy5sZW5ndGggLSAxXS5wdXNoKFsnc2tld1gnLCBhcmd1bWVudHNdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NrZXdZJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2tld1koKSB7XG4gICAgICB0aGlzLmNtZHNbdGhpcy5jbWRzLmxlbmd0aCAtIDFdLnB1c2goWydza2V3WScsIGFyZ3VtZW50c10pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb3JpZ2luWCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9yaWdpblgoKSB7XG4gICAgICB0aGlzLmNtZHNbdGhpcy5jbWRzLmxlbmd0aCAtIDFdLnB1c2goWydvcmlnaW5YJywgYXJndW1lbnRzXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvcmlnaW5ZJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3JpZ2luWSgpIHtcbiAgICAgIHRoaXMuY21kc1t0aGlzLmNtZHMubGVuZ3RoIC0gMV0ucHVzaChbJ29yaWdpblknLCBhcmd1bWVudHNdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FscGhhJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWxwaGEoKSB7XG4gICAgICB0aGlzLmNtZHNbdGhpcy5jbWRzLmxlbmd0aCAtIDFdLnB1c2goWydhbHBoYScsIGFyZ3VtZW50c10pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnYmVnaW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiZWdpbihmbikge1xuICAgICAgdGhpcy5jbWRzW3RoaXMuY21kcy5sZW5ndGggLSAxXS5iZWdpbiA9IGZuO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncHJvZ3Jlc3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9ncmVzcyhmbikge1xuICAgICAgdGhpcy5jbWRzW3RoaXMuY21kcy5sZW5ndGggLSAxXS5wcm9ncmVzcyA9IGZuO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZW5kJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKGZuKSB7XG4gICAgICB0aGlzLmNtZHNbdGhpcy5jbWRzLmxlbmd0aCAtIDFdLmVuZCA9IGZuO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnd2FpdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdhaXQoKSB7XG4gICAgICB0aGlzLmNtZHMucHVzaChbJ3dhaXQnLCBhcmd1bWVudHNdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RoZW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aGVuKCkge1xuICAgICAgdGhpcy5jbWRzLnB1c2goWyd0aGVuJywgYXJndW1lbnRzXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjeWNsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN5Y2xlKCkge1xuICAgICAgdGhpcy5jbWRzLnB1c2goWydjeWNsZScsIGFyZ3VtZW50c10pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc3RhcnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIGlmICh0aGlzLl9wYXVzZSkgcmV0dXJuO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuY21kcy5sZW5ndGg7XG4gICAgICBpZiAodGhpcy5pbmRleCA8IGxlbikge1xuICAgICAgICB0aGlzLmV4ZWModGhpcy5jbWRzW3RoaXMuaW5kZXhdLCB0aGlzLmluZGV4ID09PSBsZW4gLSAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICgwLCBfcmFmSW50ZXJ2YWwuY2xlYXJSYWZJbnRlcnZhbCkodGhpcy5sb29wKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3BhdXNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICB0aGlzLl9wYXVzZSA9IHRydWU7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy50d2VlbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy50d2VlbnNbaV0ucGF1c2UoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmN1cnJlbnRUYXNrID09PSAnd2FpdCcpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0IC09IG5ldyBEYXRlKCkgLSB0aGlzLmN1cnJlbnRUYXNrQmVnaW47XG4gICAgICAgIHRoaXMuY3VycmVudFRhc2tCZWdpbiA9IG5ldyBEYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndG9nZ2xlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgICAgaWYgKHRoaXMuX3BhdXNlKSB7XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3BsYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5KCkge1xuICAgICAgdGhpcy5fcGF1c2UgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnR3ZWVucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLnR3ZWVuc1tpXS5wbGF5KCk7XG4gICAgICB9XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5jdXJyZW50VGFzayA9PT0gJ3dhaXQnKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChzZWxmLl9wYXVzZSkgcmV0dXJuO1xuICAgICAgICAgIHNlbGYuaW5kZXgrKztcbiAgICAgICAgICBzZWxmLnN0YXJ0KCk7XG4gICAgICAgICAgaWYgKHNlbGYuaW5kZXggPT09IHNlbGYuY21kcy5sZW5ndGggJiYgc2VsZi5jb21wbGV0ZSkgc2VsZi5jb21wbGV0ZSgpO1xuICAgICAgICB9LCB0aGlzLnRpbWVvdXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3N0b3AnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMudHdlZW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMudHdlZW5zW2ldLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY21kcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FuaW1hdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlKG5hbWUpIHtcbiAgICAgIHRoaXMuY21kcyA9IHRoaXMuY21kcy5jb25jYXQoVG8uYW5pbWF0aW9uTWFwW25hbWVdIHx8IFtdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2V4ZWMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleGVjKGNtZCwgbGFzdCkge1xuICAgICAgdmFyIGxlbiA9IGNtZC5sZW5ndGgsXG4gICAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICB0aGlzLmN1cnJlbnRUYXNrID0gY21kWzBdO1xuICAgICAgc3dpdGNoICh0aGlzLmN1cnJlbnRUYXNrKSB7XG4gICAgICAgIGNhc2UgJ3RvJzpcbiAgICAgICAgICBzZWxmLnN0ZXBDb21wbGV0ZUNvdW50ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IGNtZFtpXTtcbiAgICAgICAgICAgIHZhciBlYXNlID0gdGFza1sxXVsyXTtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICAgICAgICAgIHZhciBwcm9wID0gdGFza1swXTtcbiAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHRhc2tbMV1bMF07XG5cbiAgICAgICAgICAgIHZhciB0ID0gbmV3IF90d2VlbjIuZGVmYXVsdC5Ud2Vlbih0aGlzLmVsZW1lbnQpLnRvKHRhcmdldCwgdGFza1sxXVsxXSkub25TdGFydChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChjbWQuYmVnaW4pIGNtZC5iZWdpbi5jYWxsKHNlbGYuZWxlbWVudCwgc2VsZi5lbGVtZW50KTtcbiAgICAgICAgICAgIH0pLm9uVXBkYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKGNtZC5wcm9ncmVzcykgY21kLnByb2dyZXNzLmNhbGwoc2VsZi5lbGVtZW50LCBzZWxmLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAvLyBzZWxmLmVsZW1lbnRbcHJvcF0gPSB0aGlzW3Byb3BdO1xuICAgICAgICAgICAgfSkuZWFzaW5nKGVhc2UgfHwgX3R3ZWVuMi5kZWZhdWx0LkVhc2luZy5MaW5lYXIuTm9uZSkub25Db21wbGV0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHNlbGYuc3RlcENvbXBsZXRlQ291bnQrKztcbiAgICAgICAgICAgICAgaWYgKHNlbGYuc3RlcENvbXBsZXRlQ291bnQgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoY21kLmVuZCkgY21kLmVuZC5jYWxsKHNlbGYuZWxlbWVudCwgc2VsZi5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCAmJiBzZWxmLmNvbXBsZXRlKSBzZWxmLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5pbmRleCsrO1xuICAgICAgICAgICAgICAgIHNlbGYuc3RhcnQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuc3RhcnQoKTtcbiAgICAgICAgICAgIHRoaXMudHdlZW5zLnB1c2godCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd3YWl0JzpcbiAgICAgICAgICB0aGlzLmN1cnJlbnRUYXNrQmVnaW4gPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgIHRoaXMudGltZW91dCA9IGNtZFsxXVswXTtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9wYXVzZSkgcmV0dXJuO1xuICAgICAgICAgICAgc2VsZi5pbmRleCsrO1xuICAgICAgICAgICAgc2VsZi5zdGFydCgpO1xuICAgICAgICAgICAgaWYgKGNtZC5lbmQpIGNtZC5lbmQuY2FsbChzZWxmLmVsZW1lbnQsIHNlbGYuZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAobGFzdCAmJiBzZWxmLmNvbXBsZXRlKSBzZWxmLmNvbXBsZXRlKCk7XG4gICAgICAgICAgfSwgY21kWzFdWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGhlbic6XG4gICAgICAgICAgdmFyIGFyZyA9IGNtZFsxXVswXTtcbiAgICAgICAgICBhcmcuaW5kZXggPSAwO1xuICAgICAgICAgIGFyZy5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYuaW5kZXgrKztcbiAgICAgICAgICAgIHNlbGYuc3RhcnQoKTtcbiAgICAgICAgICAgIGlmIChsYXN0ICYmIHNlbGYuY29tcGxldGUpIHNlbGYuY29tcGxldGUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGFyZy5zdGFydCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjeWNsZSc6XG4gICAgICAgICAgdmFyIGNvdW50ID0gY21kWzFdWzFdO1xuICAgICAgICAgIGlmIChjb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZWxmLmluZGV4ID0gY21kWzFdWzBdIHx8IDA7XG4gICAgICAgICAgICBzZWxmLnN0YXJ0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjb3VudCAmJiBzZWxmLmN5Y2xlQ291bnQgPT09IGNvdW50KSB7XG4gICAgICAgICAgICAgIHNlbGYuaW5kZXgrKztcbiAgICAgICAgICAgICAgc2VsZi5zdGFydCgpO1xuICAgICAgICAgICAgICBpZiAobGFzdCAmJiBzZWxmLmNvbXBsZXRlKSBzZWxmLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxmLmN5Y2xlQ291bnQrKztcbiAgICAgICAgICAgICAgc2VsZi5pbmRleCA9IGNtZFsxXVswXTtcbiAgICAgICAgICAgICAgc2VsZi5zdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVG87XG59KCk7XG5cblRvLmdldCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHZhciB0byA9IG5ldyBUbyhlbGVtZW50KTtcbiAgcmV0dXJuIHRvO1xufTtcblxuVG8uYW5pbWF0aW9uTWFwID0ge307XG5Uby5leHRlbmQgPSBmdW5jdGlvbiAoYW5pbWF0aW9uTmFtZSwgY21kcykge1xuICBUby5hbmltYXRpb25NYXBbYW5pbWF0aW9uTmFtZV0gPSBjbWRzO1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gVG87XG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc2V0UmFmSW50ZXJ2YWwgPSBzZXRSYWZJbnRlcnZhbDtcbmV4cG9ydHMuY2xlYXJSYWZJbnRlcnZhbCA9IGNsZWFyUmFmSW50ZXJ2YWw7XG4vKiFcclxuICogIHJhZi1pbnRlcnZhbCB2MC4zLjAgQnkgZG50emhhbmdcclxuICogIEdpdGh1YjogaHR0cHM6Ly9naXRodWIuY29tL2RudHpoYW5nL3JhZi1pbnRlcnZhbFxyXG4gKiAgTUlUIExpY2Vuc2VkLlxyXG4gKi9cblxuaWYgKCFEYXRlLm5vdykge1xuICBEYXRlLm5vdyA9IGZ1bmN0aW9uIG5vdygpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG59XG5cbnZhciBxdWV1ZSA9IFtdLFxuICAgIGlkID0gLTEsXG4gICAgdGlja2luZyA9IGZhbHNlLFxuICAgIHRpY2tJZCA9IG51bGwsXG4gICAgbm93ID0gRGF0ZS5ub3csXG4gICAgbGFzdFRpbWUgPSAwLFxuICAgIHZlbmRvcnMgPSBbJ21zJywgJ21veicsICd3ZWJraXQnLCAnbyddLFxuICAgIHggPSAwLFxuICAgIGlzV2VhcHAgPSB0eXBlb2Ygd3ggIT09ICd1bmRlZmluZWQnICYmICF3eC5jcmVhdGVDYW52YXMsXG4gICAgaXNXZWdhbWUgPSB0eXBlb2Ygd3ggIT09ICd1bmRlZmluZWQnICYmIHd4LmNyZWF0ZUNhbnZhcyxcbiAgICBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblxudmFyIHJhZiA9IGlzQnJvd3NlciA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBudWxsO1xudmFyIGNhZiA9IGlzQnJvd3NlciA/IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA6IG51bGw7XG5cbmZ1bmN0aW9uIG1vY2tSYWYoY2FsbGJhY2ssIGVsZW1lbnQpIHtcbiAgdmFyIGN1cnJUaW1lID0gbm93KCk7XG4gIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xuICB2YXIgaWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpO1xuICB9LCB0aW1lVG9DYWxsKTtcbiAgbGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG4gIHJldHVybiBpZDtcbn1cblxuZnVuY3Rpb24gbW9ja0NhZihpZCkge1xuICBjbGVhclRpbWVvdXQoaWQpO1xufVxuXG5pZiAoaXNCcm93c2VyKSB7XG4gIHdpbmRvdy5zZXRSYWZJbnRlcnZhbCA9IHNldFJhZkludGVydmFsO1xuICB3aW5kb3cuY2xlYXJSYWZJbnRlcnZhbCA9IGNsZWFyUmFmSW50ZXJ2YWw7XG5cbiAgZm9yICg7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKyt4KSB7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ10gfHwgd2luZG93W3ZlbmRvcnNbeF0gKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gIH1cblxuICBpZiAoIXJhZikge1xuICAgIHJhZiA9IG1vY2tSYWY7XG4gICAgY2FmID0gbW9ja0NhZjtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmFmO1xuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGNhZjtcbiAgfVxufSBlbHNlIGlmIChpc1dlYXBwKSB7XG4gIHJhZiA9IG1vY2tSYWY7XG4gIGNhZiA9IG1vY2tDYWY7XG59IGVsc2UgaWYgKGlzV2VnYW1lKSB7XG4gIHJhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgY2FmID0gY2FuY2VsQW5pbWF0aW9uRnJhbWU7XG59XG5cbmZ1bmN0aW9uIHNldFJhZkludGVydmFsKGZuLCBpbnRlcnZhbCkge1xuICBpZCsrO1xuICBxdWV1ZS5wdXNoKHsgaWQ6IGlkLCBmbjogZm4sIGludGVydmFsOiBpbnRlcnZhbCwgbGFzdFRpbWU6IG5vdygpIH0pO1xuICBpZiAoIXRpY2tpbmcpIHtcbiAgICB2YXIgdGljayA9IGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgICB0aWNrSWQgPSByYWYodGljayk7XG4gICAgICBlYWNoKHF1ZXVlLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5pbnRlcnZhbCA8IDE3IHx8IG5vdygpIC0gaXRlbS5sYXN0VGltZSA+PSBpdGVtLmludGVydmFsKSB7XG4gICAgICAgICAgaXRlbS5mbigpO1xuICAgICAgICAgIGl0ZW0ubGFzdFRpbWUgPSBub3coKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aWNraW5nID0gdHJ1ZTtcbiAgICB0aWNrKCk7XG4gIH1cbiAgcmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiBjbGVhclJhZkludGVydmFsKGlkKSB7XG4gIHZhciBpID0gMCxcbiAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcblxuICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGlkID09PSBxdWV1ZVtpXS5pZCkge1xuICAgICAgcXVldWUuc3BsaWNlKGksIDEpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgIGNhZih0aWNrSWQpO1xuICAgIHRpY2tpbmcgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlYWNoKGFyciwgZm4pIHtcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKSB7XG4gICAgYXJyLmZvckVhY2goZm4pO1xuICB9IGVsc2Uge1xuICAgIHZhciBpID0gMCxcbiAgICAgICAgbGVuID0gYXJyLmxlbmd0aDtcbiAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmbihhcnJbaV0sIGkpO1xuICAgIH1cbiAgfVxufVxuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfY2FudmFzUmVuZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cbnZhciBfY2FudmFzUmVuZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NhbnZhc1JlbmRlcik7XG5cbnZhciBfZ3JvdXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2dyb3VwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dyb3VwKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFJlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZW5kZXJlcihjYW52YXNPckNvbnRleHQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVuZGVyZXIpO1xuXG4gICAgdGhpcy5yZW5kZXJMaXN0ID0gW107XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgX2NhbnZhc1JlbmRlcjIuZGVmYXVsdChjYW52YXNPckNvbnRleHQsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgX2NhbnZhc1JlbmRlcjIuZGVmYXVsdChjYW52YXNPckNvbnRleHQpO1xuICAgICAgdGhpcy53aWR0aCA9IGNhbnZhc09yQ29udGV4dC53aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gY2FudmFzT3JDb250ZXh0LmhlaWdodDtcbiAgICB9XG4gICAgdGhpcy5jdHggPSB0aGlzLnJlbmRlcmVyLmN0eDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSZW5kZXJlciwgW3tcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoc3RhZ2UpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuY2xlYXIodGhpcy5jdHgsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuY3R4LCBzdGFnZSk7XG4gICAgICB0aGlzLmN0eC5kcmF3ICYmIHRoaXMuY3R4LmRyYXcoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRIaXRSZW5kZXJMaXN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGl0UmVuZGVyTGlzdChzdGFnZSkge1xuICAgICAgdmFyIG9ianMgPSB0aGlzLnJlbmRlckxpc3Q7XG4gICAgICBvYmpzLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLmNvbXB1dGVNYXRyaXgoc3RhZ2UpO1xuICAgICAgcmV0dXJuIG9ianM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY29tcHV0ZU1hdHJpeCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXB1dGVNYXRyaXgoc3RhZ2UpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdGFnZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLl9jb21wdXRlTWF0cml4KHN0YWdlLmNoaWxkcmVuW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpbml0Q29tcGxleCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRDb21wbGV4KG8pIHtcbiAgICAgIG8uY29tcGxleENvbXBvc2l0ZU9wZXJhdGlvbiA9IHRoaXMuX2dldENvbXBvc2l0ZU9wZXJhdGlvbihvKTtcbiAgICAgIG8uY29tcGxleEFscGhhID0gdGhpcy5fZ2V0QWxwaGEobywgMSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2NvbXB1dGVNYXRyaXgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29tcHV0ZU1hdHJpeChvLCBtdHgpIHtcbiAgICAgIGlmICghby5pc1Zpc2libGUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobXR4ICYmICFvLmZpeGVkKSB7XG4gICAgICAgIG8uX21hdHJpeC5pbml0aWFsaXplKG10eC5hLCBtdHguYiwgbXR4LmMsIG10eC5kLCBtdHgudHgsIG10eC50eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvLl9tYXRyaXguaW5pdGlhbGl6ZSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIH1cblxuICAgICAgby5fbWF0cml4LmFwcGVuZFRyYW5zZm9ybShvLngsIG8ueSwgby5zY2FsZVgsIG8uc2NhbGVZLCBvLnJvdGF0aW9uLCBvLnNrZXdYLCBvLnNrZXdZLCBvLm9yaWdpblgsIG8ub3JpZ2luWSk7XG5cbiAgICAgIGlmIChvIGluc3RhbmNlb2YgX2dyb3VwMi5kZWZhdWx0KSB7XG4gICAgICAgIHZhciBsaXN0ID0gby5jaGlsZHJlbixcbiAgICAgICAgICAgIGxlbiA9IGxpc3QubGVuZ3RoLFxuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl9jb21wdXRlTWF0cml4KGxpc3RbaV0sIG8uX21hdHJpeCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIChvIGluc3RhbmNlb2YgR3JhcGhpY3MpIHtcbiAgICAgICAgLy8gICB0aGlzLnJlbmRlckxpc3QucHVzaChvKVxuICAgICAgICAvLyAgIHRoaXMuaW5pdENvbXBsZXgobylcbiAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgby5pbml0QUFCQigpO1xuICAgICAgICAvLyBpZiAodGhpcy5pc0luU3RhZ2UobykpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJMaXN0LnB1c2gobyk7XG4gICAgICAgIHRoaXMuaW5pdENvbXBsZXgobyk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19nZXRDb21wb3NpdGVPcGVyYXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q29tcG9zaXRlT3BlcmF0aW9uKG8pIHtcbiAgICAgIGlmIChvLmNvbXBvc2l0ZU9wZXJhdGlvbikgcmV0dXJuIG8uY29tcG9zaXRlT3BlcmF0aW9uO1xuICAgICAgaWYgKG8ucGFyZW50KSByZXR1cm4gdGhpcy5fZ2V0Q29tcG9zaXRlT3BlcmF0aW9uKG8ucGFyZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0QWxwaGEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QWxwaGEobywgYWxwaGEpIHtcbiAgICAgIHZhciByZXN1bHQgPSBvLmFscGhhICogYWxwaGE7XG4gICAgICBpZiAoby5wYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEFscGhhKG8ucGFyZW50LCByZXN1bHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpc0luU3RhZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0luU3RhZ2Uobykge1xuICAgICAgcmV0dXJuIHRoaXMuY29sbGlzaW9uQmV0d2VlbkFBQkIoby5BQUJCLCB0aGlzLnN0YWdlLkFBQkIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvbGxpc2lvbkJldHdlZW5BQUJCJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29sbGlzaW9uQmV0d2VlbkFBQkIoQUFCQjEsIEFBQkIyKSB7XG4gICAgICB2YXIgbWF4WCA9IEFBQkIxWzBdICsgQUFCQjFbMl07XG4gICAgICBpZiAobWF4WCA8IEFBQkIyWzBdKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgbWluWCA9IEFBQkIxWzBdO1xuICAgICAgaWYgKG1pblggPiBBQUJCMlswXSArIEFBQkIyWzJdKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgbWF4WSA9IEFBQkIxWzFdICsgQUFCQjFbM107XG4gICAgICBpZiAobWF4WSA8IEFBQkIyWzFdKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgbWluWSA9IEFBQkIxWzFdO1xuICAgICAgaWYgKG1pblkgPiBBQUJCMlsxXSArIEFBQkIyWzNdKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVuZGVyZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJlbmRlcmVyO1xuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ3JvdXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2dyb3VwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dyb3VwKTtcblxudmFyIF9yZW5kZXJlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG52YXIgX3JlbmRlcmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlbmRlcmVyKTtcblxudmFyIF93eEhpdFJlbmRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xuXG52YXIgX3d4SGl0UmVuZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3d4SGl0UmVuZGVyKTtcblxudmFyIF9ldmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfZXZlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBXZVN0YWdlID0gZnVuY3Rpb24gKF9Hcm91cCkge1xuICBfaW5oZXJpdHMoV2VTdGFnZSwgX0dyb3VwKTtcblxuICBmdW5jdGlvbiBXZVN0YWdlKHdpZHRoLCBoZWlnaHQsIGlkLCBwYWdlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlU3RhZ2UpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFdlU3RhZ2UuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihXZVN0YWdlKSkuY2FsbCh0aGlzKSk7XG5cbiAgICB2YXIgY29tcG9uZW50ID0gcGFnZS5zZWxlY3RDb21wb25lbnQoJyMnICsgaWQpO1xuICAgIGNvbXBvbmVudC5zZXREYXRhKHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfSk7XG4gICAgY29tcG9uZW50LnN0YWdlID0gX3RoaXM7XG4gICAgdmFyIGNhbnZhc0lkID0gY29tcG9uZW50LmdldENheENhbnZhc0lkKCk7XG5cbiAgICB2YXIgY3R4ID0gd3guY3JlYXRlQ2FudmFzQ29udGV4dChjYW52YXNJZCwgY29tcG9uZW50KTtcbiAgICB2YXIgaGl0Q3R4ID0gd3guY3JlYXRlQ2FudmFzQ29udGV4dChjYW52YXNJZCArICdIaXQnLCBjb21wb25lbnQpO1xuICAgIF90aGlzLnJlbmRlcmVyID0gbmV3IF9yZW5kZXJlcjIuZGVmYXVsdChjdHgsIHdpZHRoLCBoZWlnaHQpO1xuICAgIF90aGlzLl9oaXRSZW5kZXIgPSBuZXcgX3d4SGl0UmVuZGVyMi5kZWZhdWx0KGhpdEN0eCwgY29tcG9uZW50LCBjYW52YXNJZCk7XG4gICAgX3RoaXMuX292ZXJPYmplY3QgPSBudWxsO1xuICAgIF90aGlzLmN0eCA9IGN0eDtcbiAgICBfdGhpcy5oaXRBQUJCID0gdHJ1ZTtcbiAgICBfdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIF90aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoV2VTdGFnZSwgW3tcbiAgICBrZXk6ICd0b3VjaFN0YXJ0SGFuZGxlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvdWNoU3RhcnRIYW5kbGVyKGV2dCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBwMSA9IGV2dC5jaGFuZ2VkVG91Y2hlc1swXTtcblxuICAgICAgZXZ0LnN0YWdlWCA9IHAxLng7XG4gICAgICBldnQuc3RhZ2VZID0gcDEueTtcblxuICAgICAgdGhpcy5fZ2V0T2JqZWN0VW5kZXJQb2ludChldnQsIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgX3RoaXMyLndpbGxEcmFnT2JqZWN0ID0gb2JqO1xuICAgICAgICBfdGhpczIuX21vdXNlRG93blggPSBldnQuc3RhZ2VYO1xuICAgICAgICBfdGhpczIuX21vdXNlRG93blkgPSBldnQuc3RhZ2VZO1xuICAgICAgICBfdGhpczIucHJlU3RhZ2VYID0gZXZ0LnN0YWdlWDtcbiAgICAgICAgX3RoaXMyLnByZVN0YWdlWSA9IGV2dC5zdGFnZVk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd0b3VjaE1vdmVIYW5kbGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG91Y2hNb3ZlSGFuZGxlcihldnQpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgcDEgPSBldnQuY2hhbmdlZFRvdWNoZXNbMF07XG5cbiAgICAgIGV2dC5zdGFnZVggPSBwMS54O1xuICAgICAgZXZ0LnN0YWdlWSA9IHAxLnk7XG5cbiAgICAgIHRoaXMuX2dldE9iamVjdFVuZGVyUG9pbnQoZXZ0LCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBtb2NrRXZ0ID0gbmV3IF9ldmVudDIuZGVmYXVsdCgpO1xuICAgICAgICBtb2NrRXZ0LnN0YWdlWCA9IGV2dC5zdGFnZVg7XG4gICAgICAgIG1vY2tFdnQuc3RhZ2VZID0gZXZ0LnN0YWdlWTtcbiAgICAgICAgbW9ja0V2dC5wdXJlRXZlbnQgPSBldnQ7XG5cbiAgICAgICAgaWYgKF90aGlzMy53aWxsRHJhZ09iamVjdCkge1xuICAgICAgICAgIG1vY2tFdnQudHlwZSA9ICdkcmFnJztcbiAgICAgICAgICBtb2NrRXZ0LmR4ID0gbW9ja0V2dC5zdGFnZVggLSBfdGhpczMucHJlU3RhZ2VYO1xuICAgICAgICAgIG1vY2tFdnQuZHkgPSBtb2NrRXZ0LnN0YWdlWSAtIF90aGlzMy5wcmVTdGFnZVk7XG4gICAgICAgICAgX3RoaXMzLnByZVN0YWdlWCA9IG1vY2tFdnQuc3RhZ2VYO1xuICAgICAgICAgIF90aGlzMy5wcmVTdGFnZVkgPSBtb2NrRXZ0LnN0YWdlWTtcbiAgICAgICAgICBfdGhpczMud2lsbERyYWdPYmplY3QuZGlzcGF0Y2hFdmVudChtb2NrRXZ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmopIHtcbiAgICAgICAgICBpZiAoX3RoaXMzLl9vdmVyT2JqZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBfdGhpczMuX292ZXJPYmplY3QgPSBvYmo7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvYmouaWQgIT09IF90aGlzMy5fb3Zlck9iamVjdC5pZCkge1xuICAgICAgICAgICAgICBfdGhpczMuX292ZXJPYmplY3QgPSBvYmo7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtb2NrRXZ0LnR5cGUgPSAndG91Y2htb3ZlJztcbiAgICAgICAgICAgICAgb2JqLmRpc3BhdGNoRXZlbnQobW9ja0V2dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF90aGlzMy5fb3Zlck9iamVjdCkge1xuICAgICAgICAgIF90aGlzMy5fb3Zlck9iamVjdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RvdWNoRW5kSGFuZGxlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvdWNoRW5kSGFuZGxlcihldnQpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgcDEgPSBldnQuY2hhbmdlZFRvdWNoZXNbMF07XG5cbiAgICAgIGV2dC5zdGFnZVggPSBwMS54O1xuICAgICAgZXZ0LnN0YWdlWSA9IHAxLnk7XG5cbiAgICAgIHZhciBtb2NrRXZ0ID0gbmV3IF9ldmVudDIuZGVmYXVsdCgpO1xuICAgICAgbW9ja0V2dC5zdGFnZVggPSBldnQuc3RhZ2VYO1xuICAgICAgbW9ja0V2dC5zdGFnZVkgPSBldnQuc3RhZ2VZO1xuXG4gICAgICBtb2NrRXZ0LnB1cmVFdmVudCA9IGV2dDtcblxuICAgICAgdGhpcy5fZ2V0T2JqZWN0VW5kZXJQb2ludChldnQsIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgX3RoaXM0Ll9tb3VzZVVwWCA9IGV2dC5zdGFnZVg7XG4gICAgICAgIF90aGlzNC5fbW91c2VVcFkgPSBldnQuc3RhZ2VZO1xuXG4gICAgICAgIF90aGlzNC53aWxsRHJhZ09iamVjdCA9IG51bGw7XG4gICAgICAgIF90aGlzNC5wcmVTdGFnZVggPSBudWxsO1xuICAgICAgICBfdGhpczQucHJlU3RhZ2VZID0gbnVsbDtcblxuICAgICAgICBpZiAob2JqICYmIE1hdGguYWJzKF90aGlzNC5fbW91c2VEb3duWCAtIF90aGlzNC5fbW91c2VVcFgpIDwgMzAgJiYgTWF0aC5hYnMoX3RoaXM0Ll9tb3VzZURvd25ZIC0gX3RoaXM0Ll9tb3VzZVVwWSkgPCAzMCkge1xuICAgICAgICAgIG1vY2tFdnQudHlwZSA9ICd0YXAnO1xuICAgICAgICAgIG9iai5kaXNwYXRjaEV2ZW50KG1vY2tFdnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfaGFuZGxlTW91c2VPdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlTW91c2VPdXQoZXZ0KSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICBwdXJlRXZlbnQ6IGV2dCxcbiAgICAgICAgdHlwZTogJ21vdXNlb3V0JyxcbiAgICAgICAgc3RhZ2VYOiBldnQuc3RhZ2VYLFxuICAgICAgICBzdGFnZVk6IGV2dC5zdGFnZVlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19nZXRPYmplY3RVbmRlclBvaW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldE9iamVjdFVuZGVyUG9pbnQoZXZ0LCBjYikge1xuICAgICAgdmFyIGxpc3QgPSB0aGlzLnJlbmRlcmVyLmdldEhpdFJlbmRlckxpc3QodGhpcyk7XG4gICAgICBpZiAodGhpcy5oaXRBQUJCKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oaXRSZW5kZXIuaGl0QUFCQihsaXN0LCBldnQsIGNiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2hpdFJlbmRlci5jbGVhcigpO1xuICAgICAgICB0aGlzLl9oaXRSZW5kZXIuaGl0KGxpc3QsIGV2dCwgY2IsIGxpc3QubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbih0eXBlLCBjYikge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ3RvdWNoc3RhcnQnOlxuICAgICAgICAgIHRoaXMudG91Y2hTdGFydCA9IGNiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0b3VjaG1vdmUnOlxuICAgICAgICAgIHRoaXMudG91Y2hNb3ZlID0gY2I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RvdWNoZW5kJzpcbiAgICAgICAgICB0aGlzLnRvdWNoRW5kID0gY2I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGUodGhpcyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFdlU3RhZ2U7XG59KF9ncm91cDIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFdlU3RhZ2U7XG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9zaGFwZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfc2hhcGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2hhcGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBSb3VuZGVkUmVjdCA9IGZ1bmN0aW9uIChfU2hhcGUpIHtcbiAgX2luaGVyaXRzKFJvdW5kZWRSZWN0LCBfU2hhcGUpO1xuXG4gIGZ1bmN0aW9uIFJvdW5kZWRSZWN0KHdpZHRoLCBoZWlnaHQsIHIsIG9wdGlvbikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSb3VuZGVkUmVjdCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoUm91bmRlZFJlY3QuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihSb3VuZGVkUmVjdCkpLmNhbGwodGhpcykpO1xuXG4gICAgX3RoaXMub3B0aW9uID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBsaW5lV2lkdGg6IDFcbiAgICB9LCBvcHRpb24pO1xuICAgIF90aGlzLnIgPSByIHx8IDA7XG4gICAgX3RoaXMud2lkdGggPSB3aWR0aDtcbiAgICBfdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJvdW5kZWRSZWN0LCBbe1xuICAgIGtleTogJ2RyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KCkge1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSB0aGlzLmhlaWdodCxcbiAgICAgICAgICByID0gdGhpcy5yO1xuXG4gICAgICB2YXIgYXggPSByLFxuICAgICAgICAgIGF5ID0gMCxcbiAgICAgICAgICBieCA9IHdpZHRoLFxuICAgICAgICAgIGJ5ID0gMCxcbiAgICAgICAgICBjeCA9IHdpZHRoLFxuICAgICAgICAgIGN5ID0gaGVpZ2h0LFxuICAgICAgICAgIGR4ID0gMCxcbiAgICAgICAgICBkeSA9IGhlaWdodCxcbiAgICAgICAgICBleCA9IDAsXG4gICAgICAgICAgZXkgPSAwO1xuXG4gICAgICB0aGlzLmJlZ2luUGF0aCgpO1xuXG4gICAgICB0aGlzLm1vdmVUbyhheCwgYXkpO1xuICAgICAgdGhpcy5hcmNUbyhieCwgYnksIGN4LCBjeSwgcik7XG4gICAgICB0aGlzLmFyY1RvKGN4LCBjeSwgZHgsIGR5LCByKTtcbiAgICAgIHRoaXMuYXJjVG8oZHgsIGR5LCBleCwgZXksIHIpO1xuICAgICAgdGhpcy5hcmNUbyhleCwgZXksIGF4LCBheSwgcik7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbi5maWxsU3R5bGUpIHtcbiAgICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICAgICAgdGhpcy5maWxsU3R5bGUodGhpcy5vcHRpb24uZmlsbFN0eWxlKTtcbiAgICAgICAgdGhpcy5maWxsKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbi5zdHJva2VTdHlsZSkge1xuICAgICAgICB0aGlzLmxpbmVXaWR0aCh0aGlzLm9wdGlvbi5saW5lV2lkdGgpO1xuICAgICAgICB0aGlzLnN0cm9rZVN0eWxlKHRoaXMub3B0aW9uLnN0cm9rZVN0eWxlKTtcbiAgICAgICAgdGhpcy5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUm91bmRlZFJlY3Q7XG59KF9zaGFwZTIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJvdW5kZWRSZWN0O1xuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfdHdlZW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxudmFyIF90d2VlbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90d2Vlbik7XG5cbnZhciBfdG8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIF90bzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90byk7XG5cbl9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuXG52YXIgX3N0YWdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cbnZhciBfc3RhZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RhZ2UpO1xuXG52YXIgX3dlU3RhZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxudmFyIF93ZVN0YWdlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dlU3RhZ2UpO1xuXG52YXIgX2dyYXBoaWNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9ncmFwaGljczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ncmFwaGljcyk7XG5cbnZhciBfYml0bWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9iaXRtYXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYml0bWFwKTtcblxudmFyIF90ZXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF90ZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RleHQpO1xuXG52YXIgX2dyb3VwID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9ncm91cDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ncm91cCk7XG5cbnZhciBfc3ByaXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIF9zcHJpdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ByaXRlKTtcblxudmFyIF9zaGFwZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfc2hhcGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2hhcGUpO1xuXG52YXIgX3JvdW5kZWRSZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbnZhciBfcm91bmRlZFJlY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91bmRlZFJlY3QpO1xuXG52YXIgX2Fycm93UGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuXG52YXIgX2Fycm93UGF0aDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hcnJvd1BhdGgpO1xuXG52YXIgX2VsbGlwc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcblxudmFyIF9lbGxpcHNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VsbGlwc2UpO1xuXG52YXIgX3BhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcblxudmFyIF9wYXRoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhdGgpO1xuXG52YXIgX2J1dHRvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xuXG52YXIgX2J1dHRvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9idXR0b24pO1xuXG52YXIgX3JlY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KTtcblxudmFyIF9yZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlY3QpO1xuXG52YXIgX2NpcmNsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpO1xuXG52YXIgX2NpcmNsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jaXJjbGUpO1xuXG52YXIgX3BvbHlnb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcblxudmFyIF9wb2x5Z29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BvbHlnb24pO1xuXG52YXIgX2VxdWlsYXRlcmFsUG9seWdvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xuXG52YXIgX2VxdWlsYXRlcmFsUG9seWdvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lcXVpbGF0ZXJhbFBvbHlnb24pO1xuXG52YXIgX3JhZkludGVydmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbl90bzIuZGVmYXVsdC5lYXNpbmcgPSB7XG4gIGxpbmVhcjogX3R3ZWVuMi5kZWZhdWx0LkVhc2luZy5MaW5lYXIuTm9uZVxufTtcblxudmFyIGNheCA9IHtcbiAgZWFzaW5nOiB7XG4gICAgbGluZWFyOiBfdHdlZW4yLmRlZmF1bHQuRWFzaW5nLkxpbmVhci5Ob25lXG4gIH0sXG4gIHV0aWw6IHtcbiAgICByYW5kb21JbnQ6IGZ1bmN0aW9uIHJhbmRvbUludChtaW4sIG1heCkge1xuICAgICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gICAgfVxuICB9LFxuXG4gIFN0YWdlOiBfc3RhZ2UyLmRlZmF1bHQsXG4gIFdlU3RhZ2U6IF93ZVN0YWdlMi5kZWZhdWx0LFxuICBHcmFwaGljczogX2dyYXBoaWNzMi5kZWZhdWx0LFxuICBCaXRtYXA6IF9iaXRtYXAyLmRlZmF1bHQsXG4gIFRleHQ6IF90ZXh0Mi5kZWZhdWx0LFxuICBHcm91cDogX2dyb3VwMi5kZWZhdWx0LFxuICBTcHJpdGU6IF9zcHJpdGUyLmRlZmF1bHQsXG4gIFNoYXBlOiBfc2hhcGUyLmRlZmF1bHQsXG5cbiAgQXJyb3dQYXRoOiBfYXJyb3dQYXRoMi5kZWZhdWx0LFxuICBFbGxpcHNlOiBfZWxsaXBzZTIuZGVmYXVsdCxcbiAgUGF0aDogX3BhdGgyLmRlZmF1bHQsXG5cbiAgQnV0dG9uOiBfYnV0dG9uMi5kZWZhdWx0LFxuXG4gIFJvdW5kZWRSZWN0OiBfcm91bmRlZFJlY3QyLmRlZmF1bHQsXG4gIFJlY3Q6IF9yZWN0Mi5kZWZhdWx0LFxuICBDaXJjbGU6IF9jaXJjbGUyLmRlZmF1bHQsXG4gIFBvbHlnb246IF9wb2x5Z29uMi5kZWZhdWx0LFxuICBFcXVpbGF0ZXJhbFBvbHlnb246IF9lcXVpbGF0ZXJhbFBvbHlnb24yLmRlZmF1bHQsXG5cbiAgc2V0SW50ZXJ2YWw6IF9yYWZJbnRlcnZhbC5zZXRSYWZJbnRlcnZhbCxcbiAgY2xlYXJJbnRlcnZhbDogX3JhZkludGVydmFsLmNsZWFyUmFmSW50ZXJ2YWwsXG4gIHRpY2s6IGZ1bmN0aW9uIHRpY2soZm4pIHtcbiAgICByZXR1cm4gKDAsIF9yYWZJbnRlcnZhbC5zZXRSYWZJbnRlcnZhbCkoZm4sIDE2KTtcbiAgfSxcbiAgdW50aWNrOiBmdW5jdGlvbiB1bnRpY2sodGlja0lkKSB7XG4gICAgKDAsIF9yYWZJbnRlcnZhbC5jbGVhclJhZkludGVydmFsKSh0aWNrSWQpO1xuICB9LFxuXG4gIGNheENhbnZhc0lkOiAwLFxuICBUV0VFTjogX3R3ZWVuMi5kZWZhdWx0LFxuICBUbzogX3RvMi5kZWZhdWx0XG59O1xuXG5bJ1F1YWRyYXRpYycsICdDdWJpYycsICdRdWFydGljJywgJ1F1aW50aWMnLCAnU2ludXNvaWRhbCcsICdFeHBvbmVudGlhbCcsICdDaXJjdWxhcicsICdFbGFzdGljJywgJ0JhY2snLCAnQm91bmNlJ10uZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICB2YXIgaXRlbUxvd2VyID0gaXRlbS50b0xvd2VyQ2FzZSgpO1xuICBjYXguZWFzaW5nW2l0ZW1Mb3dlciArICdJbiddID0gX3R3ZWVuMi5kZWZhdWx0LkVhc2luZ1tpdGVtXS5JbjtcbiAgY2F4LmVhc2luZ1tpdGVtTG93ZXIgKyAnT3V0J10gPSBfdHdlZW4yLmRlZmF1bHQuRWFzaW5nW2l0ZW1dLk91dDtcbiAgY2F4LmVhc2luZ1tpdGVtTG93ZXIgKyAnSW5PdXQnXSA9IF90d2VlbjIuZGVmYXVsdC5FYXNpbmdbaXRlbV0uSW5PdXQ7XG5cbiAgX3RvMi5kZWZhdWx0LmVhc2luZ1tpdGVtTG93ZXIgKyAnSW4nXSA9IF90d2VlbjIuZGVmYXVsdC5FYXNpbmdbaXRlbV0uSW47XG4gIF90bzIuZGVmYXVsdC5lYXNpbmdbaXRlbUxvd2VyICsgJ091dCddID0gX3R3ZWVuMi5kZWZhdWx0LkVhc2luZ1tpdGVtXS5PdXQ7XG4gIF90bzIuZGVmYXVsdC5lYXNpbmdbaXRlbUxvd2VyICsgJ0luT3V0J10gPSBfdHdlZW4yLmRlZmF1bHQuRWFzaW5nW2l0ZW1dLkluT3V0O1xufSk7XG5cbmNheC5sb2FkSW1nID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgb3B0aW9uLmNvbXBsZXRlKHRoaXMpO1xuICB9O1xuICBpbWcuc3JjID0gb3B0aW9uLmltZztcbn07XG5cbmNheC5sb2FkSW1ncyA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgbG9hZGVkID0gMDtcbiAgdmFyIGxlbiA9IG9wdGlvbi5pbWdzLmxlbmd0aDtcbiAgb3B0aW9uLmltZ3MuZm9yRWFjaChmdW5jdGlvbiAoc3JjLCBpbmRleCkge1xuICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKGksIGltZykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVzdWx0W2ldID0gaW1nO1xuICAgICAgICBsb2FkZWQrKztcbiAgICAgICAgb3B0aW9uLnByb2dyZXNzICYmIG9wdGlvbi5wcm9ncmVzcyhsb2FkZWQgLyBsZW4sIGxvYWRlZCwgaSwgaW1nLCByZXN1bHQpO1xuICAgICAgICBpZiAobG9hZGVkID09PSBsZW4pIHtcbiAgICAgICAgICBvcHRpb24uY29tcGxldGUgJiYgb3B0aW9uLmNvbXBsZXRlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfShpbmRleCwgaW1nKTtcbiAgICBpbWcuc3JjID0gc3JjO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY2F4O1xuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX3RvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbnZhciBfdG8yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG8pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5fdG8yLmRlZmF1bHQuZXh0ZW5kKCdydWJiZXInLCBbWyd0bycsIFsnc2NhbGVYJywge1xuICAnMCc6IDEuMjUsXG4gICcxJzogMzAwXG59XSwgWydzY2FsZVknLCB7XG4gICcwJzogMC43NSxcbiAgJzEnOiAzMDBcbn1dXSwgWyd0bycsIFsnc2NhbGVYJywge1xuICAnMCc6IDAuNzUsXG4gICcxJzogMTAwXG59XSwgWydzY2FsZVknLCB7XG4gICcwJzogMS4yNSxcbiAgJzEnOiAxMDBcbn1dXSwgWyd0bycsIFsnc2NhbGVYJywge1xuICAnMCc6IDEuMTUsXG4gICcxJzogMTAwXG59XSwgWydzY2FsZVknLCB7XG4gICcwJzogMC44NSxcbiAgJzEnOiAxMDBcbn1dXSwgWyd0bycsIFsnc2NhbGVYJywge1xuICAnMCc6IDAuOTUsXG4gICcxJzogMTUwXG59XSwgWydzY2FsZVknLCB7XG4gICcwJzogMS4wNSxcbiAgJzEnOiAxNTBcbn1dXSwgWyd0bycsIFsnc2NhbGVYJywge1xuICAnMCc6IDEuMDUsXG4gICcxJzogMTAwXG59XSwgWydzY2FsZVknLCB7XG4gICcwJzogMC45NSxcbiAgJzEnOiAxMDBcbn1dXSwgWyd0bycsIFsnc2NhbGVYJywge1xuICAnMCc6IDEsXG4gICcxJzogMjUwXG59XSwgWydzY2FsZVknLCB7XG4gICcwJzogMSxcbiAgJzEnOiAyNTBcbn1dXV0pO1xuXG5fdG8yLmRlZmF1bHQuZXh0ZW5kKCdib3VuY2VJbicsIFtbJ3RvJywgWydzY2FsZVgnLCB7XG4gICcwJzogMCxcbiAgJzEnOiAwXG59XSwgWydzY2FsZVknLCB7XG4gICcwJzogMCxcbiAgJzEnOiAwXG59XV0sIFsndG8nLCBbJ3NjYWxlWCcsIHtcbiAgJzAnOiAxLjM1LFxuICAnMSc6IDIwMFxufV0sIFsnc2NhbGVZJywge1xuICAnMCc6IDEuMzUsXG4gICcxJzogMjAwXG59XV0sIFsndG8nLCBbJ3NjYWxlWCcsIHtcbiAgJzAnOiAwLjksXG4gICcxJzogMTAwXG59XSwgWydzY2FsZVknLCB7XG4gICcwJzogMC45LFxuICAnMSc6IDEwMFxufV1dLCBbJ3RvJywgWydzY2FsZVgnLCB7XG4gICcwJzogMS4xLFxuICAnMSc6IDEwMFxufV0sIFsnc2NhbGVZJywge1xuICAnMCc6IDEuMSxcbiAgJzEnOiAxMDBcbn1dXSwgWyd0bycsIFsnc2NhbGVYJywge1xuICAnMCc6IDAuOTUsXG4gICcxJzogMTAwXG59XSwgWydzY2FsZVknLCB7XG4gICcwJzogMC45NSxcbiAgJzEnOiAxMDBcbn1dXSwgWyd0bycsIFsnc2NhbGVYJywge1xuICAnMCc6IDEsXG4gICcxJzogMTAwXG59XSwgWydzY2FsZVknLCB7XG4gICcwJzogMSxcbiAgJzEnOiAxMDBcbn1dXV0pO1xuXG5fdG8yLmRlZmF1bHQuZXh0ZW5kKCdmbGlwSW5YJywgW1sndG8nLCBbJ3JvdGF0ZVgnLCB7XG4gICcwJzogLTkwLFxuICAnMSc6IDBcbn1dXSwgWyd0bycsIFsncm90YXRlWCcsIHtcbiAgJzAnOiAyMCxcbiAgJzEnOiAzMDBcbn1dXSwgWyd0bycsIFsncm90YXRlWCcsIHtcbiAgJzAnOiAtMjAsXG4gICcxJzogMzAwXG59XV0sIFsndG8nLCBbJ3JvdGF0ZVgnLCB7XG4gICcwJzogMTAsXG4gICcxJzogMzAwXG59XV0sIFsndG8nLCBbJ3JvdGF0ZVgnLCB7XG4gICcwJzogLTUsXG4gICcxJzogMzAwXG59XV0sIFsndG8nLCBbJ3JvdGF0ZVgnLCB7XG4gICcwJzogMCxcbiAgJzEnOiAzMDBcbn1dXV0pO1xuXG5fdG8yLmRlZmF1bHQuZXh0ZW5kKCd6b29tT3V0JywgW1sndG8nLCBbJ3NjYWxlWCcsIHtcbiAgJzAnOiAwLFxuICAnMSc6IDQwMFxufV0sIFsnc2NhbGVZJywge1xuICAnMCc6IDAsXG4gICcxJzogNDAwXG59XV1dKTtcblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3dlZ2FtZUNhbnZhcyA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXG52YXIgX3dlZ2FtZUNhbnZhczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93ZWdhbWVDYW52YXMpO1xuXG52YXIgX2dyb3VwID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9ncm91cDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ncm91cCk7XG5cbnZhciBfcmVuZGVyZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxudmFyIF9yZW5kZXJlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZW5kZXJlcik7XG5cbnZhciBfaGl0UmVuZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XG5cbnZhciBfaGl0UmVuZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hpdFJlbmRlcik7XG5cbnZhciBfZXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgX2V2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50KTtcblxudmFyIF93ZVN0YWdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbnZhciBfd2VTdGFnZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93ZVN0YWdlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgU3RhZ2UgPSBmdW5jdGlvbiAoX0dyb3VwKSB7XG4gIF9pbmhlcml0cyhTdGFnZSwgX0dyb3VwKTtcblxuICBmdW5jdGlvbiBTdGFnZSh3aWR0aCwgaGVpZ2h0LCByZW5kZXJUbykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGFnZSk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU3RhZ2UuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTdGFnZSkpLmNhbGwodGhpcykpO1xuXG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgX3RoaXMuaXNXZWdhbWUgPSB0eXBlb2Ygd3ggIT09ICd1bmRlZmluZWQnICYmIHd4LmNyZWF0ZUNhbnZhcztcbiAgICBfdGhpcy5tb3ZlRGV0ZWN0aW9uSW50ZXJ2YWwgPSAwO1xuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIC8vIHdlZ2FtZVxuICAgICAgX3RoaXMuY2FudmFzID0gX3dlZ2FtZUNhbnZhczIuZGVmYXVsdDtcbiAgICAgIF90aGlzLmRpc2FibGVNb3ZlRGV0ZWN0aW9uID0gdHJ1ZTtcbiAgICAgIF90aGlzLm1vdmVEZXRlY3Rpb25JbnRlcnZhbCA9IDUwMDtcbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gNCkge1xuICAgICAgdmFyIF9yZXQ7XG5cbiAgICAgIC8vIHdlYXBwXG4gICAgICByZXR1cm4gX3JldCA9IG5ldyBfd2VTdGFnZTIuZGVmYXVsdChhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsZW4gPT09IDEpIHtcbiAgICAgICAgX3RoaXMuY2FudmFzID0gdHlwZW9mIHdpZHRoID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iod2lkdGgpIDogd2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5yZW5kZXJUbyA9IHR5cGVvZiByZW5kZXJUbyA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHJlbmRlclRvKSA6IHJlbmRlclRvO1xuICAgICAgICBpZiAoX3RoaXMucmVuZGVyVG8udGFnTmFtZSA9PT0gJ0NBTlZBUycpIHtcbiAgICAgICAgICBfdGhpcy5jYW52YXMgPSBfdGhpcy5yZW5kZXJUbztcbiAgICAgICAgICBfdGhpcy5jYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICBfdGhpcy5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgIF90aGlzLmNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgIF90aGlzLmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgX3RoaXMucmVuZGVyVG8uYXBwZW5kQ2hpbGQoX3RoaXMuY2FudmFzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZ2V0IHJlY3QgYWdhaW4gd2hlbiB0cmlnZ2VyIG9uc2Nyb2xsIG9ucmVzaXplIGV2ZW50IT9cbiAgICAgIF90aGlzLl9ib3VuZGluZ0NsaWVudFJlY3QgPSBfdGhpcy5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIF90aGlzLm9mZnNldCA9IF90aGlzLl9nZXRPZmZzZXQoX3RoaXMuY2FudmFzKTtcbiAgICB9XG4gICAgX3RoaXMucmVuZGVyZXIgPSBuZXcgX3JlbmRlcmVyMi5kZWZhdWx0KF90aGlzLmNhbnZhcyk7XG4gICAgaWYgKF90aGlzLmlzV2VnYW1lKSB7XG4gICAgICB3eC5vblRvdWNoU3RhcnQoZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuX2hhbmRsZU1vdXNlRG93bihldnQpO1xuICAgICAgfSk7XG5cbiAgICAgIHd4Lm9uVG91Y2hNb3ZlKGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLl9oYW5kbGVNb3VzZU1vdmUoZXZ0KTtcbiAgICAgIH0pO1xuXG4gICAgICB3eC5vblRvdWNoRW5kKGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLl9oYW5kbGVNb3VzZVVwKGV2dCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuX2hhbmRsZUNsaWNrKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIF90aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5faGFuZGxlTW91c2VEb3duKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIF90aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5faGFuZGxlTW91c2VNb3ZlKGV2dCk7XG4gICAgICB9KTtcbiAgICAgIF90aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuX2hhbmRsZU1vdXNlVXAoZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgX3RoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuX2hhbmRsZU1vdXNlT3V0KGV2dCk7XG4gICAgICB9KTtcbiAgICAgIF90aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuX2hhbmRsZU1vdXNlRG93bihldnQpO1xuICAgICAgfSk7XG4gICAgICBfdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuX2hhbmRsZU1vdXNlTW92ZShldnQpO1xuICAgICAgfSk7XG4gICAgICBfdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5faGFuZGxlTW91c2VVcChldnQpO1xuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdkYmxjbGljaycsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLl9oYW5kbGVEYmxDbGljayhldnQpO1xuICAgICAgfSk7XG4gICAgICAvLyB0aGlzLmFkZEV2ZW50KHRoaXMuY2FudmFzLCBcIm1vdXNld2hlZWxcIiwgdGhpcy5faGFuZGxlTW91c2VXaGVlbC5iaW5kKHRoaXMpKTtcblxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5faGFuZGxlQ29udGV4dG1lbnUoZXZ0KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF90aGlzLmJvcmRlclRvcFdpZHRoID0gMDtcbiAgICBfdGhpcy5ib3JkZXJMZWZ0V2lkdGggPSAwO1xuXG4gICAgX3RoaXMuaGl0QUFCQiA9IGZhbHNlO1xuICAgIF90aGlzLl9oaXRSZW5kZXIgPSBuZXcgX2hpdFJlbmRlcjIuZGVmYXVsdCgpO1xuXG4gICAgX3RoaXMuX292ZXJPYmplY3QgPSBudWxsO1xuXG4gICAgX3RoaXMuX3NjYWxlWCA9IDE7XG4gICAgX3RoaXMuX3NjYWxlWSA9IDE7XG5cbiAgICBfdGhpcy5fbW91c2VEb3duWCA9IDA7XG4gICAgX3RoaXMuX21vdXNlRG93blkgPSAwO1xuXG4gICAgX3RoaXMuX21vdXNlVXBYID0gMDtcbiAgICBfdGhpcy5fbW91c2VVcFkgPSAwO1xuXG4gICAgX3RoaXMud2lsbERyYWdPYmplY3QgPSBudWxsO1xuICAgIF90aGlzLnByZVN0YWdlWCA9IG51bGw7XG4gICAgX3RoaXMucHJlU3RhZ2VZID0gbnVsbDtcblxuICAgIF90aGlzLndpZHRoID0gX3RoaXMuY2FudmFzLndpZHRoO1xuICAgIF90aGlzLmhlaWdodCA9IF90aGlzLmNhbnZhcy5oZWlnaHQ7XG5cbiAgICBfdGhpcy5fX19pbnN0YW5jZW9mID0gJ1N0YWdlJztcblxuICAgIF90aGlzLl9tb3ZlRGV0ZWN0aW9uVGltZSA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN0YWdlLCBbe1xuICAgIGtleTogJ19oYW5kbGVDb250ZXh0bWVudScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVDb250ZXh0bWVudShldnQpIHtcbiAgICAgIHRoaXMuX2dldE9iamVjdFVuZGVyUG9pbnQoZXZ0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfaGFuZGxlRGJsQ2xpY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlRGJsQ2xpY2soZXZ0KSB7XG4gICAgICB0aGlzLl9nZXRPYmplY3RVbmRlclBvaW50KGV2dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2hhbmRsZUNsaWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUNsaWNrKGV2dCkge1xuICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX21vdXNlRG93blggLSB0aGlzLl9tb3VzZVVwWCkgPCAyMCAmJiBNYXRoLmFicyh0aGlzLl9tb3VzZURvd25ZIC0gdGhpcy5fbW91c2VVcFkpIDwgMjApIHtcbiAgICAgICAgdGhpcy5fZ2V0T2JqZWN0VW5kZXJQb2ludChldnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19oYW5kbGVNb3VzZURvd24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlTW91c2VEb3duKGV2dCkge1xuICAgICAgaWYgKHRoaXMuaXNXZWdhbWUpIHtcbiAgICAgICAgZXZ0LnR5cGUgPSAndG91Y2hzdGFydCc7XG4gICAgICB9XG4gICAgICB0aGlzLm9mZnNldCA9IHRoaXMuX2dldE9mZnNldCh0aGlzLmNhbnZhcyk7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fZ2V0T2JqZWN0VW5kZXJQb2ludChldnQpO1xuICAgICAgdGhpcy53aWxsRHJhZ09iamVjdCA9IG9iajtcbiAgICAgIHRoaXMuX21vdXNlRG93blggPSBldnQuc3RhZ2VYO1xuICAgICAgdGhpcy5fbW91c2VEb3duWSA9IGV2dC5zdGFnZVk7XG4gICAgICB0aGlzLnByZVN0YWdlWCA9IGV2dC5zdGFnZVg7XG4gICAgICB0aGlzLnByZVN0YWdlWSA9IGV2dC5zdGFnZVk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2NhbGVFdmVudFBvaW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2NhbGVFdmVudFBvaW50KHgsIHkpIHtcbiAgICAgIHRoaXMuX3NjYWxlWCA9IHg7XG4gICAgICB0aGlzLl9zY2FsZVkgPSB5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19oYW5kbGVNb3VzZVVwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZU1vdXNlVXAoZXZ0KSB7XG4gICAgICBpZiAodGhpcy5pc1dlZ2FtZSkge1xuICAgICAgICBldnQudHlwZSA9ICd0b3VjaGVuZCc7XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0gdGhpcy5fZ2V0T2JqZWN0VW5kZXJQb2ludChldnQpO1xuICAgICAgdGhpcy5fbW91c2VVcFggPSBldnQuc3RhZ2VYO1xuICAgICAgdGhpcy5fbW91c2VVcFkgPSBldnQuc3RhZ2VZO1xuXG4gICAgICB2YXIgbW9ja0V2dCA9IG5ldyBfZXZlbnQyLmRlZmF1bHQoKTtcbiAgICAgIG1vY2tFdnQuc3RhZ2VYID0gZXZ0LnN0YWdlWDtcbiAgICAgIG1vY2tFdnQuc3RhZ2VZID0gZXZ0LnN0YWdlWTtcbiAgICAgIG1vY2tFdnQucHVyZUV2ZW50ID0gZXZ0O1xuXG4gICAgICB0aGlzLndpbGxEcmFnT2JqZWN0ID0gbnVsbDtcbiAgICAgIHRoaXMucHJlU3RhZ2VYID0gbnVsbDtcbiAgICAgIHRoaXMucHJlU3RhZ2VZID0gbnVsbDtcblxuICAgICAgaWYgKG9iaiAmJiBldnQudHlwZSA9PT0gJ3RvdWNoZW5kJyAmJiBNYXRoLmFicyh0aGlzLl9tb3VzZURvd25YIC0gdGhpcy5fbW91c2VVcFgpIDwgMzAgJiYgTWF0aC5hYnModGhpcy5fbW91c2VEb3duWSAtIHRoaXMuX21vdXNlVXBZKSA8IDMwKSB7XG4gICAgICAgIG1vY2tFdnQudHlwZSA9ICd0YXAnO1xuICAgICAgICBvYmouZGlzcGF0Y2hFdmVudChtb2NrRXZ0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfaGFuZGxlTW91c2VPdXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlTW91c2VPdXQoZXZ0KSB7XG4gICAgICB0aGlzLl9jb21wdXRlU3RhZ2VYWShldnQpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgcHVyZUV2ZW50OiBldnQsXG4gICAgICAgIHR5cGU6ICdtb3VzZW91dCcsXG4gICAgICAgIHN0YWdlWDogZXZ0LnN0YWdlWCxcbiAgICAgICAgc3RhZ2VZOiBldnQuc3RhZ2VZXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfaGFuZGxlTW91c2VNb3ZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZU1vdXNlTW92ZShldnQpIHtcbiAgICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy5fbW92ZURldGVjdGlvblRpbWUgPCB0aGlzLm1vdmVEZXRlY3Rpb25JbnRlcnZhbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9tb3ZlRGV0ZWN0aW9uVGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgIGlmICh0aGlzLmlzV2VnYW1lKSB7XG4gICAgICAgIGV2dC50eXBlID0gJ3RvdWNobW92ZSc7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kaXNhYmxlTW92ZURldGVjdGlvbikgcmV0dXJuO1xuICAgICAgdmFyIG9iaiA9IHRoaXMuX2dldE9iamVjdFVuZGVyUG9pbnQoZXZ0KTtcbiAgICAgIHZhciBtb2NrRXZ0ID0gbmV3IF9ldmVudDIuZGVmYXVsdCgpO1xuICAgICAgbW9ja0V2dC5zdGFnZVggPSBldnQuc3RhZ2VYO1xuICAgICAgbW9ja0V2dC5zdGFnZVkgPSBldnQuc3RhZ2VZO1xuICAgICAgbW9ja0V2dC5wdXJlRXZlbnQgPSBldnQ7XG5cbiAgICAgIGlmICh0aGlzLndpbGxEcmFnT2JqZWN0KSB7XG4gICAgICAgIG1vY2tFdnQudHlwZSA9ICdkcmFnJztcbiAgICAgICAgbW9ja0V2dC5keCA9IG1vY2tFdnQuc3RhZ2VYIC0gdGhpcy5wcmVTdGFnZVg7XG4gICAgICAgIG1vY2tFdnQuZHkgPSBtb2NrRXZ0LnN0YWdlWSAtIHRoaXMucHJlU3RhZ2VZO1xuICAgICAgICB0aGlzLnByZVN0YWdlWCA9IG1vY2tFdnQuc3RhZ2VYO1xuICAgICAgICB0aGlzLnByZVN0YWdlWSA9IG1vY2tFdnQuc3RhZ2VZO1xuICAgICAgICB0aGlzLndpbGxEcmFnT2JqZWN0LmRpc3BhdGNoRXZlbnQobW9ja0V2dCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmopIHtcbiAgICAgICAgaWYgKHRoaXMuX292ZXJPYmplY3QgPT09IG51bGwpIHtcbiAgICAgICAgICBtb2NrRXZ0LnR5cGUgPSAnbW91c2VvdmVyJztcbiAgICAgICAgICBvYmouZGlzcGF0Y2hFdmVudChtb2NrRXZ0KTtcbiAgICAgICAgICB0aGlzLl9vdmVyT2JqZWN0ID0gb2JqO1xuICAgICAgICAgIHRoaXMuX3NldEN1cnNvcihvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChvYmouaWQgIT09IHRoaXMuX292ZXJPYmplY3QuaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJPYmplY3QuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgIHB1cmVFdmVudDogZXZ0LFxuICAgICAgICAgICAgICB0eXBlOiAnbW91c2VvdXQnLFxuICAgICAgICAgICAgICBzdGFnZVg6IGV2dC5zdGFnZVgsXG4gICAgICAgICAgICAgIHN0YWdlWTogZXZ0LnN0YWdlWVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtb2NrRXZ0LnR5cGUgPSAnbW91c2VvdmVyJztcbiAgICAgICAgICAgIG9iai5kaXNwYXRjaEV2ZW50KG1vY2tFdnQpO1xuICAgICAgICAgICAgdGhpcy5fc2V0Q3Vyc29yKG9iaik7XG4gICAgICAgICAgICB0aGlzLl9vdmVyT2JqZWN0ID0gb2JqO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2NrRXZ0LnR5cGUgPSAnbW91c2Vtb3ZlJztcbiAgICAgICAgICAgIG9iai5kaXNwYXRjaEV2ZW50KG1vY2tFdnQpO1xuICAgICAgICAgICAgbW9ja0V2dC50eXBlID0gJ3RvdWNobW92ZSc7XG4gICAgICAgICAgICBvYmouZGlzcGF0Y2hFdmVudChtb2NrRXZ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fb3Zlck9iamVjdCkge1xuICAgICAgICBtb2NrRXZ0LnR5cGUgPSAnbW91c2VvdXQnO1xuICAgICAgICB0aGlzLl9vdmVyT2JqZWN0LmRpc3BhdGNoRXZlbnQobW9ja0V2dCk7XG4gICAgICAgIHRoaXMuX292ZXJPYmplY3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9zZXRDdXJzb3IoeyBjdXJzb3I6ICdkZWZhdWx0JyB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfc2V0Q3Vyc29yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEN1cnNvcihvYmopIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMuc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9iai5jdXJzb3IpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUuY3Vyc29yID0gb2JqLmN1cnNvcjtcbiAgICAgIH0gZWxzZSBpZiAob2JqLnBhcmVudCkge1xuICAgICAgICB0aGlzLl9zZXRDdXJzb3Iob2JqLnBhcmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZXRDdXJzb3IoeyBjdXJzb3I6ICdkZWZhdWx0JyB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0T2JqZWN0VW5kZXJQb2ludCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRPYmplY3RVbmRlclBvaW50KGV2dCkge1xuICAgICAgdGhpcy5fY29tcHV0ZVN0YWdlWFkoZXZ0KTtcbiAgICAgIGlmICh0aGlzLmhpdEFBQkIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hpdFJlbmRlci5oaXRBQUJCKHRoaXMsIGV2dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5faGl0UmVuZGVyLmhpdFBpeGVsKHRoaXMsIGV2dCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2NvbXB1dGVTdGFnZVhZJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbXB1dGVTdGFnZVhZKGV2dCkge1xuICAgICAgdGhpcy5fYm91bmRpbmdDbGllbnRSZWN0ID0gdGhpcy5pc1dlZ2FtZSA/IHsgbGVmdDogMCwgdG9wOiAwIH0gOiB0aGlzLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGlmIChldnQudG91Y2hlcyB8fCBldnQuY2hhbmdlZFRvdWNoZXMpIHtcbiAgICAgICAgdmFyIGZpcnN0VG91Y2ggPSBldnQudG91Y2hlc1swXSB8fCBldnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICAgIGlmIChmaXJzdFRvdWNoKSB7XG4gICAgICAgICAgZXZ0LnN0YWdlWCA9IChmaXJzdFRvdWNoLnBhZ2VYIC0gdGhpcy5vZmZzZXRbMF0pIC8gdGhpcy5fc2NhbGVYO1xuICAgICAgICAgIGV2dC5zdGFnZVkgPSAoZmlyc3RUb3VjaC5wYWdlWSAtIHRoaXMub2Zmc2V0WzFdKSAvIHRoaXMuX3NjYWxlWTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXZ0LnN0YWdlWCA9IChldnQuY2xpZW50WCAtIHRoaXMuX2JvdW5kaW5nQ2xpZW50UmVjdC5sZWZ0IC0gdGhpcy5ib3JkZXJMZWZ0V2lkdGgpIC8gdGhpcy5fc2NhbGVYO1xuICAgICAgICBldnQuc3RhZ2VZID0gKGV2dC5jbGllbnRZIC0gdGhpcy5fYm91bmRpbmdDbGllbnRSZWN0LnRvcCAtIHRoaXMuYm9yZGVyVG9wV2lkdGgpIC8gdGhpcy5fc2NhbGVZO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19nZXRPZmZzZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0T2Zmc2V0KGVsKSB7XG4gICAgICBpZiAodGhpcy5pc1dlZ2FtZSkge1xuICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgICAgfVxuICAgICAgdmFyIF90ID0gMCxcbiAgICAgICAgICBfbCA9IDA7XG4gICAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICAgICAgdmFyIGJveCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBfbCA9IGJveC5sZWZ0O1xuICAgICAgICBfdCA9IGJveC50b3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZSAoZWwub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgX3QgKz0gZWwub2Zmc2V0VG9wO1xuICAgICAgICAgIF9sICs9IGVsLm9mZnNldExlZnQ7XG4gICAgICAgICAgZWwgPSBlbC5vZmZzZXRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtfbCwgX3RdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtfbCArIE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQpLCBfdCArIE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AsIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wKV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGUodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbih0eXBlLCBmbikge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBfdGhpczIuX2NvbXB1dGVTdGFnZVhZKGV2dCk7XG4gICAgICAgIGZuKGV2dCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvZmYnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvZmYodHlwZSwgZm4pIHtcbiAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdGFnZTtcbn0oX2dyb3VwMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU3RhZ2U7XG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciB3ZWdhbWVDYW52YXMgPSBudWxsO1xuaWYgKHR5cGVvZiB3eCAhPT0gJ3VuZGVmaW5lZCcgJiYgd3guY3JlYXRlQ2FudmFzKSB7XG4gIHdlZ2FtZUNhbnZhcyA9IHd4LmNyZWF0ZUNhbnZhcygpO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSB3ZWdhbWVDYW52YXM7XG5cbi8qKiovIH0pLFxuLyogMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIERFR19UT19SQUQgPSAwLjAxNzQ1MzI5MjUxOTk0MzI5NTtcbnZhciBQSV8yID0gTWF0aC5QSSAqIDI7XG5cbnZhciBNYXRyaXgyRCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWF0cml4MkQoYSwgYiwgYywgZCwgdHgsIHR5KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hdHJpeDJEKTtcblxuICAgIHRoaXMuYSA9IGEgPT0gbnVsbCA/IDEgOiBhO1xuICAgIHRoaXMuYiA9IGIgfHwgMDtcbiAgICB0aGlzLmMgPSBjIHx8IDA7XG4gICAgdGhpcy5kID0gZCA9PSBudWxsID8gMSA6IGQ7XG4gICAgdGhpcy50eCA9IHR4IHx8IDA7XG4gICAgdGhpcy50eSA9IHR5IHx8IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWF0cml4MkQsIFt7XG4gICAga2V5OiBcImlkZW50aXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlkZW50aXR5KCkge1xuICAgICAgdGhpcy5hID0gdGhpcy5kID0gMTtcbiAgICAgIHRoaXMuYiA9IHRoaXMuYyA9IHRoaXMudHggPSB0aGlzLnR5ID0gMDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBlbmRUcmFuc2Zvcm1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kVHJhbnNmb3JtKHgsIHksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbiwgc2tld1gsIHNrZXdZLCBvcmlnaW5YLCBvcmlnaW5ZKSB7XG4gICAgICBpZiAocm90YXRpb24gJSAzNjApIHtcbiAgICAgICAgdmFyIHIgPSByb3RhdGlvbiAqIERFR19UT19SQUQ7XG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhyKTtcbiAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKHIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29zID0gMTtcbiAgICAgICAgc2luID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChza2V3WCB8fCBza2V3WSkge1xuICAgICAgICBza2V3WCAqPSBERUdfVE9fUkFEO1xuICAgICAgICBza2V3WSAqPSBERUdfVE9fUkFEO1xuICAgICAgICB0aGlzLmFwcGVuZChNYXRoLmNvcyhza2V3WSksIE1hdGguc2luKHNrZXdZKSwgLU1hdGguc2luKHNrZXdYKSwgTWF0aC5jb3Moc2tld1gpLCB4LCB5KTtcbiAgICAgICAgdGhpcy5hcHBlbmQoY29zICogc2NhbGVYLCBzaW4gKiBzY2FsZVgsIC1zaW4gKiBzY2FsZVksIGNvcyAqIHNjYWxlWSwgMCwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFwcGVuZChjb3MgKiBzY2FsZVgsIHNpbiAqIHNjYWxlWCwgLXNpbiAqIHNjYWxlWSwgY29zICogc2NhbGVZLCB4LCB5KTtcbiAgICAgIH1cbiAgICAgIGlmIChvcmlnaW5YIHx8IG9yaWdpblkpIHtcbiAgICAgICAgdGhpcy50eCAtPSBvcmlnaW5YICogdGhpcy5hICsgb3JpZ2luWSAqIHRoaXMuYztcbiAgICAgICAgdGhpcy50eSAtPSBvcmlnaW5YICogdGhpcy5iICsgb3JpZ2luWSAqIHRoaXMuZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kKGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuICAgICAgdmFyIGExID0gdGhpcy5hO1xuICAgICAgdmFyIGIxID0gdGhpcy5iO1xuICAgICAgdmFyIGMxID0gdGhpcy5jO1xuICAgICAgdmFyIGQxID0gdGhpcy5kO1xuICAgICAgdGhpcy5hID0gYSAqIGExICsgYiAqIGMxO1xuICAgICAgdGhpcy5iID0gYSAqIGIxICsgYiAqIGQxO1xuICAgICAgdGhpcy5jID0gYyAqIGExICsgZCAqIGMxO1xuICAgICAgdGhpcy5kID0gYyAqIGIxICsgZCAqIGQxO1xuICAgICAgdGhpcy50eCA9IHR4ICogYTEgKyB0eSAqIGMxICsgdGhpcy50eDtcbiAgICAgIHRoaXMudHkgPSB0eCAqIGIxICsgdHkgKiBkMSArIHRoaXMudHk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdGlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplKGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuICAgICAgdGhpcy5hID0gYTtcbiAgICAgIHRoaXMuYiA9IGI7XG4gICAgICB0aGlzLmMgPSBjO1xuICAgICAgdGhpcy5kID0gZDtcbiAgICAgIHRoaXMudHggPSB0eDtcbiAgICAgIHRoaXMudHkgPSB0eTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRWYWx1ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWVzKGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuICAgICAgdGhpcy5hID0gYSA9PSBudWxsID8gMSA6IGE7XG4gICAgICB0aGlzLmIgPSBiIHx8IDA7XG4gICAgICB0aGlzLmMgPSBjIHx8IDA7XG4gICAgICB0aGlzLmQgPSBkID09IG51bGwgPyAxIDogZDtcbiAgICAgIHRoaXMudHggPSB0eCB8fCAwO1xuICAgICAgdGhpcy50eSA9IHR5IHx8IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW52ZXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludmVydCgpIHtcbiAgICAgIHZhciBhMSA9IHRoaXMuYTtcbiAgICAgIHZhciBiMSA9IHRoaXMuYjtcbiAgICAgIHZhciBjMSA9IHRoaXMuYztcbiAgICAgIHZhciBkMSA9IHRoaXMuZDtcbiAgICAgIHZhciB0eDEgPSB0aGlzLnR4O1xuICAgICAgdmFyIG4gPSBhMSAqIGQxIC0gYjEgKiBjMTtcblxuICAgICAgdGhpcy5hID0gZDEgLyBuO1xuICAgICAgdGhpcy5iID0gLWIxIC8gbjtcbiAgICAgIHRoaXMuYyA9IC1jMSAvIG47XG4gICAgICB0aGlzLmQgPSBhMSAvIG47XG4gICAgICB0aGlzLnR4ID0gKGMxICogdGhpcy50eSAtIGQxICogdHgxKSAvIG47XG4gICAgICB0aGlzLnR5ID0gLShhMSAqIHRoaXMudHkgLSBiMSAqIHR4MSkgLyBuO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weShtYXRyaXgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFZhbHVlcyhtYXRyaXguYSwgbWF0cml4LmIsIG1hdHJpeC5jLCBtYXRyaXguZCwgbWF0cml4LnR4LCBtYXRyaXgudHkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXRyaXgyRDtcbn0oKTtcblxuTWF0cml4MkQuZGVjb21wb3NlID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIHR4LCB0eSwgdHJhbnNmb3JtKSB7XG4gIHZhciBza2V3WCA9IC1NYXRoLmF0YW4yKC1jLCBkKTtcbiAgdmFyIHNrZXdZID0gTWF0aC5hdGFuMihiLCBhKTtcblxuICB2YXIgZGVsdGEgPSBNYXRoLmFicyhza2V3WCArIHNrZXdZKTtcblxuICBpZiAoZGVsdGEgPCAwLjAwMDAxIHx8IE1hdGguYWJzKFBJXzIgLSBkZWx0YSkgPCAwLjAwMDAxKSB7XG4gICAgdHJhbnNmb3JtLnJvdGF0aW9uID0gc2tld1k7XG5cbiAgICBpZiAoYSA8IDAgJiYgZCA+PSAwKSB7XG4gICAgICB0cmFuc2Zvcm0ucm90YXRpb24gKz0gdHJhbnNmb3JtLnJvdGF0aW9uIDw9IDAgPyBNYXRoLlBJIDogLU1hdGguUEk7XG4gICAgfVxuXG4gICAgdHJhbnNmb3JtLnNrZXdYID0gdHJhbnNmb3JtLnNrZXdZID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc2Zvcm0ucm90YXRpb24gPSAwO1xuICAgIHRyYW5zZm9ybS5za2V3WCA9IHNrZXdYO1xuICAgIHRyYW5zZm9ybS5za2V3WSA9IHNrZXdZO1xuICB9XG5cbiAgLy8gbmV4dCBzZXQgc2NhbGVcbiAgdHJhbnNmb3JtLnNjYWxlWCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgdHJhbnNmb3JtLnNjYWxlWSA9IE1hdGguc3FydChjICogYyArIGQgKiBkKTtcblxuICAvLyBuZXh0IHNldCBwb3NpdGlvblxuICB0cmFuc2Zvcm0ueCA9IHR4O1xuICB0cmFuc2Zvcm0ueSA9IHR5O1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTWF0cml4MkQ7XG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEV2ZW50RGlzcGF0Y2hlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXZlbnREaXNwYXRjaGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudERpc3BhdGNoZXIpO1xuXG4gICAgdGhpcy5fbGlzdGVuZXJzID0gbnVsbDtcbiAgICB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzID0gbnVsbDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFdmVudERpc3BhdGNoZXIsIFt7XG4gICAga2V5OiBcImFkZEV2ZW50TGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICAgICAgdmFyIGxpc3RlbmVycztcbiAgICAgIGlmICh1c2VDYXB0dXJlKSB7XG4gICAgICAgIGxpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgPSB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzIHx8IHt9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzIHx8IHt9O1xuICAgICAgfVxuICAgICAgdmFyIGFyciA9IGxpc3RlbmVyc1t0eXBlXTtcbiAgICAgIGlmIChhcnIpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcbiAgICAgIH1cbiAgICAgIGFyciA9IGxpc3RlbmVyc1t0eXBlXTsgLy8gcmVtb3ZlIG1heSBoYXZlIGRlbGV0ZWQgdGhlIGFycmF5XG4gICAgICBpZiAoIWFycikge1xuICAgICAgICBsaXN0ZW5lcnNbdHlwZV0gPSBbbGlzdGVuZXJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpc3RlbmVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVFdmVudExpc3RlbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSB1c2VDYXB0dXJlID8gdGhpcy5fY2FwdHVyZUxpc3RlbmVycyA6IHRoaXMuX2xpc3RlbmVycztcbiAgICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBhcnIgPSBsaXN0ZW5lcnNbdHlwZV07XG4gICAgICBpZiAoIWFycikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGFyci5ldmVyeShmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGl0ZW0gPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgYXJyLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvZmZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2ZmKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXNwYXRjaEV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoZXZ0KSB7XG5cbiAgICAgIHZhciB0b3AgPSB0aGlzLFxuICAgICAgICAgIGxpc3QgPSBbdG9wXTtcbiAgICAgIHdoaWxlICh0b3AucGFyZW50KSB7XG4gICAgICAgIGxpc3QucHVzaCh0b3AgPSB0b3AucGFyZW50KTtcbiAgICAgIH1cbiAgICAgIHZhciBpLFxuICAgICAgICAgIGwgPSBsaXN0Lmxlbmd0aDtcblxuICAgICAgLy8gY2FwdHVyZSAmIGF0VGFyZ2V0XG4gICAgICBmb3IgKGkgPSBsIC0gMTsgaSA+PSAwICYmICFldnQucHJvcGFnYXRpb25TdG9wcGVkOyBpLS0pIHtcbiAgICAgICAgbGlzdFtpXS5fZGlzcGF0Y2hFdmVudChldnQsIDApO1xuICAgICAgfVxuICAgICAgLy8gYnViYmxpbmdcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsICYmICFldnQucHJvcGFnYXRpb25TdG9wcGVkOyBpKyspIHtcbiAgICAgICAgbGlzdFtpXS5fZGlzcGF0Y2hFdmVudChldnQsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZGlzcGF0Y2hFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGlzcGF0Y2hFdmVudChldnQsIHR5cGUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGV2dC50YXJnZXQgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgJiYgdHlwZSA9PT0gMCkge1xuICAgICAgICB2YXIgY2xzID0gdGhpcy5fY2FwdHVyZUxpc3RlbmVyc1tldnQudHlwZV07XG4gICAgICAgIGNscyAmJiBjbHMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICBmbi5jYWxsKF90aGlzLCBldnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2xpc3RlbmVycyAmJiB0eXBlID09PSAxKSB7XG4gICAgICAgIHZhciBscyA9IHRoaXMuX2xpc3RlbmVyc1tldnQudHlwZV07XG4gICAgICAgIGxzICYmIGxzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgZm4uY2FsbChfdGhpcywgZXZ0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEV2ZW50RGlzcGF0Y2hlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnREaXNwYXRjaGVyO1xuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgVUlEID0ge307XG5cblVJRC5fbmV4dElEID0gMDtcblxuVUlELmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFVJRC5fbmV4dElEKys7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBVSUQ7XG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9ncm91cCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfZ3JvdXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ3JvdXApO1xuXG52YXIgX2dyYXBoaWNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9ncmFwaGljczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ncmFwaGljcyk7XG5cbnZhciBfcmVuZGVyMiA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbnZhciBfcmVuZGVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlbmRlcjIpO1xuXG52YXIgX3Nwcml0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBfc3ByaXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Nwcml0ZSk7XG5cbnZhciBfYml0bWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9iaXRtYXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYml0bWFwKTtcblxudmFyIF90ZXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF90ZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RleHQpO1xuXG52YXIgX2luZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIENhbnZhc1JlbmRlciA9IGZ1bmN0aW9uIChfUmVuZGVyKSB7XG4gIF9pbmhlcml0cyhDYW52YXNSZW5kZXIsIF9SZW5kZXIpO1xuXG4gIGZ1bmN0aW9uIENhbnZhc1JlbmRlcihjYW52YXNPckNvbnRleHQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FudmFzUmVuZGVyKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDYW52YXNSZW5kZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDYW52YXNSZW5kZXIpKS5jYWxsKHRoaXMpKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBfdGhpcy5jdHggPSBjYW52YXNPckNvbnRleHQ7XG4gICAgICBfdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgX3RoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpcy5jdHggPSBjYW52YXNPckNvbnRleHQuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIF90aGlzLndpZHRoID0gY2FudmFzT3JDb250ZXh0LndpZHRoO1xuICAgICAgX3RoaXMuaGVpZ2h0ID0gY2FudmFzT3JDb250ZXh0LmhlaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENhbnZhc1JlbmRlciwgW3tcbiAgICBrZXk6ICdjbGVhcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKGN0eCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoY3R4LCBvLCBjYWNoZURhdGEpIHtcbiAgICAgIHZhciBtdHggPSBvLl9tYXRyaXg7XG4gICAgICBpZiAoby5jaGlsZHJlbikge1xuICAgICAgICB2YXIgbGlzdCA9IG8uY2hpbGRyZW4uc2xpY2UoMCksXG4gICAgICAgICAgICBsID0gbGlzdC5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gbGlzdFtpXTtcbiAgICAgICAgICBtdHguaW5pdGlhbGl6ZSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgICBtdHguYXBwZW5kVHJhbnNmb3JtKG8ueCwgby55LCBvLnNjYWxlWCwgby5zY2FsZVksIG8ucm90YXRpb24sIG8uc2tld1gsIG8uc2tld1ksIG8ub3JpZ2luWCwgby5vcmlnaW5ZKTtcbiAgICAgICAgICAvLyBpZiAoIXRoaXMuY2hlY2tCb3VuZEV2ZW50KGNoaWxkKSkgY29udGludWVcbiAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgIHRoaXMuX3JlbmRlcihjdHgsIGNoaWxkLCBjYWNoZURhdGEgPyBudWxsIDogbXR4LCBjYWNoZURhdGEsIHRydWUpO1xuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcihjdHgsIG8sIGNhY2hlRGF0YSA/IG51bGwgOiBtdHgsIGNhY2hlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXIoY3R4LCBvLCBtdHgsIGNhY2hlRGF0YSwgaW5Hcm91cCkge1xuICAgICAgaWYgKCFvLmlzVmlzaWJsZSgpKSByZXR1cm47XG4gICAgICBpZiAobXR4ICYmICFvLmZpeGVkKSB7XG4gICAgICAgIG8uX21hdHJpeC5pbml0aWFsaXplKG10eC5hLCBtdHguYiwgbXR4LmMsIG10eC5kLCBtdHgudHgsIG10eC50eSk7XG4gICAgICB9IGVsc2UgaWYgKGNhY2hlRGF0YSAmJiAhby5maXhlZCkge1xuICAgICAgICBvLl9tYXRyaXguaW5pdGlhbGl6ZShjYWNoZURhdGEuc2NhbGUsIDAsIDAsIGNhY2hlRGF0YS5zY2FsZSwgY2FjaGVEYXRhLnggKiAtMSwgY2FjaGVEYXRhLnkgKiAtMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvLl9tYXRyaXguaW5pdGlhbGl6ZSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIH1cbiAgICAgIG10eCA9IG8uX21hdHJpeDtcblxuICAgICAgLy8gZ3JvdXAg6L+b6KGMIGNhY2hlIGNhbnZhcyDlhoXpg6jnmoTlrZDlhYPntKDpnIDopoHov5vooYxhcHBlbmRUcmFuc2Zvcm1cbiAgICAgIC8vIGNhY2hlIGNhbnZhcyDmuLLmn5PkuI3lj6DliqDoh6rouqvnmoQgdHJhbnNmb3Jt77yM5Zug5Li66L+b5YWl5Li75riy5p+T5Lya6L+b6KGMYXBwZW5kVHJhbnNmb3JtXG4gICAgICBpZiAoaW5Hcm91cCB8fCAhY2FjaGVEYXRhKSB7XG4gICAgICAgIG10eC5hcHBlbmRUcmFuc2Zvcm0oby54LCBvLnksIG8uc2NhbGVYLCBvLnNjYWxlWSwgby5yb3RhdGlvbiwgby5za2V3WCwgby5za2V3WSwgby5vcmlnaW5YLCBvLm9yaWdpblkpO1xuICAgICAgfVxuICAgICAgdmFyIG9jZyA9IG8uY2xpcEdyYXBoaWNzO1xuICAgICAgaWYgKG9jZykge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIG9jZy5fbWF0cml4LmNvcHkobXR4KTtcbiAgICAgICAgb2NnLl9tYXRyaXguYXBwZW5kVHJhbnNmb3JtKG9jZy54LCBvY2cueSwgb2NnLnNjYWxlWCwgb2NnLnNjYWxlWSwgb2NnLnJvdGF0aW9uLCBvY2cuc2tld1gsIG9jZy5za2V3WSwgb2NnLm9yaWdpblgsIG9jZy5vcmlnaW5ZKTtcbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybShvY2cuX21hdHJpeC5hLCBvY2cuX21hdHJpeC5iLCBvY2cuX21hdHJpeC5jLCBvY2cuX21hdHJpeC5kLCBvY2cuX21hdHJpeC50eCwgb2NnLl9tYXRyaXgudHkpO1xuICAgICAgICBvY2cucmVuZGVyKGN0eCk7XG4gICAgICAgIGN0eC5jbGlwKG8uY2xpcFJ1bGVOb256ZXJvID8gJ25vbnplcm8nIDogJ2V2ZW5vZGQnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9hY2cgPSBvLmFic0NsaXBHcmFwaGljcztcbiAgICAgIGlmIChvYWNnKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgb2FjZy5fbWF0cml4LmluaXRpYWxpemUoMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgIG9hY2cuX21hdHJpeC5hcHBlbmRUcmFuc2Zvcm0ob2FjZy54LCBvYWNnLnksIG9hY2cuc2NhbGVYLCBvYWNnLnNjYWxlWSwgb2FjZy5yb3RhdGlvbiwgb2FjZy5za2V3WCwgb2FjZy5za2V3WSwgb2FjZy5vcmlnaW5YLCBvYWNnLm9yaWdpblkpO1xuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKG9hY2cuX21hdHJpeC5hLCBvYWNnLl9tYXRyaXguYiwgb2FjZy5fbWF0cml4LmMsIG9hY2cuX21hdHJpeC5kLCBvYWNnLl9tYXRyaXgudHgsIG9hY2cuX21hdHJpeC50eSk7XG4gICAgICAgIG9hY2cucmVuZGVyKGN0eCk7XG4gICAgICAgIGN0eC5jbGlwKG8uYWJzQ2xpcFJ1bGVOb256ZXJvID8gJ25vbnplcm8nIDogJ2V2ZW5vZGQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYoIWNhY2hlRGF0YSl7XG4gICAgICBjdHguc2V0VHJhbnNmb3JtKG10eC5hLCBtdHguYiwgbXR4LmMsIG10eC5kLCBtdHgudHgsIG10eC50eSk7XG4gICAgICAvLyB9XG4gICAgICBpZiAoby5fcmVhZHlUb0NhY2hlIHx8IG8uY2FjaGVVcGRhdGluZykge1xuICAgICAgICB0aGlzLnNldENvbXBsZXhQcm9wcyhjdHgsIG8pO1xuICAgICAgICBvLl9yZWFkeVRvQ2FjaGUgPSBmYWxzZTtcbiAgICAgICAgby5jYWNoZUN0eC5jbGVhclJlY3QoMCwgMCwgby5jYWNoZUNhbnZhcy53aWR0aCwgby5jYWNoZUNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBvLmNhY2hlQ3R4LnNhdmUoKTtcbiAgICAgICAgdGhpcy5yZW5kZXIoby5jYWNoZUN0eCwgbywgby5fY2FjaGVEYXRhKTtcbiAgICAgICAgby5jYWNoZUN0eC5yZXN0b3JlKCk7XG4gICAgICAgIC8vIGRlYnVnIGNhY2hlQ2FudmFzXG4gICAgICAgIC8vIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoby5jYWNoZUNhbnZhcylcbiAgICAgICAgaWYgKG8uX3JlYWR5VG9GaWx0ZXIpIHtcbiAgICAgICAgICBvLmNhY2hlQ3R4LnB1dEltYWdlRGF0YSgoMCwgX2luZGV4LmZpbHRlcikoby5jYWNoZUN0eC5nZXRJbWFnZURhdGEoMCwgMCwgby5jYWNoZUNhbnZhcy53aWR0aCwgby5jYWNoZUNhbnZhcy5oZWlnaHQpLCBvLl9maWx0ZXJOYW1lKSwgMCwgMCk7XG4gICAgICAgICAgdGhpcy5fcmVhZHlUb0ZpbHRlciA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmRyYXdJbWFnZShvLmNhY2hlQ2FudmFzLCBvLl9jYWNoZURhdGEueCwgby5fY2FjaGVEYXRhLnkpO1xuICAgICAgfSBlbHNlIGlmIChvLmNhY2hlQ2FudmFzICYmICFjYWNoZURhdGEpIHtcbiAgICAgICAgdGhpcy5zZXRDb21wbGV4UHJvcHMoY3R4LCBvKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShvLmNhY2hlQ2FudmFzLCBvLl9jYWNoZURhdGEueCwgby5fY2FjaGVEYXRhLnkpO1xuICAgICAgfSBlbHNlIGlmIChvIGluc3RhbmNlb2YgX2dyb3VwMi5kZWZhdWx0KSB7XG4gICAgICAgIHZhciBsaXN0ID0gby5jaGlsZHJlbi5zbGljZSgwKSxcbiAgICAgICAgICAgIGwgPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgIHRoaXMuX3JlbmRlcihjdHgsIGxpc3RbaV0sIG10eCk7XG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvIGluc3RhbmNlb2YgX2dyYXBoaWNzMi5kZWZhdWx0KSB7XG4gICAgICAgIHRoaXMuc2V0Q29tcGxleFByb3BzKGN0eCwgbyk7XG4gICAgICAgIG8ucmVuZGVyKGN0eCk7XG4gICAgICB9IGVsc2UgaWYgKG8gaW5zdGFuY2VvZiBfc3ByaXRlMi5kZWZhdWx0ICYmIG8ucmVjdCkge1xuICAgICAgICB0aGlzLnNldENvbXBsZXhQcm9wcyhjdHgsIG8pO1xuICAgICAgICBvLnVwZGF0ZUZyYW1lKCk7XG4gICAgICAgIHZhciByZWN0ID0gby5yZWN0O1xuICAgICAgICBjdHguZHJhd0ltYWdlKG8uaW1nLCByZWN0WzBdLCByZWN0WzFdLCByZWN0WzJdLCByZWN0WzNdLCAwLCAwLCByZWN0WzJdLCByZWN0WzNdKTtcbiAgICAgIH0gZWxzZSBpZiAobyBpbnN0YW5jZW9mIF9iaXRtYXAyLmRlZmF1bHQgJiYgby5yZWN0KSB7XG4gICAgICAgIHRoaXMuc2V0Q29tcGxleFByb3BzKGN0eCwgbyk7XG4gICAgICAgIHZhciBiUmVjdCA9IG8ucmVjdDtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShvLmltZywgYlJlY3RbMF0sIGJSZWN0WzFdLCBiUmVjdFsyXSwgYlJlY3RbM10sIDAsIDAsIGJSZWN0WzJdLCBiUmVjdFszXSk7XG4gICAgICB9IGVsc2UgaWYgKG8gaW5zdGFuY2VvZiBfdGV4dDIuZGVmYXVsdCkge1xuICAgICAgICB0aGlzLnNldENvbXBsZXhQcm9wcyhjdHgsIG8pO1xuICAgICAgICBjdHguZm9udCA9IG8uZm9udDtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG8uY29sb3I7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSBvLnRleHRBbGlnbjtcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IG8uYmFzZWxpbmU7XG4gICAgICAgIGN0eC5maWxsVGV4dChvLnRleHQsIDAsIDApO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldENvbXBsZXhQcm9wcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENvbXBsZXhQcm9wcyhjdHgsIG8pIHtcbiAgICAgIG8uY29tcGxleENvbXBvc2l0ZU9wZXJhdGlvbiA9IGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSB0aGlzLmdldENvbXBvc2l0ZU9wZXJhdGlvbihvKTtcbiAgICAgIG8uY29tcGxleEFscGhhID0gY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5nZXRBbHBoYShvLCAxKTtcblxuICAgICAgby5jb21wbGV4U2hhZG93ID0gdGhpcy5nZXRTaGFkb3cobyk7XG4gICAgICBpZiAoby5jb21wbGV4U2hhZG93KSB7XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IG8uY29tcGxleFNoYWRvdy5jb2xvcjtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSBvLmNvbXBsZXhTaGFkb3cub2Zmc2V0WDtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSBvLmNvbXBsZXhTaGFkb3cub2Zmc2V0WTtcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSBvLmNvbXBsZXhTaGFkb3cuYmx1cjtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDb21wb3NpdGVPcGVyYXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb21wb3NpdGVPcGVyYXRpb24obykge1xuICAgICAgaWYgKG8uY29tcG9zaXRlT3BlcmF0aW9uKSByZXR1cm4gby5jb21wb3NpdGVPcGVyYXRpb247XG4gICAgICBpZiAoby5wYXJlbnQpIHJldHVybiB0aGlzLmdldENvbXBvc2l0ZU9wZXJhdGlvbihvLnBhcmVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0QWxwaGEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBbHBoYShvLCBhbHBoYSkge1xuICAgICAgdmFyIHJlc3VsdCA9IG8uYWxwaGEgKiBhbHBoYTtcbiAgICAgIGlmIChvLnBhcmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbHBoYShvLnBhcmVudCwgcmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0U2hhZG93JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2hhZG93KG8pIHtcbiAgICAgIGlmIChvLnNoYWRvdykgcmV0dXJuIG8uc2hhZG93O1xuICAgICAgaWYgKG8ucGFyZW50KSByZXR1cm4gdGhpcy5nZXRTaGFkb3coby5wYXJlbnQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDYW52YXNSZW5kZXI7XG59KF9yZW5kZXIzLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDYW52YXNSZW5kZXI7XG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZmlsdGVyID0gZmlsdGVyO1xuXG52YXIgX2ludmVydCA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuXG52YXIgX2JsdXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcblxudmFyIF9icmlnaHRuZXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XG5cbnZhciBfY29udHJhc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcblxudmFyIF9ncmF5c2NhbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcblxudmFyIF9zZXBpYSA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xuXG52YXIgX3RocmVzaG9sZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xuXG52YXIgX2dhbW1hID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG5cbnZhciBfY29sb3JpemUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcblxuZnVuY3Rpb24gZmlsdGVyKHBpeGVscywgbmFtZSkge1xuICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHR5cGUgPSBuYW1lLnNwbGl0KCcoJylbMF07XG4gICAgdmFyIG51bSA9IGdldE51bWJlcihuYW1lKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2ludmVydCc6XG4gICAgICAgIHJldHVybiAoMCwgX2ludmVydC5pbnZlcnQpKHBpeGVscywgbnVtKTtcbiAgICAgIGNhc2UgJ2JyaWdodG5lc3MnOlxuICAgICAgICByZXR1cm4gKDAsIF9icmlnaHRuZXNzLmJyaWdodG5lc3MpKHBpeGVscywgLTI1NSArIG51bSAqIDI1NSk7XG4gICAgICBjYXNlICdibHVyJzpcbiAgICAgICAgcmV0dXJuICgwLCBfYmx1ci5ibHVyKShwaXhlbHMsIG51bSk7XG4gICAgICBjYXNlICdjb250cmFzdCc6XG4gICAgICAgIHJldHVybiAoMCwgX2NvbnRyYXN0LmNvbnRyYXN0KShwaXhlbHMsIC0yNTUgKyBudW0gKiAyNTUpO1xuICAgICAgY2FzZSAnZ3JheXNjYWxlJzpcbiAgICAgICAgcmV0dXJuICgwLCBfZ3JheXNjYWxlLmdyYXlzY2FsZSkocGl4ZWxzLCBudW0pO1xuICAgICAgY2FzZSAnc2VwaWEnOlxuICAgICAgICByZXR1cm4gKDAsIF9zZXBpYS5zZXBpYSkocGl4ZWxzLCBudW0pO1xuICAgICAgY2FzZSAndGhyZXNob2xkJzpcbiAgICAgICAgcmV0dXJuICgwLCBfdGhyZXNob2xkLnRocmVzaG9sZCkocGl4ZWxzLCBudW0pO1xuICAgICAgY2FzZSAnZ2FtbWEnOlxuICAgICAgICByZXR1cm4gKDAsIF9nYW1tYS5nYW1tYSkocGl4ZWxzLCBudW0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKG5hbWUudHlwZSkge1xuICAgICAgY2FzZSAnY29sb3JpemUnOlxuICAgICAgICByZXR1cm4gKDAsIF9jb2xvcml6ZS5jb2xvcml6ZSkocGl4ZWxzLCBuYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TnVtYmVyKHN0cikge1xuICBzdHIgPSBzdHIucmVwbGFjZSgvKGludmVydCl8KGJyaWdodG5lc3MpfChibHVyKXwoY29udHJhc3QpfChncmF5c2NhbGUpfChzZXBpYSl8KHRocmVzaG9sZCl8KGdhbW1hKT9cXCgvZywgJycpLnJlcGxhY2UoJyknLCAnJyk7XG4gIGlmIChzdHIuaW5kZXhPZignJScpICE9PSAtMSkge1xuICAgIHJldHVybiBOdW1iZXIoc3RyLnJlcGxhY2UoJyUnLCAnJykpIC8gMTAwO1xuICB9IGVsc2UgaWYgKHN0ci5pbmRleE9mKCdweCcpICE9PSAtMSkge1xuICAgIHJldHVybiBOdW1iZXIoc3RyLnJlcGxhY2UoJ3B4JywgJycpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gTnVtYmVyKHN0cik7XG4gIH1cbn1cblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5pbnZlcnQgPSBpbnZlcnQ7XG5mdW5jdGlvbiBpbnZlcnQocGl4ZWxzLCByYXRpbykge1xuICB2YXIgZCA9IHBpeGVscy5kYXRhO1xuICByYXRpbyA9IHJhdGlvID09PSB1bmRlZmluZWQgPyAxIDogcmF0aW87XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZC5sZW5ndGg7IGkgKz0gNCkge1xuICAgIGRbaV0gPSBkW2ldICsgcmF0aW8gKiAoMjU1IC0gMiAqIGRbaV0pO1xuICAgIGRbaSArIDFdID0gZFtpICsgMV0gKyByYXRpbyAqICgyNTUgLSAyICogZFtpICsgMV0pO1xuICAgIGRbaSArIDJdID0gZFtpICsgMl0gKyByYXRpbyAqICgyNTUgLSAyICogZFtpICsgMl0pO1xuICB9XG4gIHJldHVybiBwaXhlbHM7XG59XG5cbi8qKiovIH0pLFxuLyogMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYmx1ciA9IGJsdXI7XG5cbnZhciBfY3JlYXRlSW1hZ2VEYXRhID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG5cbmZ1bmN0aW9uIGJsdXIocGl4ZWxzLCBkaWFtZXRlcikge1xuICBkaWFtZXRlciA9IE1hdGguYWJzKGRpYW1ldGVyKTtcbiAgaWYgKGRpYW1ldGVyIDw9IDEpIHJldHVybiBwaXhlbHM7XG4gIHZhciByYWRpdXMgPSBkaWFtZXRlciAvIDI7XG4gIHZhciBsZW4gPSBNYXRoLmNlaWwoZGlhbWV0ZXIpICsgKDEgLSBNYXRoLmNlaWwoZGlhbWV0ZXIpICUgMik7XG4gIHZhciB3ZWlnaHRzID0gbmV3IEZsb2F0MzJBcnJheShsZW4pO1xuICB2YXIgcmhvID0gKHJhZGl1cyArIDAuNSkgLyAzO1xuICB2YXIgcmhvU3EgPSByaG8gKiByaG87XG4gIHZhciBnYXVzc2lhbkZhY3RvciA9IDEgLyBNYXRoLnNxcnQoMiAqIE1hdGguUEkgKiByaG9TcSk7XG4gIHZhciByaG9GYWN0b3IgPSAtMSAvICgyICogcmhvICogcmhvKTtcbiAgdmFyIHdzdW0gPSAwO1xuICB2YXIgbWlkZGxlID0gTWF0aC5mbG9vcihsZW4gLyAyKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciB4ID0gaSAtIG1pZGRsZTtcbiAgICB2YXIgZ3ggPSBnYXVzc2lhbkZhY3RvciAqIE1hdGguZXhwKHggKiB4ICogcmhvRmFjdG9yKTtcbiAgICB3ZWlnaHRzW2ldID0gZ3g7XG4gICAgd3N1bSArPSBneDtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHdlaWdodHMubGVuZ3RoOyBpKyspIHtcbiAgICB3ZWlnaHRzW2ldIC89IHdzdW07XG4gIH1cbiAgcmV0dXJuIHNlcGFyYWJsZUNvbnZvbHZlKHBpeGVscywgd2VpZ2h0cywgd2VpZ2h0cywgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBzZXBhcmFibGVDb252b2x2ZShwaXhlbHMsIGhvcml6V2VpZ2h0cywgdmVydFdlaWdodHMsIG9wYXF1ZSkge1xuICByZXR1cm4gaG9yaXpvbnRhbENvbnZvbHZlKHZlcnRpY2FsQ29udm9sdmUocGl4ZWxzLCB2ZXJ0V2VpZ2h0cywgb3BhcXVlKSwgaG9yaXpXZWlnaHRzLCBvcGFxdWUpO1xufVxuXG5mdW5jdGlvbiBob3Jpem9udGFsQ29udm9sdmUocGl4ZWxzLCB3ZWlnaHRzVmVjdG9yLCBvcGFxdWUpIHtcbiAgdmFyIHNpZGUgPSB3ZWlnaHRzVmVjdG9yLmxlbmd0aDtcbiAgdmFyIGhhbGZTaWRlID0gTWF0aC5mbG9vcihzaWRlIC8gMik7XG5cbiAgdmFyIHNyYyA9IHBpeGVscy5kYXRhO1xuICB2YXIgc3cgPSBwaXhlbHMud2lkdGg7XG4gIHZhciBzaCA9IHBpeGVscy5oZWlnaHQ7XG5cbiAgdmFyIHcgPSBzdztcbiAgdmFyIGggPSBzaDtcbiAgdmFyIG91dHB1dCA9ICgwLCBfY3JlYXRlSW1hZ2VEYXRhLmNyZWF0ZUltYWdlRGF0YSkodywgaCk7XG4gIHZhciBkc3QgPSBvdXRwdXQuZGF0YTtcblxuICB2YXIgYWxwaGFGYWMgPSBvcGFxdWUgPyAxIDogMDtcblxuICBmb3IgKHZhciB5ID0gMDsgeSA8IGg7IHkrKykge1xuICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrKSB7XG4gICAgICB2YXIgc3kgPSB5O1xuICAgICAgdmFyIHN4ID0geDtcbiAgICAgIHZhciBkc3RPZmYgPSAoeSAqIHcgKyB4KSAqIDQ7XG4gICAgICB2YXIgciA9IDAsXG4gICAgICAgICAgZyA9IDAsXG4gICAgICAgICAgYiA9IDAsXG4gICAgICAgICAgYSA9IDA7XG4gICAgICBmb3IgKHZhciBjeCA9IDA7IGN4IDwgc2lkZTsgY3grKykge1xuICAgICAgICB2YXIgc2N5ID0gc3k7XG4gICAgICAgIHZhciBzY3ggPSBNYXRoLm1pbihzdyAtIDEsIE1hdGgubWF4KDAsIHN4ICsgY3ggLSBoYWxmU2lkZSkpO1xuICAgICAgICB2YXIgc3JjT2ZmID0gKHNjeSAqIHN3ICsgc2N4KSAqIDQ7XG4gICAgICAgIHZhciB3dCA9IHdlaWdodHNWZWN0b3JbY3hdO1xuICAgICAgICByICs9IHNyY1tzcmNPZmZdICogd3Q7XG4gICAgICAgIGcgKz0gc3JjW3NyY09mZiArIDFdICogd3Q7XG4gICAgICAgIGIgKz0gc3JjW3NyY09mZiArIDJdICogd3Q7XG4gICAgICAgIGEgKz0gc3JjW3NyY09mZiArIDNdICogd3Q7XG4gICAgICB9XG4gICAgICBkc3RbZHN0T2ZmXSA9IHI7XG4gICAgICBkc3RbZHN0T2ZmICsgMV0gPSBnO1xuICAgICAgZHN0W2RzdE9mZiArIDJdID0gYjtcbiAgICAgIGRzdFtkc3RPZmYgKyAzXSA9IGEgKyBhbHBoYUZhYyAqICgyNTUgLSBhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gdmVydGljYWxDb252b2x2ZShwaXhlbHMsIHdlaWdodHNWZWN0b3IsIG9wYXF1ZSkge1xuICB2YXIgc2lkZSA9IHdlaWdodHNWZWN0b3IubGVuZ3RoO1xuICB2YXIgaGFsZlNpZGUgPSBNYXRoLmZsb29yKHNpZGUgLyAyKTtcblxuICB2YXIgc3JjID0gcGl4ZWxzLmRhdGE7XG4gIHZhciBzdyA9IHBpeGVscy53aWR0aDtcbiAgdmFyIHNoID0gcGl4ZWxzLmhlaWdodDtcblxuICB2YXIgdyA9IHN3O1xuICB2YXIgaCA9IHNoO1xuICB2YXIgb3V0cHV0ID0gKDAsIF9jcmVhdGVJbWFnZURhdGEuY3JlYXRlSW1hZ2VEYXRhKSh3LCBoKTtcbiAgdmFyIGRzdCA9IG91dHB1dC5kYXRhO1xuXG4gIHZhciBhbHBoYUZhYyA9IG9wYXF1ZSA/IDEgOiAwO1xuXG4gIGZvciAodmFyIHkgPSAwOyB5IDwgaDsgeSsrKSB7XG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyspIHtcbiAgICAgIHZhciBzeSA9IHk7XG4gICAgICB2YXIgc3ggPSB4O1xuICAgICAgdmFyIGRzdE9mZiA9ICh5ICogdyArIHgpICogNDtcbiAgICAgIHZhciByID0gMCxcbiAgICAgICAgICBnID0gMCxcbiAgICAgICAgICBiID0gMCxcbiAgICAgICAgICBhID0gMDtcbiAgICAgIGZvciAodmFyIGN5ID0gMDsgY3kgPCBzaWRlOyBjeSsrKSB7XG4gICAgICAgIHZhciBzY3kgPSBNYXRoLm1pbihzaCAtIDEsIE1hdGgubWF4KDAsIHN5ICsgY3kgLSBoYWxmU2lkZSkpO1xuICAgICAgICB2YXIgc2N4ID0gc3g7XG4gICAgICAgIHZhciBzcmNPZmYgPSAoc2N5ICogc3cgKyBzY3gpICogNDtcbiAgICAgICAgdmFyIHd0ID0gd2VpZ2h0c1ZlY3RvcltjeV07XG4gICAgICAgIHIgKz0gc3JjW3NyY09mZl0gKiB3dDtcbiAgICAgICAgZyArPSBzcmNbc3JjT2ZmICsgMV0gKiB3dDtcbiAgICAgICAgYiArPSBzcmNbc3JjT2ZmICsgMl0gKiB3dDtcbiAgICAgICAgYSArPSBzcmNbc3JjT2ZmICsgM10gKiB3dDtcbiAgICAgIH1cbiAgICAgIGRzdFtkc3RPZmZdID0gcjtcbiAgICAgIGRzdFtkc3RPZmYgKyAxXSA9IGc7XG4gICAgICBkc3RbZHN0T2ZmICsgMl0gPSBiO1xuICAgICAgZHN0W2RzdE9mZiArIDNdID0gYSArIGFscGhhRmFjICogKDI1NSAtIGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jcmVhdGVJbWFnZURhdGEgPSBjcmVhdGVJbWFnZURhdGE7XG52YXIgdG1wQ3R4ID0gbnVsbDtcblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgdG1wQ3R4ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKTtcbn0gZWxzZSBpZiAodHlwZW9mIHd4ICE9PSAndW5kZWZpbmVkJyAmJiB3eC5jcmVhdGVDYW52YXMpIHtcbiAgdG1wQ3R4ID0gd3guY3JlYXRlQ2FudmFzKCkuZ2V0Q29udGV4dCgnMmQnKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW1hZ2VEYXRhKHcsIGgpIHtcbiAgcmV0dXJuIHRtcEN0eC5jcmVhdGVJbWFnZURhdGEodywgaCk7XG59XG5cbi8qKiovIH0pLFxuLyogMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYnJpZ2h0bmVzcyA9IGJyaWdodG5lc3M7XG5mdW5jdGlvbiBicmlnaHRuZXNzKHBpeGVscywgYWRqdXN0bWVudCkge1xuICB2YXIgZGF0YSA9IHBpeGVscy5kYXRhO1xuICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDQpIHtcbiAgICBkYXRhW2ldICs9IGFkanVzdG1lbnQ7XG4gICAgZGF0YVtpICsgMV0gKz0gYWRqdXN0bWVudDtcbiAgICBkYXRhW2kgKyAyXSArPSBhZGp1c3RtZW50O1xuICB9XG4gIHJldHVybiBwaXhlbHM7XG59XG5cbi8qKiovIH0pLFxuLyogMzEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY29udHJhc3QgPSBjb250cmFzdDtcbmZ1bmN0aW9uIGNvbnRyYXN0KHBpeGVscywgY29udHJhc3QpIHtcbiAgdmFyIGRhdGEgPSBwaXhlbHMuZGF0YTtcbiAgdmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICB2YXIgZmFjdG9yID0gMjU5ICogKGNvbnRyYXN0ICsgMjU1KSAvICgyNTUgKiAoMjU5IC0gY29udHJhc3QpKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSA0KSB7XG4gICAgZGF0YVtpXSA9IGZhY3RvciAqIChkYXRhW2ldIC0gMTI4KSArIDEyODtcbiAgICBkYXRhW2kgKyAxXSA9IGZhY3RvciAqIChkYXRhW2kgKyAxXSAtIDEyOCkgKyAxMjg7XG4gICAgZGF0YVtpICsgMl0gPSBmYWN0b3IgKiAoZGF0YVtpICsgMl0gLSAxMjgpICsgMTI4O1xuICB9XG5cbiAgcmV0dXJuIHBpeGVscztcbn07XG5cbi8qKiovIH0pLFxuLyogMzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ3JheXNjYWxlID0gZ3JheXNjYWxlO1xuZnVuY3Rpb24gZ3JheXNjYWxlKHBpeGVscywgYWRqdXN0bWVudCkge1xuICB2YXIgZGF0YSA9IHBpeGVscy5kYXRhO1xuICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDQpIHtcbiAgICB2YXIgciA9IGRhdGFbaV07XG4gICAgdmFyIGcgPSBkYXRhW2kgKyAxXTtcbiAgICB2YXIgYiA9IGRhdGFbaSArIDJdO1xuXG4gICAgLy8gQ0lFIGx1bWluYW5jZSBmb3IgdGhlIFJHQlxuICAgIC8vIFRoZSBodW1hbiBleWUgaXMgYmFkIGF0IHNlZWluZyByZWQgYW5kIGJsdWUsIHNvIHdlIGRlLWVtcGhhc2l6ZSB0aGVtLlxuICAgIHZhciB2ID0gMC4yMTI2ICogciArIDAuNzE1MiAqIGcgKyAwLjA3MjIgKiBiO1xuICAgIGRhdGFbaV0gPSByICsgKHYgLSByKSAqIGFkanVzdG1lbnQ7XG4gICAgZGF0YVtpICsgMV0gPSBnICsgKHYgLSBnKSAqIGFkanVzdG1lbnQ7XG4gICAgZGF0YVtpICsgMl0gPSBiICsgKHYgLSBiKSAqIGFkanVzdG1lbnQ7XG4gIH1cbiAgcmV0dXJuIHBpeGVscztcbn07XG5cbi8qKiovIH0pLFxuLyogMzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc2VwaWEgPSBzZXBpYTtcbmZ1bmN0aW9uIHNlcGlhKHBpeGVscywgYWRqdXN0bWVudCkge1xuICB2YXIgZGF0YSA9IHBpeGVscy5kYXRhO1xuICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDQpIHtcbiAgICB2YXIgciA9IGRhdGFbaV07XG4gICAgdmFyIGcgPSBkYXRhW2kgKyAxXTtcbiAgICB2YXIgYiA9IGRhdGFbaSArIDJdO1xuXG4gICAgdmFyIHNyID0gciAqIDAuMzkzICsgZyAqIDAuNzY5ICsgYiAqIDAuMTg5O1xuICAgIHZhciBzZyA9IHIgKiAwLjM0OSArIGcgKiAwLjY4NiArIGIgKiAwLjE2ODtcbiAgICB2YXIgc2IgPSByICogMC4yNzIgKyBnICogMC41MzQgKyBiICogMC4xMzE7XG5cbiAgICBkYXRhW2ldID0gciArIChzciAtIHIpICogYWRqdXN0bWVudDtcbiAgICBkYXRhW2kgKyAxXSA9IGcgKyAoc2cgLSBnKSAqIGFkanVzdG1lbnQ7XG4gICAgZGF0YVtpICsgMl0gPSBiICsgKHNiIC0gYikgKiBhZGp1c3RtZW50O1xuICB9XG5cbiAgcmV0dXJuIHBpeGVscztcbn07XG5cbi8qKiovIH0pLFxuLyogMzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudGhyZXNob2xkID0gdGhyZXNob2xkO1xuZnVuY3Rpb24gdGhyZXNob2xkKHBpeGVscywgdGhyZXNob2xkKSB7XG4gIHZhciBkYXRhID0gcGl4ZWxzLmRhdGE7XG4gIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gNCkge1xuICAgIHZhciByID0gZGF0YVtpXTtcbiAgICB2YXIgZyA9IGRhdGFbaSArIDFdO1xuICAgIHZhciBiID0gZGF0YVtpICsgMl07XG4gICAgdmFyIHYgPSAwLjIxMjYgKiByICsgMC43MTUyICogZyArIDAuMDcyMiAqIGIgPj0gdGhyZXNob2xkID8gMjU1IDogMDtcbiAgICBkYXRhW2ldID0gZGF0YVtpICsgMV0gPSBkYXRhW2kgKyAyXSA9IHY7XG4gIH1cbiAgcmV0dXJuIHBpeGVscztcbn07XG5cbi8qKiovIH0pLFxuLyogMzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2FtbWEgPSBnYW1tYTtcbmZ1bmN0aW9uIGdhbW1hKHBpeGVscywgYWRqdXN0bWVudCkge1xuICB2YXIgZGF0YSA9IHBpeGVscy5kYXRhO1xuICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDQpIHtcbiAgICBkYXRhW2ldID0gTWF0aC5wb3coZGF0YVtpXSAvIDI1NSwgYWRqdXN0bWVudCkgKiAyNTU7XG4gICAgZGF0YVtpICsgMV0gPSBNYXRoLnBvdyhkYXRhW2kgKyAxXSAvIDI1NSwgYWRqdXN0bWVudCkgKiAyNTU7XG4gICAgZGF0YVtpICsgMl0gPSBNYXRoLnBvdyhkYXRhW2kgKyAyXSAvIDI1NSwgYWRqdXN0bWVudCkgKiAyNTU7XG4gIH1cbiAgcmV0dXJuIHBpeGVscztcbn07XG5cbi8qKiovIH0pLFxuLyogMzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY29sb3JpemUgPSBjb2xvcml6ZTtcbmZ1bmN0aW9uIGNvbG9yaXplKHBpeGVscywgb3B0aW9uKSB7XG4gIHZhciBkYXRhID0gcGl4ZWxzLmRhdGE7XG4gIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgdmFyIGhleCA9IG9wdGlvbi5jb2xvci5jaGFyQXQoMCkgPT09ICcjJyA/IG9wdGlvbi5jb2xvci5zdWJzdHIoMSkgOiBvcHRpb24uY29sb3I7XG4gIHZhciBjb2xvclJHQiA9IHtcbiAgICByOiBwYXJzZUludChoZXguc3Vic3RyKDAsIDIpLCAxNiksXG4gICAgZzogcGFyc2VJbnQoaGV4LnN1YnN0cigyLCAyKSwgMTYpLFxuICAgIGI6IHBhcnNlSW50KGhleC5zdWJzdHIoNCwgMiksIDE2KVxuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDQpIHtcbiAgICBkYXRhW2ldIC09IChkYXRhW2ldIC0gY29sb3JSR0IucikgKiBvcHRpb24uYW1vdW50O1xuICAgIGRhdGFbaSArIDFdIC09IChkYXRhW2kgKyAxXSAtIGNvbG9yUkdCLmcpICogb3B0aW9uLmFtb3VudDtcbiAgICBkYXRhW2kgKyAyXSAtPSAoZGF0YVtpICsgMl0gLSBjb2xvclJHQi5iKSAqIG9wdGlvbi5hbW91bnQ7XG4gIH1cblxuICByZXR1cm4gcGl4ZWxzO1xufTtcblxuLyoqKi8gfSksXG4vKiAzNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dyb3VwID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9ncm91cDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ncm91cCk7XG5cbnZhciBfZ3JhcGhpY3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2dyYXBoaWNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dyYXBoaWNzKTtcblxudmFyIF9yZW5kZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgX3JlbmRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZW5kZXIpO1xuXG52YXIgX2V2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIF9ldmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudCk7XG5cbnZhciBfc3ByaXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIF9zcHJpdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ByaXRlKTtcblxudmFyIF9iaXRtYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX2JpdG1hcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iaXRtYXApO1xuXG52YXIgX3RleHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX3RleHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGV4dCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEhpdFJlbmRlciA9IGZ1bmN0aW9uIChfUmVuZGVyKSB7XG4gIF9pbmhlcml0cyhIaXRSZW5kZXIsIF9SZW5kZXIpO1xuXG4gIGZ1bmN0aW9uIEhpdFJlbmRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGl0UmVuZGVyKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChIaXRSZW5kZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihIaXRSZW5kZXIpKS5jYWxsKHRoaXMpKTtcblxuICAgIGlmICh0eXBlb2Ygd3ggIT09ICd1bmRlZmluZWQnICYmIHd4LmNyZWF0ZUNhbnZhcykge1xuICAgICAgX3RoaXMuY2FudmFzID0gd3guY3JlYXRlQ2FudmFzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIH1cblxuICAgIF90aGlzLmNhbnZhcy53aWR0aCA9IDE7XG4gICAgX3RoaXMuY2FudmFzLmhlaWdodCA9IDE7XG4gICAgX3RoaXMuY3R4ID0gX3RoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAvLyBkZWJ1ZyBldmVudFxuICAgIC8vIHRoaXMuY2FudmFzLndpZHRoID0gNDQxXG4gICAgLy8gdGhpcy5jYW52YXMuaGVpZ2h0ID0gNDQxXG4gICAgLy8gdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgLy8gZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcylcblxuICAgIF90aGlzLmRpc2FibGVFdmVudHMgPSBbJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdtb3VzZW1vdmUnLCAndG91Y2htb3ZlJ107XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEhpdFJlbmRlciwgW3tcbiAgICBrZXk6ICdjbGVhcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoaXRBQUJCJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGl0QUFCQihvLCBldnQpIHtcbiAgICAgIHZhciBsaXN0ID0gby5jaGlsZHJlbi5zbGljZSgwKSxcbiAgICAgICAgICBsID0gbGlzdC5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gbCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGxpc3RbaV07XG4gICAgICAgIC8vIGlmICghdGhpcy5pc2JpbmRpbmdFdmVudChjaGlsZCkpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5faGl0QUFCQihjaGlsZCwgZXZ0KTtcbiAgICAgICAgaWYgKHRhcmdldCkgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfaGl0QUFCQicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oaXRBQUJCKG8sIGV2dCkge1xuICAgICAgaWYgKG8uaWdub3JlSGl0IHx8ICFvLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChvIGluc3RhbmNlb2YgX2dyb3VwMi5kZWZhdWx0KSB7XG4gICAgICAgIHZhciBsaXN0ID0gby5jaGlsZHJlbi5zbGljZSgwKSxcbiAgICAgICAgICAgIGwgPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IGwgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IGxpc3RbaV07XG4gICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX2hpdEFBQkIoY2hpbGQsIGV2dCk7XG4gICAgICAgICAgaWYgKHRhcmdldCkgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG8uQUFCQiAmJiB0aGlzLmNoZWNrUG9pbnRJbkFBQkIoZXZ0LnN0YWdlWCwgZXZ0LnN0YWdlWSwgby5BQUJCKSkge1xuICAgICAgICAgIC8vIHRoaXMuX2J1YmJsZUV2ZW50KG8sIHR5cGUsIGV2dCk7XG4gICAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudChvLCBldnQpO1xuICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2hlY2tQb2ludEluQUFCQicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrUG9pbnRJbkFBQkIoeCwgeSwgQUFCQikge1xuICAgICAgdmFyIG1pblggPSBBQUJCWzBdO1xuICAgICAgaWYgKHggPCBtaW5YKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgbWluWSA9IEFBQkJbMV07XG4gICAgICBpZiAoeSA8IG1pblkpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBtYXhYID0gbWluWCArIEFBQkJbMl07XG4gICAgICBpZiAoeCA+IG1heFgpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBtYXhZID0gbWluWSArIEFBQkJbM107XG4gICAgICBpZiAoeSA+IG1heFkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2hpdFBpeGVsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGl0UGl4ZWwobywgZXZ0KSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIDIsIDIpO1xuICAgICAgdmFyIG10eCA9IG8uX2hpdE1hdHJpeDtcbiAgICAgIHZhciBsaXN0ID0gby5jaGlsZHJlbi5zbGljZSgwKSxcbiAgICAgICAgICBsID0gbGlzdC5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gbCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGxpc3RbaV07XG4gICAgICAgIG10eC5pbml0aWFsaXplKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICBtdHguYXBwZW5kVHJhbnNmb3JtKG8ueCAtIGV2dC5zdGFnZVgsIG8ueSAtIGV2dC5zdGFnZVksIG8uc2NhbGVYLCBvLnNjYWxlWSwgby5yb3RhdGlvbiwgby5za2V3WCwgby5za2V3WSwgby5vcmlnaW5YLCBvLm9yaWdpblkpO1xuICAgICAgICAvLyBpZiAoIXRoaXMuY2hlY2tCb3VuZEV2ZW50KGNoaWxkKSkgY29udGludWVcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX2hpdFBpeGVsKGNoaWxkLCBldnQsIG10eCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIGlmICh0YXJnZXQpIHJldHVybiB0YXJnZXQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2hpdFBpeGVsJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hpdFBpeGVsKG8sIGV2dCwgbXR4KSB7XG4gICAgICBpZiAoby5pZ25vcmVIaXQgfHwgIW8uaXNWaXNpYmxlKCkpIHJldHVybjtcbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgIGlmIChtdHggJiYgIW8uZml4ZWQpIHtcbiAgICAgICAgby5faGl0TWF0cml4LmluaXRpYWxpemUobXR4LmEsIG10eC5iLCBtdHguYywgbXR4LmQsIG10eC50eCwgbXR4LnR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG8uX2hpdE1hdHJpeC5pbml0aWFsaXplKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgfVxuICAgICAgbXR4ID0gby5faGl0TWF0cml4O1xuICAgICAgbXR4LmFwcGVuZFRyYW5zZm9ybShvLngsIG8ueSwgby5zY2FsZVgsIG8uc2NhbGVZLCBvLnJvdGF0aW9uLCBvLnNrZXdYLCBvLnNrZXdZLCBvLm9yaWdpblgsIG8ub3JpZ2luWSk7XG5cbiAgICAgIHZhciBvY2cgPSBvLmNsaXBHcmFwaGljcztcbiAgICAgIGlmIChvY2cpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBvY2cuX21hdHJpeC5jb3B5KG10eCk7XG4gICAgICAgIG9jZy5fbWF0cml4LmFwcGVuZFRyYW5zZm9ybShvY2cueCwgb2NnLnksIG9jZy5zY2FsZVgsIG9jZy5zY2FsZVksIG9jZy5yb3RhdGlvbiwgb2NnLnNrZXdYLCBvY2cuc2tld1ksIG9jZy5vcmlnaW5YLCBvY2cub3JpZ2luWSk7XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0ob2NnLl9tYXRyaXguYSwgb2NnLl9tYXRyaXguYiwgb2NnLl9tYXRyaXguYywgb2NnLl9tYXRyaXguZCwgb2NnLl9tYXRyaXgudHgsIG9jZy5fbWF0cml4LnR5KTtcbiAgICAgICAgb2NnLnJlbmRlcihjdHgpO1xuICAgICAgICBjdHguY2xpcChvLmNsaXBSdWxlTm9uemVybyA/ICdub256ZXJvJyA6ICdldmVub2RkJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBvYWNnID0gby5hYnNDbGlwR3JhcGhpY3M7XG4gICAgICBpZiAob2FjZykge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIG9hY2cuX21hdHJpeC5pbml0aWFsaXplKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICBvYWNnLl9tYXRyaXguYXBwZW5kVHJhbnNmb3JtKG9hY2cueCwgb2FjZy55LCBvYWNnLnNjYWxlWCwgb2FjZy5zY2FsZVksIG9hY2cucm90YXRpb24sIG9hY2cuc2tld1gsIG9hY2cuc2tld1ksIG9hY2cub3JpZ2luWCwgb2FjZy5vcmlnaW5ZKTtcbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybShvYWNnLl9tYXRyaXguYSwgb2FjZy5fbWF0cml4LmIsIG9hY2cuX21hdHJpeC5jLCBvYWNnLl9tYXRyaXguZCwgb2FjZy5fbWF0cml4LnR4LCBvYWNnLl9tYXRyaXgudHkpO1xuICAgICAgICBvYWNnLnJlbmRlcihjdHgpO1xuICAgICAgICBjdHguY2xpcChvLmFic0NsaXBSdWxlTm9uemVybyA/ICdub256ZXJvJyA6ICdldmVub2RkJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvLmNhY2hlQ2FudmFzKSB7XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0obXR4LmEsIG10eC5iLCBtdHguYywgbXR4LmQsIG10eC50eCwgbXR4LnR5KTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShvLmNhY2hlQ2FudmFzLCBvLl9jYWNoZURhdGEueCwgby5fY2FjaGVEYXRhLnkpO1xuICAgICAgfSBlbHNlIGlmIChvIGluc3RhbmNlb2YgX2dyb3VwMi5kZWZhdWx0KSB7XG4gICAgICAgIHZhciBsaXN0ID0gby5jaGlsZHJlbi5zbGljZSgwKSxcbiAgICAgICAgICAgIGwgPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IGwgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX2hpdFBpeGVsKGxpc3RbaV0sIGV2dCwgbXR4KTtcbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgIGlmICh0YXJnZXQpIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0obXR4LmEsIG10eC5iLCBtdHguYywgbXR4LmQsIG10eC50eCwgbXR4LnR5KTtcbiAgICAgICAgaWYgKG8gaW5zdGFuY2VvZiBfZ3JhcGhpY3MyLmRlZmF1bHQpIHtcbiAgICAgICAgICB0aGlzLnNldENvbXBsZXhQcm9wcyhjdHgsIG8pO1xuXG4gICAgICAgICAgby5yZW5kZXIoY3R4KTtcbiAgICAgICAgfSBlbHNlIGlmIChvIGluc3RhbmNlb2YgX3Nwcml0ZTIuZGVmYXVsdCAmJiBvLnJlY3QpIHtcbiAgICAgICAgICB0aGlzLnNldENvbXBsZXhQcm9wcyhjdHgsIG8pO1xuXG4gICAgICAgICAgby51cGRhdGVGcmFtZSgpO1xuICAgICAgICAgIHZhciByZWN0ID0gby5yZWN0O1xuICAgICAgICAgIGN0eC5kcmF3SW1hZ2Uoby5pbWcsIHJlY3RbMF0sIHJlY3RbMV0sIHJlY3RbMl0sIHJlY3RbM10sIDAsIDAsIHJlY3RbMl0sIHJlY3RbM10pO1xuICAgICAgICB9IGVsc2UgaWYgKG8gaW5zdGFuY2VvZiBfYml0bWFwMi5kZWZhdWx0ICYmIG8ucmVjdCkge1xuICAgICAgICAgIHRoaXMuc2V0Q29tcGxleFByb3BzKGN0eCwgbyk7XG5cbiAgICAgICAgICB2YXIgYlJlY3QgPSBvLnJlY3Q7XG4gICAgICAgICAgY3R4LmRyYXdJbWFnZShvLmltZywgYlJlY3RbMF0sIGJSZWN0WzFdLCBiUmVjdFsyXSwgYlJlY3RbM10sIDAsIDAsIGJSZWN0WzJdLCBiUmVjdFszXSk7XG4gICAgICAgIH0gZWxzZSBpZiAobyBpbnN0YW5jZW9mIF90ZXh0Mi5kZWZhdWx0KSB7XG4gICAgICAgICAgdGhpcy5zZXRDb21wbGV4UHJvcHMoY3R4LCBvKTtcblxuICAgICAgICAgIGN0eC5mb250ID0gby5mb250O1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBvLmNvbG9yO1xuICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBvLnRleHRBbGlnbjtcbiAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gby5iYXNlbGluZTtcbiAgICAgICAgICBjdHguZmlsbFRleHQoby50ZXh0LCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhWzNdID4gMSkge1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KG8sIGV2dCk7XG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldENvbXBsZXhQcm9wcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENvbXBsZXhQcm9wcyhjdHgsIG8pIHtcbiAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBvLmNvbXBsZXhDb21wb3NpdGVPcGVyYXRpb247XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvLmNvbXBsZXhBbHBoYTtcbiAgICAgIC8vIFRoZSBzaGFkb3cgZG9lcyBub3QgdHJpZ2dlciB0aGUgZXZlbnQsIHNvIHJlbW92ZSBpdFxuICAgICAgLy8gaWYoby5jb21wbGV4U2hhZG93KXtcbiAgICAgIC8vICAgY3R4LnNoYWRvd0NvbG9yID0gby5jb21wbGV4U2hhZG93LmNvbG9yXG4gICAgICAvLyAgIGN0eC5zaGFkb3dPZmZzZXRYID0gby5jb21wbGV4U2hhZG93Lm9mZnNldFhcbiAgICAgIC8vICAgY3R4LnNoYWRvd09mZnNldFkgPSBvLmNvbXBsZXhTaGFkb3cub2Zmc2V0WVxuICAgICAgLy8gICBjdHguc2hhZG93Qmx1ciA9IG8uY29tcGxleFNoYWRvdy5ibHVyXG4gICAgICAvLyB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2Rpc3BhdGNoRXZlbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGlzcGF0Y2hFdmVudChvYmosIGV2dCkge1xuICAgICAgaWYgKHRoaXMuZGlzYWJsZUV2ZW50cy5pbmRleE9mKGV2dC50eXBlKSAhPT0gLTEpIHJldHVybjtcbiAgICAgIHZhciBtb2NrRXZ0ID0gbmV3IF9ldmVudDIuZGVmYXVsdCgpO1xuICAgICAgbW9ja0V2dC5zdGFnZVggPSBldnQuc3RhZ2VYO1xuICAgICAgbW9ja0V2dC5zdGFnZVkgPSBldnQuc3RhZ2VZO1xuICAgICAgbW9ja0V2dC5wdXJlRXZlbnQgPSBldnQ7XG4gICAgICBtb2NrRXZ0LnR5cGUgPSBldnQudHlwZTtcbiAgICAgIG9iai5kaXNwYXRjaEV2ZW50KG1vY2tFdnQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIaXRSZW5kZXI7XG59KF9yZW5kZXIyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBIaXRSZW5kZXI7XG5cbi8qKiovIH0pLFxuLyogMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9ncmFwaGljcyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfZ3JhcGhpY3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ3JhcGhpY3MpO1xuXG52YXIgX3JlbmRlciA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbnZhciBfcmVuZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlbmRlcik7XG5cbnZhciBfZXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgX2V2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V2ZW50KTtcblxudmFyIF9zcHJpdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgX3Nwcml0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zcHJpdGUpO1xuXG52YXIgX2JpdG1hcCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfYml0bWFwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JpdG1hcCk7XG5cbnZhciBfdGV4dCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfdGV4dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90ZXh0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgV3hIaXRSZW5kZXIgPSBmdW5jdGlvbiAoX1JlbmRlcikge1xuICBfaW5oZXJpdHMoV3hIaXRSZW5kZXIsIF9SZW5kZXIpO1xuXG4gIGZ1bmN0aW9uIFd4SGl0UmVuZGVyKGN0eCwgY29tcG9uZW50LCBjYW52YXNJZCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXeEhpdFJlbmRlcik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoV3hIaXRSZW5kZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihXeEhpdFJlbmRlcikpLmNhbGwodGhpcykpO1xuXG4gICAgX3RoaXMuY3R4ID0gY3R4O1xuICAgIF90aGlzLl9pc1dlYXBwID0gdHJ1ZTtcbiAgICBfdGhpcy5fY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgIF90aGlzLl9oaXRDYW52YXNJZCA9IGNhbnZhc0lkICsgJ0hpdCc7XG5cbiAgICBfdGhpcy5kaXNhYmxlRXZlbnRzID0gWydtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnbW91c2Vtb3ZlJywgJ3RvdWNobW92ZSddO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhXeEhpdFJlbmRlciwgW3tcbiAgICBrZXk6ICdjbGVhcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIDIsIDIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2hpdEFBQkInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaXRBQUJCKGxpc3QsIGV2dCwgY2IpIHtcbiAgICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbyA9IGxpc3RbaV07XG5cbiAgICAgICAgaWYgKG8uQUFCQiAmJiB0aGlzLmNoZWNrUG9pbnRJbkFBQkIoZXZ0LnN0YWdlWCwgZXZ0LnN0YWdlWSwgby5BQUJCKSkge1xuICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnQobywgZXZ0KTtcbiAgICAgICAgICBjYihvKTtcbiAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NoZWNrUG9pbnRJbkFBQkInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1BvaW50SW5BQUJCKHgsIHksIEFBQkIpIHtcbiAgICAgIHZhciBtaW5YID0gQUFCQlswXTtcbiAgICAgIGlmICh4IDwgbWluWCkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIG1pblkgPSBBQUJCWzFdO1xuICAgICAgaWYgKHkgPCBtaW5ZKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgbWF4WCA9IG1pblggKyBBQUJCWzJdO1xuICAgICAgaWYgKHggPiBtYXhYKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgbWF4WSA9IG1pblkgKyBBQUJCWzNdO1xuICAgICAgaWYgKHkgPiBtYXhZKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaXQobGlzdCwgZXZ0LCBjYiwgY3VycmVudCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgIHZhciBvYmogPSBsaXN0W2N1cnJlbnRdO1xuICAgICAgdmFyIG10eCA9IG9iai5faGl0TWF0cml4LmluaXRpYWxpemUoMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgbXR4LmFwcGVuZFRyYW5zZm9ybShvYmoueCAtIGV2dC5zdGFnZVgsIG9iai55IC0gZXZ0LnN0YWdlWSwgb2JqLnNjYWxlWCwgb2JqLnNjYWxlWSwgb2JqLnJvdGF0aW9uLCBvYmouc2tld1gsIG9iai5za2V3WSwgb2JqLm9yaWdpblgsIG9iai5vcmlnaW5ZKTtcbiAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBvYmouY29tcGxleENvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9iai5jb21wbGV4QWxwaGE7XG4gICAgICBjdHguc2V0VHJhbnNmb3JtKG10eC5hLCBtdHguYiwgbXR4LmMsIG10eC5kLCBtdHgudHgsIG10eC50eSk7XG4gICAgICBpZiAob2JqIGluc3RhbmNlb2YgX2dyYXBoaWNzMi5kZWZhdWx0KSB7XG4gICAgICAgIG9iai5yZW5kZXIoY3R4KTtcbiAgICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgX3Nwcml0ZTIuZGVmYXVsdCAmJiBvYmoucmVjdCkge1xuICAgICAgICBvYmoudXBkYXRlRnJhbWUoKTtcbiAgICAgICAgdmFyIHJlY3QgPSBvYmoucmVjdDtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShvYmouaW1nLCByZWN0WzBdLCByZWN0WzFdLCByZWN0WzJdLCByZWN0WzNdLCAwLCAwLCByZWN0WzJdLCByZWN0WzNdKTtcbiAgICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgX2JpdG1hcDIuZGVmYXVsdCAmJiBvYmoucmVjdCkge1xuICAgICAgICB2YXIgYlJlY3QgPSBvYmoucmVjdDtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShvYmouaW1nLCBiUmVjdFswXSwgYlJlY3RbMV0sIGJSZWN0WzJdLCBiUmVjdFszXSwgMCwgMCwgYlJlY3RbMl0sIGJSZWN0WzNdKTtcbiAgICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgX3RleHQyLmRlZmF1bHQpIHtcbiAgICAgICAgY3R4LmZvbnQgPSBvYmouZm9udDtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9iai5jb2xvcjtcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IG9iai50ZXh0QWxpZ247XG4gICAgICAgIGN0eC5maWxsVGV4dChvYmoudGV4dCwgMCwgMCk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgY3VycmVudC0tO1xuICAgICAgY3R4LmRyYXcoZmFsc2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd3guY2FudmFzR2V0SW1hZ2VEYXRhKHtcbiAgICAgICAgICBjYW52YXNJZDogX3RoaXMyLl9oaXRDYW52YXNJZCxcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIHN1Y2Nlc3MocmVzKSB7XG4gICAgICAgICAgICBpZiAocmVzLmRhdGFbM10gPiAxKSB7XG4gICAgICAgICAgICAgIF90aGlzMi5fZGlzcGF0Y2hFdmVudChvYmosIGV2dCk7XG4gICAgICAgICAgICAgIGNiKG9iaik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY3VycmVudCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMyLmhpdChsaXN0LCBldnQsIGNiLCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX3RoaXMyLl9jb21wb25lbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2Rpc3BhdGNoRXZlbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGlzcGF0Y2hFdmVudChvYmosIGV2dCkge1xuICAgICAgaWYgKHRoaXMuZGlzYWJsZUV2ZW50cy5pbmRleE9mKGV2dC50eXBlKSAhPT0gLTEpIHJldHVybjtcbiAgICAgIHZhciBtb2NrRXZ0ID0gbmV3IF9ldmVudDIuZGVmYXVsdCgpO1xuICAgICAgbW9ja0V2dC5zdGFnZVggPSBldnQuc3RhZ2VYO1xuICAgICAgbW9ja0V2dC5zdGFnZVkgPSBldnQuc3RhZ2VZO1xuICAgICAgbW9ja0V2dC5wdXJlRXZlbnQgPSBldnQ7XG4gICAgICBtb2NrRXZ0LnR5cGUgPSBldnQudHlwZTtcbiAgICAgIG9iai5kaXNwYXRjaEV2ZW50KG1vY2tFdnQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBXeEhpdFJlbmRlcjtcbn0oX3JlbmRlcjIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFd4SGl0UmVuZGVyO1xuXG4vKioqLyB9KSxcbi8qIDM5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfc2hhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3NoYXBlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoYXBlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQXJyb3dQYXRoID0gZnVuY3Rpb24gKF9TaGFwZSkge1xuICBfaW5oZXJpdHMoQXJyb3dQYXRoLCBfU2hhcGUpO1xuXG4gIGZ1bmN0aW9uIEFycm93UGF0aChwYXRoLCBvcHRpb24pIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXJyb3dQYXRoKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChBcnJvd1BhdGguX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihBcnJvd1BhdGgpKS5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzLnBhdGggPSBwYXRoO1xuICAgIF90aGlzLm9wdGlvbiA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgc3Ryb2tlU3R5bGU6ICdibGFjaycsXG4gICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICBoZWFkU2l6ZTogMTBcbiAgICB9LCBvcHRpb24pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBcnJvd1BhdGgsIFt7XG4gICAga2V5OiAnZHJhdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XG4gICAgICB2YXIgbGVuID0gcGF0aC5sZW5ndGg7XG4gICAgICBpZiAobGVuID09PSAyKSB7XG4gICAgICAgIHRoaXMuZHJhd0Fycm93KHBhdGhbMF0ueCwgcGF0aFswXS55LCBwYXRoWzFdLngsIHBhdGhbMV0ueSwgMzApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tb3ZlVG8ocGF0aFswXS54LCBwYXRoWzBdLnkpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbiAtIDE7IGkrKykge1xuICAgICAgICAgIHRoaXMubGluZVRvKHBhdGhbaV0ueCwgcGF0aFtpXS55KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYXdBcnJvdyhwYXRoW2xlbiAtIDJdLngsIHBhdGhbbGVuIC0gMl0ueSwgcGF0aFtsZW4gLSAxXS54LCBwYXRoW2xlbiAtIDFdLnksIDMwKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdHJva2UoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3QXJyb3cnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3QXJyb3coZnJvbVgsIGZyb21ZLCB0b1gsIHRvWSwgdGhldGEpIHtcbiAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoZnJvbVkgLSB0b1ksIGZyb21YIC0gdG9YKSAqIDE4MCAvIE1hdGguUEksXG4gICAgICAgICAgYW5nbGUxID0gKGFuZ2xlICsgdGhldGEpICogTWF0aC5QSSAvIDE4MCxcbiAgICAgICAgICBhbmdsZTIgPSAoYW5nbGUgLSB0aGV0YSkgKiBNYXRoLlBJIC8gMTgwLFxuICAgICAgICAgIGhzID0gdGhpcy5vcHRpb24uaGVhZFNpemUsXG4gICAgICAgICAgdG9wWCA9IGhzICogTWF0aC5jb3MoYW5nbGUxKSxcbiAgICAgICAgICB0b3BZID0gaHMgKiBNYXRoLnNpbihhbmdsZTEpLFxuICAgICAgICAgIGJvdFggPSBocyAqIE1hdGguY29zKGFuZ2xlMiksXG4gICAgICAgICAgYm90WSA9IGhzICogTWF0aC5zaW4oYW5nbGUyKTtcblxuICAgICAgdmFyIGFycm93WCA9IGZyb21YIC0gdG9wWCxcbiAgICAgICAgICBhcnJvd1kgPSBmcm9tWSAtIHRvcFk7XG5cbiAgICAgIHRoaXMubW92ZVRvKGFycm93WCwgYXJyb3dZKTtcbiAgICAgIHRoaXMubW92ZVRvKGZyb21YLCBmcm9tWSk7XG4gICAgICB0aGlzLmxpbmVUbyh0b1gsIHRvWSk7XG4gICAgICBhcnJvd1ggPSB0b1ggKyB0b3BYO1xuICAgICAgYXJyb3dZID0gdG9ZICsgdG9wWTtcbiAgICAgIHRoaXMubW92ZVRvKGFycm93WCwgYXJyb3dZKTtcbiAgICAgIHRoaXMubGluZVRvKHRvWCwgdG9ZKTtcbiAgICAgIGFycm93WCA9IHRvWCArIGJvdFg7XG4gICAgICBhcnJvd1kgPSB0b1kgKyBib3RZO1xuICAgICAgdGhpcy5saW5lVG8oYXJyb3dYLCBhcnJvd1kpO1xuICAgICAgdGhpcy5zdHJva2VTdHlsZSh0aGlzLm9wdGlvbi5zdHJva2VTdHlsZSk7XG4gICAgICB0aGlzLmxpbmVXaWR0aCh0aGlzLm9wdGlvbi5saW5lV2lkdGgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBcnJvd1BhdGg7XG59KF9zaGFwZTIuZGVmYXVsdCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEFycm93UGF0aDtcblxuLyoqKi8gfSksXG4vKiA0MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3NoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9zaGFwZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zaGFwZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEVsbGlwc2UgPSBmdW5jdGlvbiAoX1NoYXBlKSB7XG4gIF9pbmhlcml0cyhFbGxpcHNlLCBfU2hhcGUpO1xuXG4gIGZ1bmN0aW9uIEVsbGlwc2Uod2lkdGgsIGhlaWdodCwgb3B0aW9uKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVsbGlwc2UpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEVsbGlwc2UuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihFbGxpcHNlKSkuY2FsbCh0aGlzKSk7XG5cbiAgICBfdGhpcy5vcHRpb24gPSBvcHRpb24gfHwge307XG4gICAgX3RoaXMud2lkdGggPSB3aWR0aDtcbiAgICBfdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEVsbGlwc2UsIFt7XG4gICAga2V5OiAnZHJhdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAgICB2YXIgdyA9IHRoaXMud2lkdGg7XG4gICAgICB2YXIgaCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgdmFyIGsgPSAwLjU1MjI4NDg7XG4gICAgICB2YXIgb3ggPSB3IC8gMiAqIGs7XG4gICAgICB2YXIgb3kgPSBoIC8gMiAqIGs7XG4gICAgICB2YXIgeGUgPSB3O1xuICAgICAgdmFyIHllID0gaDtcbiAgICAgIHZhciB4bSA9IHcgLyAyO1xuICAgICAgdmFyIHltID0gaCAvIDI7XG5cbiAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLm1vdmVUbygwLCB5bSk7XG4gICAgICB0aGlzLmJlemllckN1cnZlVG8oMCwgeW0gLSBveSwgeG0gLSBveCwgMCwgeG0sIDApO1xuICAgICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHhtICsgb3gsIDAsIHhlLCB5bSAtIG95LCB4ZSwgeW0pO1xuICAgICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHhlLCB5bSArIG95LCB4bSArIG94LCB5ZSwgeG0sIHllKTtcbiAgICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4bSAtIG94LCB5ZSwgMCwgeW0gKyBveSwgMCwgeW0pO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb24uc3Ryb2tlU3R5bGUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uLmxpbmVXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5saW5lV2lkdGgodGhpcy5vcHRpb24ubGluZVdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0cm9rZVN0eWxlKHRoaXMub3B0aW9uLnN0cm9rZVN0eWxlKTtcbiAgICAgICAgdGhpcy5zdHJva2UoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9uLmZpbGxTdHlsZSkge1xuICAgICAgICB0aGlzLmZpbGxTdHlsZSh0aGlzLm9wdGlvbi5maWxsU3R5bGUpO1xuICAgICAgICB0aGlzLmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRWxsaXBzZTtcbn0oX3NoYXBlMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRWxsaXBzZTtcblxuLyoqKi8gfSksXG4vKiA0MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3BhdGhQYXJzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcblxudmFyIF9wYXRoUGFyc2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhdGhQYXJzZXIpO1xuXG52YXIgX3NoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9zaGFwZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zaGFwZSk7XG5cbnZhciBfYXJjVG9CZXppZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcblxudmFyIF9hcmNUb0JlemllcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hcmNUb0Jlemllcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFBhdGggPSBmdW5jdGlvbiAoX1NoYXBlKSB7XG4gIF9pbmhlcml0cyhQYXRoLCBfU2hhcGUpO1xuXG4gIGZ1bmN0aW9uIFBhdGgoZCwgb3B0aW9uKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhdGgpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFBhdGguX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihQYXRoKSkuY2FsbCh0aGlzKSk7XG5cbiAgICBfdGhpcy5kID0gZDtcblxuICAgIG9wdGlvbiA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbGluZVdpZHRoOiAxXG4gICAgfSwgb3B0aW9uKTtcbiAgICBfdGhpcy5vcHRpb24gPSBvcHRpb247XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBhdGgsIFt7XG4gICAga2V5OiAnZHJhdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGNtZHMgPSAoMCwgX3BhdGhQYXJzZXIyLmRlZmF1bHQpKHRoaXMuZCk7XG5cbiAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy96aC1DTi9kb2NzL1dlYi9TVkcvVHV0b3JpYWwvUGF0aHNcbiAgICAgIC8vIE0gPSBtb3ZldG9cbiAgICAgIC8vIEwgPSBsaW5ldG9cbiAgICAgIC8vIEggPSBob3Jpem9udGFsIGxpbmV0b1xuICAgICAgLy8gViA9IHZlcnRpY2FsIGxpbmV0b1xuICAgICAgLy8gQyA9IGN1cnZldG9cbiAgICAgIC8vIFMgPSBzbW9vdGggY3VydmV0b1xuICAgICAgLy8gUSA9IHF1YWRyYXRpYyBCZWx6aWVyIGN1cnZlXG4gICAgICAvLyBUID0gc21vb3RoIHF1YWRyYXRpYyBCZWx6aWVyIGN1cnZldG9cbiAgICAgIC8vIEEgPSBlbGxpcHRpY2FsIEFyYyAg5pqC5pe25pyq5a6e546w77yM55So6LSd5aGe5bCU5ouf5ZCI5qSt5ZyGXG4gICAgICAvLyBaID0gY2xvc2VwYXRoXG4gICAgICAvLyDku6XkuIrmiYDmnInlkb3ku6TlnYflhYHorrjlsI/lhpnlrZfmr43jgILlpKflhpnooajnpLrnu53lr7nlrprkvY3vvIzlsI/lhpnooajnpLrnm7jlr7nlrprkvY0o5LuO5LiK5LiA5Liq54K55byA5aeLKeOAglxuICAgICAgdmFyIHByZVggPSB2b2lkIDAsXG4gICAgICAgICAgcHJlWSA9IHZvaWQgMCxcbiAgICAgICAgICBjdXJ2ZXMgPSB2b2lkIDAsXG4gICAgICAgICAgbGFzdEN1cnZlID0gdm9pZCAwO1xuXG4gICAgICAvLyDlj4LogIPmiJHnmoQgcGFzaXRpb24gaHR0cHM6Ly9naXRodWIuY29tL0FsbG95VGVhbS9wYXNpdGlvbi9ibG9iL21hc3Rlci9zcmMvaW5kZXguanNcbiAgICAgIGZvciAodmFyIGogPSAwLCBjbWRMZW4gPSBjbWRzLmxlbmd0aDsgaiA8IGNtZExlbjsgaisrKSB7XG4gICAgICAgIHZhciBpdGVtID0gY21kc1tqXTtcbiAgICAgICAgdmFyIGFjdGlvbiA9IGl0ZW1bMF07XG4gICAgICAgIHZhciBwcmVJdGVtID0gY21kc1tqIC0gMV07XG5cbiAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgIHByZVggPSBpdGVtWzFdO1xuICAgICAgICAgICAgcHJlWSA9IGl0ZW1bMl07XG4gICAgICAgICAgICB0aGlzLm1vdmVUbyhwcmVYLCBwcmVZKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgcHJlWCA9IGl0ZW1bMV07XG4gICAgICAgICAgICBwcmVZID0gaXRlbVsyXTtcbiAgICAgICAgICAgIHRoaXMubGluZVRvKHByZVgsIHByZVkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICBwcmVYID0gaXRlbVsxXTtcbiAgICAgICAgICAgIHRoaXMubGluZVRvKHByZVgsIHByZVkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgICBwcmVZID0gaXRlbVsxXTtcbiAgICAgICAgICAgIHRoaXMubGluZVRvKHByZVgsIHByZVkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICBwcmVYID0gaXRlbVs1XTtcbiAgICAgICAgICAgIHByZVkgPSBpdGVtWzZdO1xuICAgICAgICAgICAgdGhpcy5iZXppZXJDdXJ2ZVRvKGl0ZW1bMV0sIGl0ZW1bMl0sIGl0ZW1bM10sIGl0ZW1bNF0sIHByZVgsIHByZVkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnUyc6XG5cbiAgICAgICAgICAgIGlmIChwcmVJdGVtWzBdID09PSAnQycgfHwgcHJlSXRlbVswXSA9PT0gJ2MnKSB7XG4gICAgICAgICAgICAgIHRoaXMuYmV6aWVyQ3VydmVUbyhwcmVYICsgcHJlSXRlbVs1XSAtIHByZUl0ZW1bM10sIHByZVkgKyBwcmVJdGVtWzZdIC0gcHJlSXRlbVs0XSwgaXRlbVsxXSwgaXRlbVsyXSwgaXRlbVszXSwgaXRlbVs0XSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZUl0ZW1bMF0gPT09ICdTJyB8fCBwcmVJdGVtWzBdID09PSAncycpIHtcbiAgICAgICAgICAgICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHByZVggKyBwcmVJdGVtWzNdIC0gcHJlSXRlbVsxXSwgcHJlWSArIHByZUl0ZW1bNF0gLSBwcmVJdGVtWzJdLCBpdGVtWzFdLCBpdGVtWzJdLCBpdGVtWzNdLCBpdGVtWzRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZVggPSBpdGVtWzNdO1xuICAgICAgICAgICAgcHJlWSA9IGl0ZW1bNF07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgcHJlWCA9IGl0ZW1bM107XG4gICAgICAgICAgICBwcmVZID0gaXRlbVs0XTtcbiAgICAgICAgICAgIHRoaXMucXVhZHJhdGljQ3VydmVUbyhpdGVtWzFdLCBpdGVtWzJdLCBwcmVYLCBwcmVZKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICBwcmVYICs9IGl0ZW1bMV07XG4gICAgICAgICAgICBwcmVZICs9IGl0ZW1bMl07XG4gICAgICAgICAgICB0aGlzLm1vdmVUbyhwcmVYLCBwcmVZKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgcHJlWCArPSBpdGVtWzFdO1xuICAgICAgICAgICAgcHJlWSArPSBpdGVtWzJdO1xuICAgICAgICAgICAgdGhpcy5saW5lVG8ocHJlWCwgcHJlWSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIHByZVggKz0gaXRlbVsxXTtcbiAgICAgICAgICAgIHRoaXMubGluZVRvKHByZVgsIHByZVkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICBwcmVZICs9IGl0ZW1bMV07XG4gICAgICAgICAgICB0aGlzLmxpbmVUbyhwcmVYLCBwcmVZKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHByZVggKyBpdGVtWzFdLCBwcmVZICsgaXRlbVsyXSwgcHJlWCArIGl0ZW1bM10sIHByZVkgKyBpdGVtWzRdLCBwcmVYICsgaXRlbVs1XSwgcHJlWSArIGl0ZW1bNl0pO1xuICAgICAgICAgICAgcHJlWCA9IHByZVggKyBpdGVtWzVdO1xuICAgICAgICAgICAgcHJlWSA9IHByZVkgKyBpdGVtWzZdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICBpZiAocHJlSXRlbVswXSA9PT0gJ0MnIHx8IHByZUl0ZW1bMF0gPT09ICdjJykge1xuICAgICAgICAgICAgICB0aGlzLmJlemllckN1cnZlVG8ocHJlWCArIHByZUl0ZW1bNV0gLSBwcmVJdGVtWzNdLCBwcmVZICsgcHJlSXRlbVs2XSAtIHByZUl0ZW1bNF0sIHByZVggKyBpdGVtWzFdLCBwcmVZICsgaXRlbVsyXSwgcHJlWCArIGl0ZW1bM10sIHByZVkgKyBpdGVtWzRdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJlSXRlbVswXSA9PT0gJ1MnIHx8IHByZUl0ZW1bMF0gPT09ICdzJykge1xuICAgICAgICAgICAgICB0aGlzLmJlemllckN1cnZlVG8ocHJlWCArIHByZUl0ZW1bM10gLSBwcmVJdGVtWzFdLCBwcmVZICsgcHJlSXRlbVs0XSAtIHByZUl0ZW1bMl0sIHByZVggKyBpdGVtWzFdLCBwcmVZICsgaXRlbVsyXSwgcHJlWCArIGl0ZW1bM10sIHByZVkgKyBpdGVtWzRdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJlWCArPSBpdGVtWzNdO1xuICAgICAgICAgICAgcHJlWSArPSBpdGVtWzRdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncSc6XG5cbiAgICAgICAgICAgIHRoaXMucXVhZHJhdGljQ3VydmVUbyhwcmVYICsgaXRlbVsxXSwgcHJlWSArIGl0ZW1bMl0sIGl0ZW1bM10gKyBwcmVYLCBpdGVtWzRdICsgcHJlWSk7XG4gICAgICAgICAgICBwcmVYICs9IGl0ZW1bM107XG4gICAgICAgICAgICBwcmVZICs9IGl0ZW1bNF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgY3VydmVzID0gKDAsIF9hcmNUb0JlemllcjIuZGVmYXVsdCkoe1xuICAgICAgICAgICAgICByeDogaXRlbVsxXSxcbiAgICAgICAgICAgICAgcnk6IGl0ZW1bMl0sXG4gICAgICAgICAgICAgIHB4OiBwcmVYLFxuICAgICAgICAgICAgICBweTogcHJlWSxcbiAgICAgICAgICAgICAgeEF4aXNSb3RhdGlvbjogaXRlbVszXSxcbiAgICAgICAgICAgICAgbGFyZ2VBcmNGbGFnOiBpdGVtWzRdLFxuICAgICAgICAgICAgICBzd2VlcEZsYWc6IGl0ZW1bNV0sXG4gICAgICAgICAgICAgIGN4OiBwcmVYICsgaXRlbVs2XSxcbiAgICAgICAgICAgICAgY3k6IHByZVggKyBpdGVtWzddXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxhc3RDdXJ2ZSA9IGN1cnZlc1tjdXJ2ZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgIGN1cnZlcy5mb3JFYWNoKGZ1bmN0aW9uIChjdXJ2ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMyLm1vdmVUbyhwcmVYLCBwcmVZKTtcbiAgICAgICAgICAgICAgICBfdGhpczIuYmV6aWVyQ3VydmVUbyhjdXJ2ZS54MSwgY3VydmUueTEsIGN1cnZlLngyLCBjdXJ2ZS55MiwgY3VydmUueCwgY3VydmUueSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9jdXJ2ZXNbaW5kZXggLSAxXS54LCBjdXJ2ZXNbaW5kZXggLSAxXS55LCBcbiAgICAgICAgICAgICAgICBfdGhpczIuYmV6aWVyQ3VydmVUbyhjdXJ2ZS54MSwgY3VydmUueTEsIGN1cnZlLngyLCBjdXJ2ZS55MiwgY3VydmUueCwgY3VydmUueSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwcmVYID0gbGFzdEN1cnZlLng7XG4gICAgICAgICAgICBwcmVZID0gbGFzdEN1cnZlLnk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQSc6XG5cbiAgICAgICAgICAgIGN1cnZlcyA9ICgwLCBfYXJjVG9CZXppZXIyLmRlZmF1bHQpKHtcbiAgICAgICAgICAgICAgcng6IGl0ZW1bMV0sXG4gICAgICAgICAgICAgIHJ5OiBpdGVtWzJdLFxuICAgICAgICAgICAgICBweDogcHJlWCxcbiAgICAgICAgICAgICAgcHk6IHByZVksXG4gICAgICAgICAgICAgIHhBeGlzUm90YXRpb246IGl0ZW1bM10sXG4gICAgICAgICAgICAgIGxhcmdlQXJjRmxhZzogaXRlbVs0XSxcbiAgICAgICAgICAgICAgc3dlZXBGbGFnOiBpdGVtWzVdLFxuICAgICAgICAgICAgICBjeDogaXRlbVs2XSxcbiAgICAgICAgICAgICAgY3k6IGl0ZW1bN11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGFzdEN1cnZlID0gY3VydmVzW2N1cnZlcy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgY3VydmVzLmZvckVhY2goZnVuY3Rpb24gKGN1cnZlLCBpbmRleCkge1xuICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICBfdGhpczIubW92ZVRvKHByZVgsIHByZVkpO1xuICAgICAgICAgICAgICAgIF90aGlzMi5iZXppZXJDdXJ2ZVRvKGN1cnZlLngxLCBjdXJ2ZS55MSwgY3VydmUueDIsIGN1cnZlLnkyLCBjdXJ2ZS54LCBjdXJ2ZS55KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL2N1cnZlc1tpbmRleCAtIDFdLngsIGN1cnZlc1tpbmRleCAtIDFdLnlcbiAgICAgICAgICAgICAgICBfdGhpczIuYmV6aWVyQ3VydmVUbyhjdXJ2ZS54MSwgY3VydmUueTEsIGN1cnZlLngyLCBjdXJ2ZS55MiwgY3VydmUueCwgY3VydmUueSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwcmVYID0gbGFzdEN1cnZlLng7XG4gICAgICAgICAgICBwcmVZID0gbGFzdEN1cnZlLnk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnVCc6XG5cbiAgICAgICAgICAgIGlmIChwcmVJdGVtWzBdID09PSAnUScgfHwgcHJlSXRlbVswXSA9PT0gJ3EnKSB7XG4gICAgICAgICAgICAgIHByZUNYID0gcHJlWCArIHByZUl0ZW1bM10gLSBwcmVJdGVtWzFdO1xuICAgICAgICAgICAgICBwcmVDWSA9IHByZVkgKyBwcmVJdGVtWzRdIC0gcHJlSXRlbVsyXTtcbiAgICAgICAgICAgICAgdGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKHByZVgsIHByZVksIHByZUNYLCBwcmVDWSwgaXRlbVsxXSwgaXRlbVsyXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZUl0ZW1bMF0gPT09ICdUJyB8fCBwcmVJdGVtWzBdID09PSAndCcpIHtcbiAgICAgICAgICAgICAgdGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKHByZVgsIHByZVksIHByZVggKyBwcmVYIC0gcHJlQ1gsIHByZVkgKyBwcmVZIC0gcHJlQ1ksIGl0ZW1bMV0sIGl0ZW1bMl0pO1xuICAgICAgICAgICAgICBwcmVDWCA9IHByZVggKyBwcmVYIC0gcHJlQ1g7XG4gICAgICAgICAgICAgIHByZUNZID0gcHJlWSArIHByZVkgLSBwcmVDWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJlWCA9IGl0ZW1bMV07XG4gICAgICAgICAgICBwcmVZID0gaXRlbVsyXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICBpZiAocHJlSXRlbVswXSA9PT0gJ1EnIHx8IHByZUl0ZW1bMF0gPT09ICdxJykge1xuICAgICAgICAgICAgICBwcmVDWCA9IHByZVggKyBwcmVJdGVtWzNdIC0gcHJlSXRlbVsxXTtcbiAgICAgICAgICAgICAgcHJlQ1kgPSBwcmVZICsgcHJlSXRlbVs0XSAtIHByZUl0ZW1bMl07XG4gICAgICAgICAgICAgIHRoaXMucXVhZHJhdGljQ3VydmVUbyhwcmVYLCBwcmVZLCBwcmVDWCwgcHJlQ1ksIHByZVggKyBpdGVtWzFdLCBwcmVZICsgaXRlbVsyXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZUl0ZW1bMF0gPT09ICdUJyB8fCBwcmVJdGVtWzBdID09PSAndCcpIHtcbiAgICAgICAgICAgICAgdGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKHByZVgsIHByZVksIHByZVggKyBwcmVYIC0gcHJlQ1gsIHByZVkgKyBwcmVZIC0gcHJlQ1ksIHByZVggKyBpdGVtWzFdLCBwcmVZICsgaXRlbVsyXSk7XG4gICAgICAgICAgICAgIHByZUNYID0gcHJlWCArIHByZVggLSBwcmVDWDtcbiAgICAgICAgICAgICAgcHJlQ1kgPSBwcmVZICsgcHJlWSAtIHByZUNZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmVYICs9IGl0ZW1bMV07XG4gICAgICAgICAgICBwcmVZICs9IGl0ZW1bMl07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9uLmZpbGxTdHlsZSkge1xuICAgICAgICB0aGlzLmZpbGxTdHlsZSh0aGlzLm9wdGlvbi5maWxsU3R5bGUpO1xuICAgICAgICB0aGlzLmZpbGwoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9uLnN0cm9rZVN0eWxlKSB7XG4gICAgICAgIHRoaXMubGluZVdpZHRoKHRoaXMub3B0aW9uLmxpbmVXaWR0aCk7XG4gICAgICAgIHRoaXMuc3Ryb2tlU3R5bGUodGhpcy5vcHRpb24uc3Ryb2tlU3R5bGUpO1xuICAgICAgICB0aGlzLnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQYXRoO1xufShfc2hhcGUyLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBQYXRoO1xuXG4vKioqLyB9KSxcbi8qIDQyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vamtyb3NvL3BhcnNlLXN2Zy1wYXRoL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4vKipcclxuICogZXhwZWN0ZWQgYXJndW1lbnQgbGVuZ3Roc1xyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKi9cblxudmFyIGxlbmd0aCA9IHsgYTogNywgYzogNiwgaDogMSwgbDogMiwgbTogMiwgcTogNCwgczogNCwgdDogMiwgdjogMSwgejogMFxuXG4gIC8qKlxyXG4gICAqIHNlZ21lbnQgcGF0dGVyblxyXG4gICAqIEB0eXBlIHtSZWdFeHB9XHJcbiAgICovXG5cbn07dmFyIHNlZ21lbnQgPSAvKFthc3R2enFtaGxjXSkoW15hc3R2enFtaGxjXSopL2lnO1xuXG4vKipcclxuICogcGFyc2UgYW4gc3ZnIHBhdGggZGF0YSBzdHJpbmcuIEdlbmVyYXRlcyBhbiBBcnJheVxyXG4gKiBvZiBjb21tYW5kcyB3aGVyZSBlYWNoIGNvbW1hbmQgaXMgYW4gQXJyYXkgb2YgdGhlXHJcbiAqIGZvcm0gYFtjb21tYW5kLCBhcmcxLCBhcmcyLCAuLi5dYFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHBhdGgpIHtcbiAgdmFyIGRhdGEgPSBbXTtcbiAgcGF0aC5yZXBsYWNlKHNlZ21lbnQsIGZ1bmN0aW9uIChfLCBjb21tYW5kLCBhcmdzKSB7XG4gICAgdmFyIHR5cGUgPSBjb21tYW5kLnRvTG93ZXJDYXNlKCk7XG4gICAgYXJncyA9IHBhcnNlVmFsdWVzKGFyZ3MpO1xuXG4gICAgLy8gb3ZlcmxvYWRlZCBtb3ZlVG9cbiAgICBpZiAodHlwZSA9PT0gJ20nICYmIGFyZ3MubGVuZ3RoID4gMikge1xuICAgICAgZGF0YS5wdXNoKFtjb21tYW5kXS5jb25jYXQoYXJncy5zcGxpY2UoMCwgMikpKTtcbiAgICAgIHR5cGUgPSAnbCc7XG4gICAgICBjb21tYW5kID0gY29tbWFuZCA9PT0gJ20nID8gJ2wnIDogJ0wnO1xuICAgIH1cblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IGxlbmd0aFt0eXBlXSkge1xuICAgICAgICBhcmdzLnVuc2hpZnQoY29tbWFuZCk7XG4gICAgICAgIHJldHVybiBkYXRhLnB1c2goYXJncyk7XG4gICAgICB9XG4gICAgICBpZiAoYXJncy5sZW5ndGggPCBsZW5ndGhbdHlwZV0pIHRocm93IG5ldyBFcnJvcignbWFsZm9ybWVkIHBhdGggZGF0YScpO1xuICAgICAgZGF0YS5wdXNoKFtjb21tYW5kXS5jb25jYXQoYXJncy5zcGxpY2UoMCwgbGVuZ3RoW3R5cGVdKSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG52YXIgbnVtYmVyID0gLy0/WzAtOV0qXFwuP1swLTldKyg/OmVbLStdP1xcZCspPy9pZztcblxuZnVuY3Rpb24gcGFyc2VWYWx1ZXMoYXJncykge1xuICB2YXIgbnVtYmVycyA9IGFyZ3MubWF0Y2gobnVtYmVyKTtcbiAgcmV0dXJuIG51bWJlcnMgPyBudW1iZXJzLm1hcChOdW1iZXIpIDogW107XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHBhcnNlO1xuXG4vKioqLyB9KSxcbi8qIDQzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NvbGlubWVpbmtlL3N2Zy1hcmMtdG8tY3ViaWMtYmV6aWVyXG5cbnZhciBUQVUgPSBNYXRoLlBJICogMjtcblxudmFyIG1hcFRvRWxsaXBzZSA9IGZ1bmN0aW9uIG1hcFRvRWxsaXBzZShfcmVmLCByeCwgcnksIGNvc3BoaSwgc2lucGhpLCBjZW50ZXJ4LCBjZW50ZXJ5KSB7XG4gIHZhciB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcblxuICB4ICo9IHJ4O1xuICB5ICo9IHJ5O1xuXG4gIHZhciB4cCA9IGNvc3BoaSAqIHggLSBzaW5waGkgKiB5O1xuICB2YXIgeXAgPSBzaW5waGkgKiB4ICsgY29zcGhpICogeTtcblxuICByZXR1cm4ge1xuICAgIHg6IHhwICsgY2VudGVyeCxcbiAgICB5OiB5cCArIGNlbnRlcnlcbiAgfTtcbn07XG5cbnZhciBhcHByb3hVbml0QXJjID0gZnVuY3Rpb24gYXBwcm94VW5pdEFyYyhhbmcxLCBhbmcyKSB7XG4gIHZhciBhID0gNCAvIDMgKiBNYXRoLnRhbihhbmcyIC8gNCk7XG5cbiAgdmFyIHgxID0gTWF0aC5jb3MoYW5nMSk7XG4gIHZhciB5MSA9IE1hdGguc2luKGFuZzEpO1xuICB2YXIgeDIgPSBNYXRoLmNvcyhhbmcxICsgYW5nMik7XG4gIHZhciB5MiA9IE1hdGguc2luKGFuZzEgKyBhbmcyKTtcblxuICByZXR1cm4gW3tcbiAgICB4OiB4MSAtIHkxICogYSxcbiAgICB5OiB5MSArIHgxICogYVxuICB9LCB7XG4gICAgeDogeDIgKyB5MiAqIGEsXG4gICAgeTogeTIgLSB4MiAqIGFcbiAgfSwge1xuICAgIHg6IHgyLFxuICAgIHk6IHkyXG4gIH1dO1xufTtcblxudmFyIHZlY3RvckFuZ2xlID0gZnVuY3Rpb24gdmVjdG9yQW5nbGUodXgsIHV5LCB2eCwgdnkpIHtcbiAgdmFyIHNpZ24gPSB1eCAqIHZ5IC0gdXkgKiB2eCA8IDAgPyAtMSA6IDE7XG4gIHZhciB1bWFnID0gTWF0aC5zcXJ0KHV4ICogdXggKyB1eSAqIHV5KTtcbiAgdmFyIHZtYWcgPSBNYXRoLnNxcnQodXggKiB1eCArIHV5ICogdXkpO1xuICB2YXIgZG90ID0gdXggKiB2eCArIHV5ICogdnk7XG5cbiAgdmFyIGRpdiA9IGRvdCAvICh1bWFnICogdm1hZyk7XG5cbiAgaWYgKGRpdiA+IDEpIHtcbiAgICBkaXYgPSAxO1xuICB9XG5cbiAgaWYgKGRpdiA8IC0xKSB7XG4gICAgZGl2ID0gLTE7XG4gIH1cblxuICByZXR1cm4gc2lnbiAqIE1hdGguYWNvcyhkaXYpO1xufTtcblxudmFyIGdldEFyY0NlbnRlciA9IGZ1bmN0aW9uIGdldEFyY0NlbnRlcihweCwgcHksIGN4LCBjeSwgcngsIHJ5LCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgc2lucGhpLCBjb3NwaGksIHB4cCwgcHlwKSB7XG4gIHZhciByeHNxID0gTWF0aC5wb3cocngsIDIpO1xuICB2YXIgcnlzcSA9IE1hdGgucG93KHJ5LCAyKTtcbiAgdmFyIHB4cHNxID0gTWF0aC5wb3cocHhwLCAyKTtcbiAgdmFyIHB5cHNxID0gTWF0aC5wb3cocHlwLCAyKTtcblxuICB2YXIgcmFkaWNhbnQgPSByeHNxICogcnlzcSAtIHJ4c3EgKiBweXBzcSAtIHJ5c3EgKiBweHBzcTtcblxuICBpZiAocmFkaWNhbnQgPCAwKSB7XG4gICAgcmFkaWNhbnQgPSAwO1xuICB9XG5cbiAgcmFkaWNhbnQgLz0gcnhzcSAqIHB5cHNxICsgcnlzcSAqIHB4cHNxO1xuICByYWRpY2FudCA9IE1hdGguc3FydChyYWRpY2FudCkgKiAobGFyZ2VBcmNGbGFnID09PSBzd2VlcEZsYWcgPyAtMSA6IDEpO1xuXG4gIHZhciBjZW50ZXJ4cCA9IHJhZGljYW50ICogcnggLyByeSAqIHB5cDtcbiAgdmFyIGNlbnRlcnlwID0gcmFkaWNhbnQgKiAtcnkgLyByeCAqIHB4cDtcblxuICB2YXIgY2VudGVyeCA9IGNvc3BoaSAqIGNlbnRlcnhwIC0gc2lucGhpICogY2VudGVyeXAgKyAocHggKyBjeCkgLyAyO1xuICB2YXIgY2VudGVyeSA9IHNpbnBoaSAqIGNlbnRlcnhwICsgY29zcGhpICogY2VudGVyeXAgKyAocHkgKyBjeSkgLyAyO1xuXG4gIHZhciB2eDEgPSAocHhwIC0gY2VudGVyeHApIC8gcng7XG4gIHZhciB2eTEgPSAocHlwIC0gY2VudGVyeXApIC8gcnk7XG4gIHZhciB2eDIgPSAoLXB4cCAtIGNlbnRlcnhwKSAvIHJ4O1xuICB2YXIgdnkyID0gKC1weXAgLSBjZW50ZXJ5cCkgLyByeTtcblxuICB2YXIgYW5nMSA9IHZlY3RvckFuZ2xlKDEsIDAsIHZ4MSwgdnkxKTtcbiAgdmFyIGFuZzIgPSB2ZWN0b3JBbmdsZSh2eDEsIHZ5MSwgdngyLCB2eTIpO1xuXG4gIGlmIChzd2VlcEZsYWcgPT09IDAgJiYgYW5nMiA+IDApIHtcbiAgICBhbmcyIC09IFRBVTtcbiAgfVxuXG4gIGlmIChzd2VlcEZsYWcgPT09IDEgJiYgYW5nMiA8IDApIHtcbiAgICBhbmcyICs9IFRBVTtcbiAgfVxuXG4gIHJldHVybiBbY2VudGVyeCwgY2VudGVyeSwgYW5nMSwgYW5nMl07XG59O1xuXG52YXIgYXJjVG9CZXppZXIgPSBmdW5jdGlvbiBhcmNUb0JlemllcihfcmVmMikge1xuICB2YXIgcHggPSBfcmVmMi5weCxcbiAgICAgIHB5ID0gX3JlZjIucHksXG4gICAgICBjeCA9IF9yZWYyLmN4LFxuICAgICAgY3kgPSBfcmVmMi5jeSxcbiAgICAgIHJ4ID0gX3JlZjIucngsXG4gICAgICByeSA9IF9yZWYyLnJ5LFxuICAgICAgX3JlZjIkeEF4aXNSb3RhdGlvbiA9IF9yZWYyLnhBeGlzUm90YXRpb24sXG4gICAgICB4QXhpc1JvdGF0aW9uID0gX3JlZjIkeEF4aXNSb3RhdGlvbiA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYyJHhBeGlzUm90YXRpb24sXG4gICAgICBfcmVmMiRsYXJnZUFyY0ZsYWcgPSBfcmVmMi5sYXJnZUFyY0ZsYWcsXG4gICAgICBsYXJnZUFyY0ZsYWcgPSBfcmVmMiRsYXJnZUFyY0ZsYWcgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmMiRsYXJnZUFyY0ZsYWcsXG4gICAgICBfcmVmMiRzd2VlcEZsYWcgPSBfcmVmMi5zd2VlcEZsYWcsXG4gICAgICBzd2VlcEZsYWcgPSBfcmVmMiRzd2VlcEZsYWcgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmMiRzd2VlcEZsYWc7XG5cbiAgdmFyIGN1cnZlcyA9IFtdO1xuXG4gIGlmIChyeCA9PT0gMCB8fCByeSA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBzaW5waGkgPSBNYXRoLnNpbih4QXhpc1JvdGF0aW9uICogVEFVIC8gMzYwKTtcbiAgdmFyIGNvc3BoaSA9IE1hdGguY29zKHhBeGlzUm90YXRpb24gKiBUQVUgLyAzNjApO1xuXG4gIHZhciBweHAgPSBjb3NwaGkgKiAocHggLSBjeCkgLyAyICsgc2lucGhpICogKHB5IC0gY3kpIC8gMjtcbiAgdmFyIHB5cCA9IC1zaW5waGkgKiAocHggLSBjeCkgLyAyICsgY29zcGhpICogKHB5IC0gY3kpIC8gMjtcblxuICBpZiAocHhwID09PSAwICYmIHB5cCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHJ4ID0gTWF0aC5hYnMocngpO1xuICByeSA9IE1hdGguYWJzKHJ5KTtcblxuICB2YXIgbGFtYmRhID0gTWF0aC5wb3cocHhwLCAyKSAvIE1hdGgucG93KHJ4LCAyKSArIE1hdGgucG93KHB5cCwgMikgLyBNYXRoLnBvdyhyeSwgMik7XG5cbiAgaWYgKGxhbWJkYSA+IDEpIHtcbiAgICByeCAqPSBNYXRoLnNxcnQobGFtYmRhKTtcbiAgICByeSAqPSBNYXRoLnNxcnQobGFtYmRhKTtcbiAgfVxuXG4gIHZhciBfZ2V0QXJjQ2VudGVyID0gZ2V0QXJjQ2VudGVyKHB4LCBweSwgY3gsIGN5LCByeCwgcnksIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLCBzaW5waGksIGNvc3BoaSwgcHhwLCBweXApLFxuICAgICAgX2dldEFyY0NlbnRlcjIgPSBfc2xpY2VkVG9BcnJheShfZ2V0QXJjQ2VudGVyLCA0KSxcbiAgICAgIGNlbnRlcnggPSBfZ2V0QXJjQ2VudGVyMlswXSxcbiAgICAgIGNlbnRlcnkgPSBfZ2V0QXJjQ2VudGVyMlsxXSxcbiAgICAgIGFuZzEgPSBfZ2V0QXJjQ2VudGVyMlsyXSxcbiAgICAgIGFuZzIgPSBfZ2V0QXJjQ2VudGVyMlszXTtcblxuICB2YXIgc2VnbWVudHMgPSBNYXRoLm1heChNYXRoLmNlaWwoTWF0aC5hYnMoYW5nMikgLyAoVEFVIC8gNCkpLCAxKTtcblxuICBhbmcyIC89IHNlZ21lbnRzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHM7IGkrKykge1xuICAgIGN1cnZlcy5wdXNoKGFwcHJveFVuaXRBcmMoYW5nMSwgYW5nMikpO1xuICAgIGFuZzEgKz0gYW5nMjtcbiAgfVxuXG4gIHJldHVybiBjdXJ2ZXMubWFwKGZ1bmN0aW9uIChjdXJ2ZSkge1xuICAgIHZhciBfbWFwVG9FbGxpcHNlID0gbWFwVG9FbGxpcHNlKGN1cnZlWzBdLCByeCwgcnksIGNvc3BoaSwgc2lucGhpLCBjZW50ZXJ4LCBjZW50ZXJ5KSxcbiAgICAgICAgeDEgPSBfbWFwVG9FbGxpcHNlLngsXG4gICAgICAgIHkxID0gX21hcFRvRWxsaXBzZS55O1xuXG4gICAgdmFyIF9tYXBUb0VsbGlwc2UyID0gbWFwVG9FbGxpcHNlKGN1cnZlWzFdLCByeCwgcnksIGNvc3BoaSwgc2lucGhpLCBjZW50ZXJ4LCBjZW50ZXJ5KSxcbiAgICAgICAgeDIgPSBfbWFwVG9FbGxpcHNlMi54LFxuICAgICAgICB5MiA9IF9tYXBUb0VsbGlwc2UyLnk7XG5cbiAgICB2YXIgX21hcFRvRWxsaXBzZTMgPSBtYXBUb0VsbGlwc2UoY3VydmVbMl0sIHJ4LCByeSwgY29zcGhpLCBzaW5waGksIGNlbnRlcngsIGNlbnRlcnkpLFxuICAgICAgICB4ID0gX21hcFRvRWxsaXBzZTMueCxcbiAgICAgICAgeSA9IF9tYXBUb0VsbGlwc2UzLnk7XG5cbiAgICByZXR1cm4geyB4MTogeDEsIHkxOiB5MSwgeDI6IHgyLCB5MjogeTIsIHg6IHgsIHk6IHkgfTtcbiAgfSk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBhcmNUb0JlemllcjtcblxuLyoqKi8gfSksXG4vKiA0NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dyb3VwID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9ncm91cDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ncm91cCk7XG5cbnZhciBfdGV4dCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfdGV4dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90ZXh0KTtcblxudmFyIF9yb3VuZGVkUmVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXG52YXIgX3JvdW5kZWRSZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdW5kZWRSZWN0KTtcblxudmFyIF9iaXRtYXAyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9iaXRtYXAzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYml0bWFwMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLypcclxuT3B0aW9uc1xyXG4gIGZvbnQ6XHJcbiAgdGV4dDogXHJcbiAgdGV4dENvbG9yOlxyXG4gIGltYWdlOiBbcGF0aCwgd2lkdGgsIGhlaWdodF1cclxuICBiZ0NvbG9yOiBcclxuICBiZ0ltYWdlOiBbcGF0aCwgd2lkdGgsIGhlaWdodF1cclxuICBib3JkZXJSYWRpdXM6XHJcbiAgYm9yZGVyQ29sb3I6XHJcbiovXG5cbnZhciBCdXR0b24gPSBmdW5jdGlvbiAoX0dyb3VwKSB7XG4gIF9pbmhlcml0cyhCdXR0b24sIF9Hcm91cCk7XG5cbiAgZnVuY3Rpb24gQnV0dG9uKG9wdGlvbikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdXR0b24pO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEJ1dHRvbi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEJ1dHRvbikpLmNhbGwodGhpcykpO1xuXG4gICAgX3RoaXMud2lkdGggPSBvcHRpb24ud2lkdGg7XG4gICAgX3RoaXMuaGVpZ2h0ID0gb3B0aW9uLmhlaWdodDtcbiAgICBfdGhpcy54ID0gb3B0aW9uLng7XG4gICAgX3RoaXMueSA9IG9wdGlvbi55O1xuXG4gICAgdmFyIHRleHRIZWlnaHQgPSAwO1xuICAgIHZhciB0ZXh0R3JvdXA7XG5cbiAgICBpZiAob3B0aW9uLnRleHQpIHtcbiAgICAgIHRleHRHcm91cCA9IG5ldyBfZ3JvdXAyLmRlZmF1bHQoKTtcbiAgICAgIF90aGlzLnRleHQgPSBuZXcgX3RleHQyLmRlZmF1bHQob3B0aW9uLnRleHQsIHtcbiAgICAgICAgZm9udDogb3B0aW9uLmZvbnQsXG4gICAgICAgIGNvbG9yOiBvcHRpb24uY29sb3JcbiAgICAgIH0pO1xuICAgICAgdmFyIHRleHRXaWR0aCA9IF90aGlzLnRleHQuZ2V0V2lkdGgoKTtcblxuICAgICAgaWYgKHRleHRXaWR0aCA+IG9wdGlvbi53aWR0aCkge1xuICAgICAgICB2YXIgc3RlcCA9IE1hdGgucm91bmQob3B0aW9uLnRleHQubGVuZ3RoICogb3B0aW9uLndpZHRoIC8gdGV4dFdpZHRoIC8gMik7XG5cbiAgICAgICAgdmFyIHRleHRMaXN0ID0gX3RoaXMuc3RyaW5nU3BsaXQob3B0aW9uLnRleHQsIHN0ZXApO1xuICAgICAgICB2YXIgbGluZUhlaWdodCA9IG9wdGlvbi5saW5lSGVpZ2h0IHx8IDEyO1xuICAgICAgICB0ZXh0SGVpZ2h0ID0gdGV4dExpc3QubGVuZ3RoICogbGluZUhlaWdodCArIDY7XG5cbiAgICAgICAgdGV4dExpc3QuZm9yRWFjaChmdW5jdGlvbiAodGV4dCwgaW5kZXgpIHtcbiAgICAgICAgICBfdGhpcy50ZXh0ID0gbmV3IF90ZXh0Mi5kZWZhdWx0KHRleHQsIHtcbiAgICAgICAgICAgIGZvbnQ6IG9wdGlvbi5mb250LFxuICAgICAgICAgICAgY29sb3I6IG9wdGlvbi5jb2xvclxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgX3RoaXMudGV4dC54ID0gb3B0aW9uLndpZHRoIC8gMiAtIF90aGlzLnRleHQuZ2V0V2lkdGgoKSAvIDIgKiBfdGhpcy50ZXh0LnNjYWxlWCArIChvcHRpb24udGV4dFggfHwgMCk7XG4gICAgICAgICAgX3RoaXMudGV4dC55ID0gTWF0aC5tYXgodGV4dEhlaWdodCwgb3B0aW9uLmhlaWdodCkgLyAyIC0gMTAgKyA1ICogX3RoaXMudGV4dC5zY2FsZVkgKyAob3B0aW9uLnRleHRZIHx8IDApICsgaW5kZXggKiAxMiAtIHRleHRIZWlnaHQgLyAyICsgbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgdGV4dEdyb3VwLmFkZChfdGhpcy50ZXh0KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy50ZXh0LnggPSBvcHRpb24ud2lkdGggLyAyIC0gX3RoaXMudGV4dC5nZXRXaWR0aCgpIC8gMiAqIF90aGlzLnRleHQuc2NhbGVYICsgKG9wdGlvbi50ZXh0WCB8fCAwKTtcbiAgICAgICAgX3RoaXMudGV4dC55ID0gb3B0aW9uLmhlaWdodCAvIDIgLSAxMCArIDUgKiBfdGhpcy50ZXh0LnNjYWxlWSArIChvcHRpb24udGV4dFkgfHwgMCk7XG4gICAgICAgIHRleHRHcm91cC5hZGQoX3RoaXMudGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbi5iZ0ltYWdlKSB7XG4gICAgICB2YXIgcmF0aW8gPSBTQ0FMRV9SQVRJTztcbiAgICAgIHZhciBiaXRtYXAgPSBuZXcgX2JpdG1hcDMuZGVmYXVsdChvcHRpb24uYmdJbWFnZVswXSk7XG4gICAgICBiaXRtYXAuc2NhbGVYID0gcmF0aW87XG4gICAgICBiaXRtYXAuc2NhbGVZID0gcmF0aW87XG4gICAgICBiaXRtYXAud2lkdGggPSBvcHRpb24uYmdJbWFnZVsxXTtcbiAgICAgIGJpdG1hcC5oZWlnaHQgPSBvcHRpb24uYmdJbWFnZVsyXTtcbiAgICAgIGJpdG1hcC54ID0gKF90aGlzLndpZHRoIC0gYml0bWFwLndpZHRoKSAvIDI7XG4gICAgICBiaXRtYXAueSA9IChfdGhpcy5oZWlnaHQgLSBiaXRtYXAuaGVpZ2h0KSAvIDI7XG4gICAgICBfdGhpcy5hZGQoYml0bWFwKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbi5iZ0NvbG9yIHx8IG9wdGlvbi5ib3JkZXJDb2xvcikge1xuICAgICAgX3RoaXMucm91bmRlZFJlY3QgPSBuZXcgX3JvdW5kZWRSZWN0Mi5kZWZhdWx0KG9wdGlvbi53aWR0aCwgb3B0aW9uLmF1dG9IZWlnaHQgPyBNYXRoLm1heCh0ZXh0SGVpZ2h0LCBvcHRpb24uaGVpZ2h0KSA6IG9wdGlvbi5oZWlnaHQsIG9wdGlvbi5ib3JkZXJSYWRpdXMsIHtcbiAgICAgICAgc3Ryb2tlU3R5bGU6IG9wdGlvbi5ib3JkZXJDb2xvciB8fCAnYmxhY2snLFxuICAgICAgICBmaWxsU3R5bGU6IG9wdGlvbi5iYWNrZ3JvdW5kQ29sb3IgfHwgJyNGNUY1RjUnXG4gICAgICB9KTtcbiAgICAgIF90aGlzLmFkZChfdGhpcy5yb3VuZGVkUmVjdCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbi5pbWFnZSkge1xuICAgICAgdmFyIHJhdGlvID0gU0NBTEVfUkFUSU87XG4gICAgICB2YXIgX2JpdG1hcCA9IG5ldyBfYml0bWFwMy5kZWZhdWx0KG9wdGlvbi5pbWFnZVswXSk7XG4gICAgICBfYml0bWFwLnNjYWxlWCA9IHJhdGlvO1xuICAgICAgX2JpdG1hcC5zY2FsZVkgPSByYXRpbztcbiAgICAgIF9iaXRtYXAud2lkdGggPSBvcHRpb24uaW1hZ2VbMV07XG4gICAgICBfYml0bWFwLmhlaWdodCA9IG9wdGlvbi5pbWFnZVsyXTtcbiAgICAgIF9iaXRtYXAueCA9IChfdGhpcy53aWR0aCAtIF9iaXRtYXAud2lkdGgpIC8gMjtcbiAgICAgIF9iaXRtYXAueSA9IChfdGhpcy5oZWlnaHQgLSBfYml0bWFwLmhlaWdodCkgLyAyO1xuICAgICAgX3RoaXMuYWRkKF9iaXRtYXApO1xuICAgIH1cblxuICAgIGlmICh0ZXh0R3JvdXApIHtcbiAgICAgIF90aGlzLmFkZCh0ZXh0R3JvdXApO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQnV0dG9uLCBbe1xuICAgIGtleTogJ3N0cmluZ1NwbGl0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RyaW5nU3BsaXQoc3RyLCBsZW4pIHtcbiAgICAgIHZhciBhcnIgPSBbXSxcbiAgICAgICAgICBvZmZzZXQgPSAwLFxuICAgICAgICAgIGNoYXJfbGVuZ3RoID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb25fc3RyID0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgZW5jb2RlVVJJKHNvbl9zdHIpLmxlbmd0aCA+IDIgPyBjaGFyX2xlbmd0aCArPSAxIDogY2hhcl9sZW5ndGggKz0gMC41O1xuICAgICAgICBpZiAoY2hhcl9sZW5ndGggPj0gbGVuIHx8IGNoYXJfbGVuZ3RoIDwgbGVuICYmIGkgPT09IHN0ci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgdmFyIHN1Yl9sZW4gPSBjaGFyX2xlbmd0aCA9PSBsZW4gPyBpICsgMSA6IGk7XG4gICAgICAgICAgYXJyLnB1c2goc3RyLnN1YnN0cihvZmZzZXQsIHN1Yl9sZW4gLSBvZmZzZXQgKyAoY2hhcl9sZW5ndGggPCBsZW4gJiYgaSA9PT0gc3RyLmxlbmd0aCAtIDEgPyAxIDogMCkpKTtcbiAgICAgICAgICBvZmZzZXQgPSBpICsgMTtcbiAgICAgICAgICBjaGFyX2xlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJ1dHRvbjtcbn0oX2dyb3VwMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQnV0dG9uO1xuXG4vKioqLyB9KSxcbi8qIDQ1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfc2hhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3NoYXBlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoYXBlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgUmVjdCA9IGZ1bmN0aW9uIChfU2hhcGUpIHtcbiAgX2luaGVyaXRzKFJlY3QsIF9TaGFwZSk7XG5cbiAgZnVuY3Rpb24gUmVjdCh3aWR0aCwgaGVpZ2h0LCBvcHRpb24pIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVjdCk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoUmVjdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFJlY3QpKS5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzLndpZHRoID0gd2lkdGg7XG4gICAgX3RoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIF90aGlzLm9wdGlvbiA9IG9wdGlvbiB8fCB7fTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmVjdCwgW3tcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdygpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbi5maWxsU3R5bGUpIHtcbiAgICAgICAgdGhpcy5maWxsU3R5bGUodGhpcy5vcHRpb24uZmlsbFN0eWxlKTtcbiAgICAgICAgdGhpcy5maWxsUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbi5zdHJva2VTdHlsZSkge1xuICAgICAgICB0aGlzLnN0cm9rZVN0eWxlKHRoaXMub3B0aW9uLnN0cm9rZVN0eWxlKTtcbiAgICAgICAgdGhpcy5zdHJva2VSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVjdDtcbn0oX3NoYXBlMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUmVjdDtcblxuLyoqKi8gfSksXG4vKiA0NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3NoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9zaGFwZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zaGFwZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIENpcmNsZSA9IGZ1bmN0aW9uIChfU2hhcGUpIHtcbiAgX2luaGVyaXRzKENpcmNsZSwgX1NoYXBlKTtcblxuICBmdW5jdGlvbiBDaXJjbGUociwgb3B0aW9uKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENpcmNsZSk7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQ2lyY2xlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2lyY2xlKSkuY2FsbCh0aGlzKSk7XG5cbiAgICBfdGhpcy5vcHRpb24gPSBvcHRpb24gfHwge307XG4gICAgX3RoaXMuciA9IHI7XG5cbiAgICBfdGhpcy5fZHAgPSBNYXRoLlBJICogMjtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2lyY2xlLCBbe1xuICAgIGtleTogJ2RyYXcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KCkge1xuICAgICAgdGhpcy5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMuYXJjKDAsIDAsIHRoaXMuciwgMCwgdGhpcy5fZHAsIGZhbHNlKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9uLnN0cm9rZVN0eWxlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbi5saW5lV2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMubGluZVdpZHRoKHRoaXMub3B0aW9uLmxpbmVXaWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdHJva2VTdHlsZSh0aGlzLm9wdGlvbi5zdHJva2VTdHlsZSk7XG4gICAgICAgIHRoaXMuc3Ryb2tlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbi5maWxsU3R5bGUpIHtcbiAgICAgICAgdGhpcy5maWxsU3R5bGUodGhpcy5vcHRpb24uZmlsbFN0eWxlKTtcbiAgICAgICAgdGhpcy5maWxsKCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENpcmNsZTtcbn0oX3NoYXBlMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQ2lyY2xlO1xuXG4vKioqLyB9KSxcbi8qIDQ3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfc2hhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3NoYXBlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoYXBlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgUG9seWdvbiA9IGZ1bmN0aW9uIChfU2hhcGUpIHtcbiAgX2luaGVyaXRzKFBvbHlnb24sIF9TaGFwZSk7XG5cbiAgZnVuY3Rpb24gUG9seWdvbih2ZXJ0ZXgsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9seWdvbik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoUG9seWdvbi5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFBvbHlnb24pKS5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzLnZlcnRleCA9IHZlcnRleCB8fCBbXTtcbiAgICBfdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBfdGhpcy5zdHJva2VDb2xvciA9IF90aGlzLm9wdGlvbnMuc3Ryb2tlQ29sb3I7XG4gICAgX3RoaXMuZmlsbENvbG9yID0gX3RoaXMub3B0aW9ucy5maWxsQ29sb3I7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBvbHlnb24sIFt7XG4gICAga2V5OiAnZHJhdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAgICB0aGlzLmNsZWFyKCkuYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLnN0cm9rZVN0eWxlKHRoaXMuc3Ryb2tlQ29sb3IpO1xuICAgICAgdGhpcy5tb3ZlVG8odGhpcy52ZXJ0ZXhbMF1bMF0sIHRoaXMudmVydGV4WzBdWzFdKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IHRoaXMudmVydGV4Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMubGluZVRvKHRoaXMudmVydGV4W2ldWzBdLCB0aGlzLnZlcnRleFtpXVsxXSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgICAgLy8g6Lev5b6E6Zet5ZCIXG4gICAgICAvLyAgaWYgKHRoaXMub3B0aW9ucy5zdHJva2VTdHlsZSkge1xuICAgICAgLy8gICAgdGhpcy5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgLy8gdGhpcy5saW5lV2lkdGgodGhpcy5vcHRpb25zLndpZHRoKTtcbiAgICAgIC8vIHRoaXMubGluZUpvaW4oJ3JvdW5kJyk7XG4gICAgICAvLyB0aGlzLnN0cm9rZSgpO1xuICAgICAgLy8gIH1cbiAgICAgIGlmICh0aGlzLnN0cm9rZUNvbG9yKSB7XG4gICAgICAgIHRoaXMuc3Ryb2tlU3R5bGUodGhpcy5zdHJva2VDb2xvcik7XG4gICAgICAgIHRoaXMuc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5maWxsQ29sb3IpIHtcbiAgICAgICAgdGhpcy5maWxsU3R5bGUodGhpcy5maWxsQ29sb3IpO1xuICAgICAgICB0aGlzLmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUG9seWdvbjtcbn0oX3NoYXBlMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUG9seWdvbjtcblxuLyoqKi8gfSksXG4vKiA0OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3NoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9zaGFwZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zaGFwZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEVxdWlsYXRlcmFsUG9seWdvbiA9IGZ1bmN0aW9uIChfU2hhcGUpIHtcbiAgX2luaGVyaXRzKEVxdWlsYXRlcmFsUG9seWdvbiwgX1NoYXBlKTtcblxuICBmdW5jdGlvbiBFcXVpbGF0ZXJhbFBvbHlnb24obnVtLCByLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVxdWlsYXRlcmFsUG9seWdvbik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRXF1aWxhdGVyYWxQb2x5Z29uLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRXF1aWxhdGVyYWxQb2x5Z29uKSkuY2FsbCh0aGlzKSk7XG5cbiAgICBfdGhpcy5udW0gPSBudW07XG4gICAgX3RoaXMuciA9IHI7XG4gICAgX3RoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBfdGhpcy52ZXJ0ZXggPSBbXTtcbiAgICBfdGhpcy5pbml0VmVydGV4KCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEVxdWlsYXRlcmFsUG9seWdvbiwgW3tcbiAgICBrZXk6ICdpbml0VmVydGV4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdFZlcnRleCgpIHtcbiAgICAgIHRoaXMudmVydGV4Lmxlbmd0aCA9IFtdO1xuICAgICAgdmFyIG51bSA9IHRoaXMubnVtO1xuICAgICAgdmFyIHIgPSB0aGlzLnI7XG4gICAgICB2YXIgaSA9IHZvaWQgMCxcbiAgICAgICAgICBzdGFydFggPSB2b2lkIDAsXG4gICAgICAgICAgc3RhcnRZID0gdm9pZCAwLFxuICAgICAgICAgIG5ld1ggPSB2b2lkIDAsXG4gICAgICAgICAgbmV3WSA9IHZvaWQgMDtcblxuICAgICAgaWYgKG51bSAlIDIgPT09IDApIHtcbiAgICAgICAgc3RhcnRYID0gciAqIE1hdGguY29zKDIgKiBNYXRoLlBJICogMCAvIG51bSk7XG4gICAgICAgIHN0YXJ0WSA9IHIgKiBNYXRoLnNpbigyICogTWF0aC5QSSAqIDAgLyBudW0pO1xuXG4gICAgICAgIHRoaXMudmVydGV4LnB1c2goW3N0YXJ0WCwgc3RhcnRZXSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBudW07IGkrKykge1xuICAgICAgICAgIG5ld1ggPSByICogTWF0aC5jb3MoMiAqIE1hdGguUEkgKiBpIC8gbnVtKTtcbiAgICAgICAgICBuZXdZID0gciAqIE1hdGguc2luKDIgKiBNYXRoLlBJICogaSAvIG51bSk7XG5cbiAgICAgICAgICB0aGlzLnZlcnRleC5wdXNoKFtuZXdYLCBuZXdZXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0WCA9IHIgKiBNYXRoLmNvcygyICogTWF0aC5QSSAqIDAgLyBudW0gLSBNYXRoLlBJIC8gMik7XG4gICAgICAgIHN0YXJ0WSA9IHIgKiBNYXRoLnNpbigyICogTWF0aC5QSSAqIDAgLyBudW0gLSBNYXRoLlBJIC8gMik7XG5cbiAgICAgICAgdGhpcy52ZXJ0ZXgucHVzaChbc3RhcnRYLCBzdGFydFldKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG51bTsgaSsrKSB7XG4gICAgICAgICAgbmV3WCA9IHIgKiBNYXRoLmNvcygyICogTWF0aC5QSSAqIGkgLyBudW0gLSBNYXRoLlBJIC8gMik7XG4gICAgICAgICAgbmV3WSA9IHIgKiBNYXRoLnNpbigyICogTWF0aC5QSSAqIGkgLyBudW0gLSBNYXRoLlBJIC8gMik7XG5cbiAgICAgICAgICB0aGlzLnZlcnRleC5wdXNoKFtuZXdYLCBuZXdZXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdygpIHtcbiAgICAgIHRoaXMuYmVnaW5QYXRoKCk7XG5cbiAgICAgIHRoaXMubW92ZVRvKHRoaXMudmVydGV4WzBdWzBdLCB0aGlzLnZlcnRleFswXVsxXSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSB0aGlzLnZlcnRleC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLmxpbmVUbyh0aGlzLnZlcnRleFtpXVswXSwgdGhpcy52ZXJ0ZXhbaV1bMV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5maWxsU3R5bGUpIHtcbiAgICAgICAgdGhpcy5maWxsU3R5bGUodGhpcy5vcHRpb25zLmZpbGxTdHlsZSk7XG4gICAgICAgIHRoaXMuZmlsbCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN0cm9rZVN0eWxlKSB7XG4gICAgICAgIHRoaXMuc3Ryb2tlU3R5bGUodGhpcy5vcHRpb25zLnN0cm9rZVN0eWxlKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMubGluZVdpZHRoID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMubGluZVdpZHRoKHRoaXMub3B0aW9ucy5saW5lV2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVxdWlsYXRlcmFsUG9seWdvbjtcbn0oX3NoYXBlMi5kZWZhdWx0KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRXF1aWxhdGVyYWxQb2x5Z29uO1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.1.2.9@cax/dist/cax.js\n");

/***/ }),

/***/ "./src/bird.js":
/*!*********************!*\
  !*** ./src/bird.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _class, _temp;\n\nvar _cax = __webpack_require__(/*! cax */ \"./node_modules/.1.2.9@cax/dist/cax.js\");\n\nvar _cax2 = _interopRequireDefault(_cax);\n\nvar _vector = __webpack_require__(/*! ./vector */ \"./src/vector.js\");\n\nvar _vector2 = _interopRequireDefault(_vector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Bird = (_temp = _class = function (_cax$Group) {\n  _inherits(Bird, _cax$Group);\n\n  function Bird() {\n    var mass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n    _classCallCheck(this, Bird);\n\n    var _this = _possibleConstructorReturn(this, (Bird.__proto__ || Object.getPrototypeOf(Bird)).call(this));\n\n    _this.polygon = new _cax2.default.Graphics();\n    _this.polygon.fillStyle('hsl(' + (0 + Math.random() * 30) + ',75%,75%)').beginPath().moveTo(10, 0).lineTo(-10, 8).lineTo(-10, -8).lineTo(10, 0).closePath().fill();\n\n    _this.add(_this.polygon);\n\n    _this.po = new _vector2.default();\n    _this.ve = new _vector2.default();\n    _this.ac = new _vector2.default();\n\n    _this.mass = mass;\n\n    return _this;\n  }\n\n  _createClass(Bird, [{\n    key: 'update',\n    value: function update(stage, birds) {\n      var _this2 = this;\n\n      birds = birds.filter(function (o) {\n        return _this2 != o;\n      });\n\n      // separation\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = birds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var bird = _step.value;\n\n          if (this.po.distanceTo(bird.po) < Bird.sDist) {\n\n            this.ac.sub(bird.po.clone().sub(this.po).normalize().multiplyScalar(Bird.MAX_SPEED).sub(this.ve));\n          }\n        }\n\n        // cohesion\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var cohesion = birds.reduce(function (param, b) {\n        if (_this2.po.distanceTo(b.po) < Bird.cDist) {\n          param.sum.add(b.po);\n          param.count++;\n        }\n        return param;\n      }, { sum: new _vector2.default(), count: 0, force: new _vector2.default() });\n\n      if (cohesion.count > 0) {\n\n        this.ac.add(cohesion.sum.divideScalar(cohesion.count).sub(this.po).normalize().multiplyScalar(Bird.MAX_SPEED).sub(this.ve));\n      }\n\n      // alignment\n      var alignment = birds.reduce(function (param, b) {\n        if (_this2.po.distanceTo(b.po) < Bird.aDist) {\n          param.sum.add(b.ve);\n          param.count++;\n        }\n        return param;\n      }, { sum: new _vector2.default(), count: 0, force: new _vector2.default() });\n\n      if (alignment.count > 0) {\n        this.ac.add(alignment.sum.divideScalar(alignment.count).normalize().multiplyScalar(Bird.MAX_SPEED).sub(this.ve));\n      }\n\n      if (this.ac.length > Bird.MAX_FORCE) this.ac.normalize().multiplyScalar(Bird.MAX_FORCE);\n      if (this.ve.length > Bird.MAX_SPEED) this.ve.normalize().multiplyScalar(Bird.MAX_SPEED);\n\n      this.ve.add(this.ac.divideScalar(this.mass));\n      this.po.add(this.ve);\n\n      this.polygon.x = this.po.x;\n      this.polygon.y = this.po.y;\n      this.polygon.rotation = this.ve.angle / Math.PI * 180;\n\n      if (this.po.x > stage.width) {\n        this.po.x = stage.width;\n        this.ve.x *= -1;\n      } else if (this.po.x < 0) {\n        this.po.x = 0;\n        this.ve.x *= -1;\n      }\n\n      if (this.po.y > stage.height) {\n        this.po.y = stage.height;\n        this.ve.y *= -1;\n      } else if (this.po.y < 0) {\n        this.po.y = 0;\n        this.ve.y *= -1;\n      }\n    }\n  }]);\n\n  return Bird;\n}(_cax2.default.Group), _class.MAX_SPEED = 5, _class.MAX_FORCE = .1, _class.sDist = 18, _class.cDist = 80, _class.aDist = 60, _temp);\nexports.default = Bird;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYmlyZC5qcz82OTk1Il0sIm5hbWVzIjpbIkJpcmQiLCJtYXNzIiwicG9seWdvbiIsIkdyYXBoaWNzIiwiZmlsbFN0eWxlIiwiTWF0aCIsInJhbmRvbSIsImJlZ2luUGF0aCIsIm1vdmVUbyIsImxpbmVUbyIsImNsb3NlUGF0aCIsImZpbGwiLCJhZGQiLCJwbyIsInZlIiwiYWMiLCJzdGFnZSIsImJpcmRzIiwiZmlsdGVyIiwibyIsImJpcmQiLCJkaXN0YW5jZVRvIiwic0Rpc3QiLCJzdWIiLCJjbG9uZSIsIm5vcm1hbGl6ZSIsIm11bHRpcGx5U2NhbGFyIiwiTUFYX1NQRUVEIiwiY29oZXNpb24iLCJyZWR1Y2UiLCJwYXJhbSIsImIiLCJjRGlzdCIsInN1bSIsImNvdW50IiwiZm9yY2UiLCJkaXZpZGVTY2FsYXIiLCJhbGlnbm1lbnQiLCJhRGlzdCIsImxlbmd0aCIsIk1BWF9GT1JDRSIsIngiLCJ5Iiwicm90YXRpb24iLCJhbmdsZSIsIlBJIiwid2lkdGgiLCJoZWlnaHQiLCJHcm91cCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7SUFDcUJBLEk7OztBQVFuQixrQkFBbUI7QUFBQSxRQUFQQyxJQUFPLHVFQUFGLENBQUU7O0FBQUE7O0FBQUE7O0FBRWpCLFVBQUtDLE9BQUwsR0FBZSxJQUFJLGNBQUlDLFFBQVIsRUFBZjtBQUNBLFVBQUtELE9BQUwsQ0FDQ0UsU0FERCxXQUNrQixJQUFFQyxLQUFLQyxNQUFMLEtBQWMsRUFEbEMsaUJBRUNDLFNBRkQsR0FHQ0MsTUFIRCxDQUdRLEVBSFIsRUFHWSxDQUhaLEVBSUNDLE1BSkQsQ0FJUSxDQUFDLEVBSlQsRUFJYSxDQUpiLEVBS0NBLE1BTEQsQ0FLUSxDQUFDLEVBTFQsRUFLYSxDQUFDLENBTGQsRUFNQ0EsTUFORCxDQU1RLEVBTlIsRUFNWSxDQU5aLEVBT0NDLFNBUEQsR0FRQ0MsSUFSRDs7QUFVQSxVQUFLQyxHQUFMLENBQVMsTUFB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LENBQVIsSUFBYSxDQUFDLENBQWQ7QUFFRCxPQUpELE1BSU8sSUFBRyxLQUFLN0IsRUFBTCxDQUFRNkIsQ0FBUixHQUFZLENBQWYsRUFBaUI7QUFDdEIsYUFBSzdCLEVBQUwsQ0FBUTZCLENBQVIsR0FBWSxDQUFaO0FBQ0EsYUFBSzVCLEVBQUwsQ0FBUTRCLENBQVIsSUFBYSxDQUFDLENBQWQ7QUFDRDtBQUVGOzs7O0VBL0crQixjQUFJTSxLLFVBRTdCckIsUyxHQUFZLEMsU0FDWmEsUyxHQUFZLEUsU0FDWmxCLEssR0FBUSxFLFNBQ1JVLEssR0FBUSxFLFNBQ1JNLEssR0FBUSxFO2tCQU5JdEMsSSIsImZpbGUiOiIuL3NyYy9iaXJkLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNheCBmcm9tICdjYXgnXHJcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi92ZWN0b3InXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJpcmQgZXh0ZW5kcyBjYXguR3JvdXB7XHJcblxyXG4gIHN0YXRpYyBNQVhfU1BFRUQgPSA1XHJcbiAgc3RhdGljIE1BWF9GT1JDRSA9IC4xXHJcbiAgc3RhdGljIHNEaXN0ID0gMThcclxuICBzdGF0aWMgY0Rpc3QgPSA4MFxyXG4gIHN0YXRpYyBhRGlzdCA9IDYwXHJcblxyXG4gIGNvbnN0cnVjdG9yKG1hc3M9MSl7XHJcbiAgICBzdXBlcigpXHJcbiAgICB0aGlzLnBvbHlnb24gPSBuZXcgY2F4LkdyYXBoaWNzKClcclxuICAgIHRoaXMucG9seWdvblxyXG4gICAgLmZpbGxTdHlsZShgaHNsKCR7MCtNYXRoLnJhbmRvbSgpKjMwfSw3NSUsNzUlKWApXHJcbiAgICAuYmVnaW5QYXRoKClcclxuICAgIC5tb3ZlVG8oMTAsIDApXHJcbiAgICAubGluZVRvKC0xMCwgOClcclxuICAgIC5saW5lVG8oLTEwLCAtOClcclxuICAgIC5saW5lVG8oMTAsIDApXHJcbiAgICAuY2xvc2VQYXRoKClcclxuICAgIC5maWxsKClcclxuXHJcbiAgICB0aGlzLmFkZCh0aGlzLnBvbHlnb24pXHJcblxyXG4gICAgdGhpcy5wbyA9IG5ldyBWZWN0b3IoKVxyXG4gICAgdGhpcy52ZSA9IG5ldyBWZWN0b3IoKVxyXG4gICAgdGhpcy5hYyA9IG5ldyBWZWN0b3IoKVxyXG5cclxuICAgIHRoaXMubWFzcyA9IG1hc3NcclxuXHJcbiAgfVxyXG4gIHVwZGF0ZShzdGFnZSwgYmlyZHMpe1xyXG5cclxuICAgIGJpcmRzID0gYmlyZHMuZmlsdGVyKG89PnRoaXMhPW8pXHJcblxyXG4gICAgLy8gc2VwYXJhdGlvblxyXG4gICAgZm9yKGxldCBiaXJkIG9mIGJpcmRzKXtcclxuICAgICAgaWYodGhpcy5wby5kaXN0YW5jZVRvKGJpcmQucG8pIDwgQmlyZC5zRGlzdCl7XHJcblxyXG4gICAgICAgIHRoaXMuYWMuc3ViKFxyXG4gICAgICAgICAgYmlyZC5wby5jbG9uZSgpXHJcbiAgICAgICAgICAuc3ViKHRoaXMucG8pLm5vcm1hbGl6ZSgpXHJcbiAgICAgICAgICAubXVsdGlwbHlTY2FsYXIoQmlyZC5NQVhfU1BFRUQpXHJcbiAgICAgICAgICAuc3ViKHRoaXMudmUpXHJcbiAgICAgICAgKVxyXG4gICAgICB9IFxyXG4gICAgfVxyXG4gICAgICBcclxuICAgIC8vIGNvaGVzaW9uXHJcbiAgICBsZXQgY29oZXNpb24gPSAgYmlyZHMucmVkdWNlKChwYXJhbSwgYik9PntcclxuICAgICAgaWYodGhpcy5wby5kaXN0YW5jZVRvKGIucG8pIDwgQmlyZC5jRGlzdCl7XHJcbiAgICAgICAgcGFyYW0uc3VtLmFkZChiLnBvKVxyXG4gICAgICAgIHBhcmFtLmNvdW50KytcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcGFyYW1cclxuICAgIH0se3N1bTpuZXcgVmVjdG9yKCksY291bnQ6MCxmb3JjZTpuZXcgVmVjdG9yKCl9KVxyXG5cclxuICAgIGlmKGNvaGVzaW9uLmNvdW50PjApe1xyXG5cclxuICAgICAgdGhpcy5hYy5hZGQoXHJcbiAgICAgICAgY29oZXNpb24uc3VtLmRpdmlkZVNjYWxhcihjb2hlc2lvbi5jb3VudClcclxuICAgICAgICAuc3ViKHRoaXMucG8pLm5vcm1hbGl6ZSgpXHJcbiAgICAgICAgLm11bHRpcGx5U2NhbGFyKEJpcmQuTUFYX1NQRUVEKVxyXG4gICAgICAgIC5zdWIodGhpcy52ZSlcclxuICAgICAgKVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBhbGlnbm1lbnRcclxuICAgIGxldCBhbGlnbm1lbnQgPSAgYmlyZHMucmVkdWNlKChwYXJhbSwgYik9PntcclxuICAgICAgaWYodGhpcy5wby5kaXN0YW5jZVRvKGIucG8pIDwgQmlyZC5hRGlzdCl7XHJcbiAgICAgICAgcGFyYW0uc3VtLmFkZChiLnZlKVxyXG4gICAgICAgIHBhcmFtLmNvdW50KytcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcGFyYW1cclxuICAgIH0se3N1bTpuZXcgVmVjdG9yKCksY291bnQ6MCxmb3JjZTpuZXcgVmVjdG9yKCl9KVxyXG5cclxuICAgIGlmKGFsaWdubWVudC5jb3VudD4wKXtcclxuICAgICAgdGhpcy5hYy5hZGQoXHJcbiAgICAgICAgYWxpZ25tZW50LnN1bS5kaXZpZGVTY2FsYXIoYWxpZ25tZW50LmNvdW50KS5ub3JtYWxpemUoKVxyXG4gICAgICAgIC5tdWx0aXBseVNjYWxhcihCaXJkLk1BWF9TUEVFRCkuc3ViKHRoaXMudmUpIFxyXG4gICAgICApXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmKHRoaXMuYWMubGVuZ3RoID4gQmlyZC5NQVhfRk9SQ0UpIHRoaXMuYWMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoQmlyZC5NQVhfRk9SQ0UpXHJcbiAgICBpZih0aGlzLnZlLmxlbmd0aCA+IEJpcmQuTUFYX1NQRUVEKSB0aGlzLnZlLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKEJpcmQuTUFYX1NQRUVEKVxyXG5cclxuICAgIHRoaXMudmUuYWRkKHRoaXMuYWMuZGl2aWRlU2NhbGFyKHRoaXMubWFzcykpXHJcbiAgICB0aGlzLnBvLmFkZCh0aGlzLnZlKVxyXG5cclxuICAgIHRoaXMucG9seWdvbi54ID0gdGhpcy5wby54XHJcbiAgICB0aGlzLnBvbHlnb24ueSA9IHRoaXMucG8ueVxyXG4gICAgdGhpcy5wb2x5Z29uLnJvdGF0aW9uID0gdGhpcy52ZS5hbmdsZS9NYXRoLlBJKjE4MFxyXG4gICAgXHJcbiAgICBpZih0aGlzLnBvLnggPiBzdGFnZS53aWR0aCl7XHJcbiAgICAgIHRoaXMucG8ueCA9IHN0YWdlLndpZHRoXHJcbiAgICAgIHRoaXMudmUueCAqPSAtMVxyXG4gICAgfSBlbHNlIGlmKHRoaXMucG8ueCA8IDApe1xyXG4gICAgICB0aGlzLnBvLnggPSAwXHJcbiAgICAgIHRoaXMudmUueCAqPSAtMVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZih0aGlzLnBvLnkgPiBzdGFnZS5oZWlnaHQpe1xyXG4gICAgICB0aGlzLnBvLnkgPSBzdGFnZS5oZWlnaHRcclxuICAgICAgdGhpcy52ZS55ICo9IC0xXHJcblxyXG4gICAgfSBlbHNlIGlmKHRoaXMucG8ueSA8IDApe1xyXG4gICAgICB0aGlzLnBvLnkgPSAwXHJcbiAgICAgIHRoaXMudmUueSAqPSAtMVxyXG4gICAgfVxyXG5cclxuICB9XHJcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/bird.js\n");

/***/ }),

/***/ "./src/flocking.js":
/*!*************************!*\
  !*** ./src/flocking.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Flocking;\n\nvar _bird = __webpack_require__(/*! ./bird */ \"./src/bird.js\");\n\nvar _bird2 = _interopRequireDefault(_bird);\n\nvar _vector = __webpack_require__(/*! ./vector */ \"./src/vector.js\");\n\nvar _vector2 = _interopRequireDefault(_vector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// debugger\nfunction Flocking(stage) {\n  exports.default = Flocking = {\n    update: function update() {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.birds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var bird = _step.value;\n          bird.update(stage, this.birds);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    },\n    birds: [],\n    initial: function initial() {\n      var rd = Math.random;\n      this.birds = Array.from({ length: 70 }, function (v, i) {\n        var bird = new _bird2.default();\n        stage.add(bird);\n        //bird.po =\n        Object.assign(bird, {\n          po: new _vector2.default(stage.width * rd(), stage.height * rd()),\n          ve: new _vector2.default(Math.random() * 20 - 10, Math.random() * 20 - 10),\n          ac: new _vector2.default(),\n          mass: 1\n        });\n\n        return bird;\n      });\n    }\n  };\n  Flocking.initial();\n  return Flocking;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZmxvY2tpbmcuanM/NTIwNiJdLCJuYW1lcyI6WyJGbG9ja2luZyIsInN0YWdlIiwidXBkYXRlIiwiYmlyZHMiLCJiaXJkIiwiaW5pdGlhbCIsInJkIiwiTWF0aCIsInJhbmRvbSIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsInYiLCJpIiwiYWRkIiwiT2JqZWN0IiwiYXNzaWduIiwicG8iLCJ3aWR0aCIsImhlaWdodCIsInZlIiwiYWMiLCJtYXNzIl0sIm1hcHBpbmdzIjoiOzs7OztrQkFJd0JBLFE7O0FBSnhCOzs7O0FBQ0E7Ozs7OztBQUVBO0FBQ2UsU0FBU0EsUUFBVCxDQUFrQkMsS0FBbEIsRUFBd0I7QUFDckMsK0JBQVc7QUFDVEMsVUFEUyxvQkFDRDtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUNOLDZCQUFnQixLQUFLQyxLQUFyQjtBQUFBLGNBQVFDLElBQVI7QUFBNEJBLGVBQUtGLE1BQUwsQ0FBWUQsS0FBWixFQUFtQixLQUFLRSxLQUF4QjtBQUE1QjtBQURNO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHUCxLQUpRO0FBS1JBLFdBQU8sRUFMQztBQU1SRSxXQU5RLHFCQU1DO0FBQ1IsVUFBSUMsS0FBS0MsS0FBS0MsTUFBZDtBQUNBLFdBQUtMLEtBQUwsR0FBYU0sTUFBTUMsSUFBTixDQUFXLEVBQUNDLFFBQU8sRUFBUixFQUFYLEVBQXVCLFVBQUNDLENBQUQsRUFBR0MsQ0FBSCxFQUFPO0FBQ3pDLFlBQUlULE9BQU8sb0JBQVg7QUFDQUgsY0FBTWEsR0FBTixDQUFVVixJQUFWO0FBQ0E7QUFDQVcsZUFBT0MsTUFBUCxDQUFjWixJQUFkLEVBQW1CO0FBQ2pCYSxjQUFJLHFCQUFXaEIsTUFBTWlCLEtBQU4sR0FBWVosSUFBdkIsRUFBNEJMLE1BQU1rQixNQUFOLEdBQWFiLElBQXpDLENBRGE7QUFFaEJjLGNBQUkscUJBQVdiLEtBQUtDLE1BQUwsS0FBZ0IsRUFBaEIsR0FBcUIsRUFBaEMsRUFBb0NELEtBQUtDLE1BQUwsS0FBZ0IsRUFBaEIsR0FBcUIsRUFBekQsQ0FGWTtBQUdoQmEsY0FBSSxzQkFIWTtBQUloQkMsZ0JBQU07QUFKVSxTQUFuQjs7QUFPQSxlQUFPbEIsSUFBUDtBQUNELE9BWlksQ0FBYjtBQWFEO0FBckJRLEdBQVg7QUF1QkFKLFdBQVNLLE9BQVQ7QUFDQSxTQUFPTCxRQUFQO0FBQ0QiLCJmaWxlIjoiLi9zcmMvZmxvY2tpbmcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQmlyZCBmcm9tICcuL2JpcmQnXHJcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi92ZWN0b3InXHJcblxyXG4vLyBkZWJ1Z2dlclxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG9ja2luZyhzdGFnZSl7XHJcbiAgRmxvY2tpbmcgPSB7XHJcbiAgICB1cGRhdGUoKXtcclxuICAgICAgZm9yKGxldCBiaXJkIG9mIHRoaXMuYmlyZHMpIGJpcmQudXBkYXRlKHN0YWdlLCB0aGlzLmJpcmRzKVxyXG4gICAgICBcclxuICAgIH1cclxuICAgICxiaXJkczogW11cclxuICAgICxpbml0aWFsKCl7XHJcbiAgICAgIHZhciByZCA9IE1hdGgucmFuZG9tXHJcbiAgICAgIHRoaXMuYmlyZHMgPSBBcnJheS5mcm9tKHtsZW5ndGg6NzB9LCh2LGkpPT57XHJcbiAgICAgICAgdmFyIGJpcmQgPSBuZXcgQmlyZCgpXHJcbiAgICAgICAgc3RhZ2UuYWRkKGJpcmQpXHJcbiAgICAgICAgLy9iaXJkLnBvID1cclxuICAgICAgICBPYmplY3QuYXNzaWduKGJpcmQse1xyXG4gICAgICAgICAgcG86IG5ldyBWZWN0b3Ioc3RhZ2Uud2lkdGgqcmQoKSxzdGFnZS5oZWlnaHQqcmQoKSlcclxuICAgICAgICAgICx2ZTogbmV3IFZlY3RvcihNYXRoLnJhbmRvbSgpICogMjAgLSAxMCwgTWF0aC5yYW5kb20oKSAqIDIwIC0gMTApXHJcbiAgICAgICAgICAsYWM6IG5ldyBWZWN0b3IoKVxyXG4gICAgICAgICAgLG1hc3M6IDFcclxuICAgICAgICB9KSBcclxuXHJcbiAgICAgICAgcmV0dXJuIGJpcmRcclxuICAgICAgfSlcclxuICAgIH1cclxuICB9XHJcbiAgRmxvY2tpbmcuaW5pdGlhbCgpXHJcbiAgcmV0dXJuIEZsb2NraW5nXHJcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/flocking.js\n");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _cax = __webpack_require__(/*! cax */ \"./node_modules/.1.2.9@cax/dist/cax.js\");\n\nvar _cax2 = _interopRequireDefault(_cax);\n\n__webpack_require__(/*! ./main.less */ \"./src/main.less\");\n\nvar _flocking = __webpack_require__(/*! ./flocking */ \"./src/flocking.js\");\n\nvar _flocking2 = _interopRequireDefault(_flocking);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar stage = new _cax2.default.Stage(document.body.offsetWidth, document.body.offsetHeight, 'body');\n\nvar flocking = (0, _flocking2.default)(stage);\n\n_cax2.default.tick(function () {\n  stage.update();\n  flocking.update(stage);\n  // debugger\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz81NmQ3Il0sIm5hbWVzIjpbInN0YWdlIiwiU3RhZ2UiLCJkb2N1bWVudCIsImJvZHkiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsImZsb2NraW5nIiwidGljayIsInVwZGF0ZSJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7OztBQUNBOztBQUNBOzs7Ozs7QUFHQSxJQUFJQSxRQUFRLElBQUksY0FBSUMsS0FBUixDQUFjQyxTQUFTQyxJQUFULENBQWNDLFdBQTVCLEVBQXdDRixTQUFTQyxJQUFULENBQWNFLFlBQXRELEVBQW1FLE1BQW5FLENBQVo7O0FBRUEsSUFBSUMsV0FBVyx3QkFBU04sS0FBVCxDQUFmOztBQUVBLGNBQUlPLElBQUosQ0FBUyxZQUFJO0FBQ1hQLFFBQU1RLE1BQU47QUFDQUYsV0FBU0UsTUFBVCxDQUFnQlIsS0FBaEI7QUFDQTtBQUNELENBSkQiLCJmaWxlIjoiLi9zcmMvbWFpbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjYXggZnJvbSAnY2F4J1xyXG5pbXBvcnQgJy4vbWFpbi5sZXNzJ1xyXG5pbXBvcnQgRmxvY2tpbmcgZnJvbSAnLi9mbG9ja2luZydcclxuXHJcblxyXG52YXIgc3RhZ2UgPSBuZXcgY2F4LlN0YWdlKGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGgsZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQsJ2JvZHknKVxyXG5cclxudmFyIGZsb2NraW5nID0gRmxvY2tpbmcoc3RhZ2UpXHJcblxyXG5jYXgudGljaygoKT0+e1xyXG4gIHN0YWdlLnVwZGF0ZSgpXHJcbiAgZmxvY2tpbmcudXBkYXRlKHN0YWdlKVxyXG4gIC8vIGRlYnVnZ2VyXHJcbn0pIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/main.js\n");

/***/ }),

/***/ "./src/main.less":
/*!***********************!*\
  !*** ./src/main.less ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../node_modules/css-loader!../../node_modules/postcss-loader/lib??ref--5-2!../../node_modules/less-loader/dist/cjs.js!./main.less */ \"../node_modules/css-loader/index.js!../node_modules/postcss-loader/lib/index.js??ref--5-2!../node_modules/less-loader/dist/cjs.js!./src/main.less\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ \"../node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5sZXNzP2E3ODgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7QUFJQSxlQUFlOztBQUVmO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEiLCJmaWxlIjoiLi9zcmMvbWFpbi5sZXNzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tNS0yIS4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL21haW4ubGVzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS01LTIhLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbWFpbi5sZXNzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS01LTIhLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbWFpbi5sZXNzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/main.less\n");

/***/ }),

/***/ "./src/vector.js":
/*!***********************!*\
  !*** ./src/vector.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// distanceTo\n// add\n// divideScalar\n// sub\n// normalize\n// multiplyScalar\n// length\n\nvar s = Math.sin,\n    c = Math.cos,\n    sqrt = Math.sqrt,\n    pow = Math.pow,\n    PI = Math.PI,\n    atan2 = Math.atan2;\n\nvar Vector = function () {\n  function Vector() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, Vector);\n\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  _createClass(Vector, [{\n    key: \"distanceTo\",\n    value: function distanceTo(v2) {\n\n      return sqrt(pow(this.x - v2.x, 2) + pow(this.y - v2.y, 2) + pow(this.z - v2.z, 2));\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Vector(this.x, this.y, this.z);\n    }\n  }, {\n    key: \"add\",\n    value: function add(v2) {\n      this.x += v2.x;\n      this.y += v2.y;\n      this.z += v2.z;\n      return this;\n    }\n  }, {\n    key: \"sub\",\n    value: function sub(v2) {\n      this.x -= v2.x;\n      this.y -= v2.y;\n      this.z -= v2.z;\n      return this;\n    }\n  }, {\n    key: \"divideScalar\",\n    value: function divideScalar(v) {\n      if (v === 0) v = 1;\n      this.x /= v;\n      this.y /= v;\n      this.z /= v;\n      return this;\n    }\n  }, {\n    key: \"multiplyScalar\",\n    value: function multiplyScalar(v) {\n      this.x *= v;\n      this.y *= v;\n      this.z *= v;\n      return this;\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      // debugger\n      return this.divideScalar(this.length);\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return sqrt(pow(this.x, 2) + pow(this.y, 2) + pow(this.z, 2));\n    }\n  }, {\n    key: \"angle\",\n    get: function get() {\n      return atan2(this.y, this.x);\n    }\n  }]);\n\n  return Vector;\n}();\n\nexports.default = Vector;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yLmpzPzM0MTMiXSwibmFtZXMiOlsicyIsIk1hdGgiLCJzaW4iLCJjIiwiY29zIiwic3FydCIsInBvdyIsIlBJIiwiYXRhbjIiLCJWZWN0b3IiLCJ4IiwieSIsInoiLCJ2MiIsInYiLCJkaXZpZGVTY2FsYXIiLCJsZW5ndGgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFNQSxJQUFJQyxLQUFLQyxHQUFmO0FBQUEsSUFBb0JDLElBQUlGLEtBQUtHLEdBQTdCO0FBQUEsSUFBa0NDLE9BQU9KLEtBQUtJLElBQTlDO0FBQUEsSUFBb0RDLE1BQU1MLEtBQUtLLEdBQS9EO0FBQUEsSUFBb0VDLEtBQUtOLEtBQUtNLEVBQTlFO0FBQUEsSUFBa0ZDLFFBQVFQLEtBQUtPLEtBQS9GOztJQUNxQkMsTTtBQUNuQixvQkFBd0I7QUFBQSxRQUFaQyxDQUFZLHVFQUFWLENBQVU7QUFBQSxRQUFSQyxDQUFRLHVFQUFOLENBQU07QUFBQSxRQUFKQyxDQUFJLHVFQUFGLENBQUU7O0FBQUE7O0FBQ3RCLFNBQUtGLENBQUwsR0FBU0EsQ0FBVDtBQUNBLFNBQUtDLENBQUwsR0FBU0EsQ0FBVDtBQUNBLFNBQUtDLENBQUwsR0FBU0EsQ0FBVDtBQUNEOzs7OytCQU9VQyxFLEVBQUc7O0FBRVosYUFBT1IsS0FBS0MsSUFBSSxLQUFLSSxDQUFMLEdBQVNHLEdBQUdILENBQWhCLEVBQWtCLENBQWxCLElBQXVCSixJQUFJLEtBQUtLLENBQUwsR0FBT0UsR0FBR0YsQ0FBZCxFQUFnQixDQUFoQixDQUF2QixHQUE0Q0wsSUFBSSxLQUFLTSxDQUFMLEdBQU9DLEdBQUdELENBQWQsRUFBZ0IsQ0FBaEIsQ0FBakQsQ0FBUDtBQUVEOzs7NEJBQ007QUFDTCxhQUFPLElBQUlILE1BQUosQ0FBVyxLQUFLQyxDQUFoQixFQUFrQixLQUFLQyxDQUF2QixFQUF5QixLQUFLQyxDQUE5QixDQUFQO0FBQ0Q7Ozt3QkFDR0MsRSxFQUFHO0FBQ0wsV0FBS0gsQ0FBTCxJQUFVRyxHQUFHSCxDQUFiO0FBQ0EsV0FBS0MsQ0FBTCxJQUFVRSxHQUFHRixDQUFiO0FBQ0EsV0FBS0MsQ0FBTCxJQUFVQyxHQUFHRCxDQUFiO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7Ozt3QkFDR0MsRSxFQUFHO0FBQ0wsV0FBS0gsQ0FBTCxJQUFVRyxHQUFHSCxDQUFiO0FBQ0EsV0FBS0MsQ0FBTCxJQUFVRSxHQUFHRixDQUFiO0FBQ0EsV0FBS0MsQ0FBTCxJQUFVQyxHQUFHRCxDQUFiO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7OztpQ0FDWUUsQyxFQUFFO0FBQ2IsVUFBR0EsTUFBTSxDQUFULEVBQVlBLElBQUksQ0FBSjtBQUNaLFdBQUtKLENBQUwsSUFBVUksQ0FBVjtBQUNBLFdBQUtILENBQUwsSUFBVUcsQ0FBVjtBQUNBLFdBQUtGLENBQUwsSUFBVUUsQ0FBVjtBQUNBLGFBQU8sSUFBUDtBQUNEOzs7bUNBQ2NBLEMsRUFBRTtBQUNmLFdBQUtKLENBQUwsSUFBVUksQ0FBVjtBQUNBLFdBQUtILENBQUwsSUFBVUcsQ0FBVjtBQUNBLFdBQUtGLENBQUwsSUFBVUUsQ0FBVjtBQUNBLGFBQU8sSUFBUDtBQUNEOzs7Z0NBQ1U7QUFDVDtBQUNBLGFBQU8sS0FBS0MsWUFBTCxDQUFrQixLQUFLQyxNQUF2QixDQUFQO0FBQ0Q7Ozt3QkExQ1c7QUFDVixhQUFPWCxLQUFLQyxJQUFJLEtBQUtJLENBQVQsRUFBVyxDQUFYLElBQWNKLElBQUksS0FBS0ssQ0FBVCxFQUFXLENBQVgsQ0FBZCxHQUE0QkwsSUFBSSxLQUFLTSxDQUFULEVBQVcsQ0FBWCxDQUFqQyxDQUFQO0FBQ0Q7Ozt3QkFDVTtBQUNULGFBQU9KLE1BQU0sS0FBS0csQ0FBWCxFQUFjLEtBQUtELENBQW5CLENBQVA7QUFDRDs7Ozs7O2tCQVhrQkQsTSIsImZpbGUiOiIuL3NyYy92ZWN0b3IuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcclxuLy8gZGlzdGFuY2VUb1xyXG4vLyBhZGRcclxuLy8gZGl2aWRlU2NhbGFyXHJcbi8vIHN1YlxyXG4vLyBub3JtYWxpemVcclxuLy8gbXVsdGlwbHlTY2FsYXJcclxuLy8gbGVuZ3RoXHJcblxyXG5jb25zdCBzID0gTWF0aC5zaW4sIGMgPSBNYXRoLmNvcywgc3FydCA9IE1hdGguc3FydCwgcG93ID0gTWF0aC5wb3csIFBJID0gTWF0aC5QSSwgYXRhbjIgPSBNYXRoLmF0YW4yXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlY3RvcntcclxuICBjb25zdHJ1Y3Rvcih4PTAseT0wLHo9MCl7XHJcbiAgICB0aGlzLnggPSB4XHJcbiAgICB0aGlzLnkgPSB5XHJcbiAgICB0aGlzLnogPSB6XHJcbiAgfVxyXG4gIGdldCBsZW5ndGgoKXtcclxuICAgIHJldHVybiBzcXJ0KHBvdyh0aGlzLngsMikrcG93KHRoaXMueSwyKStwb3codGhpcy56LDIpKVxyXG4gIH1cclxuICBnZXQgYW5nbGUoKXtcclxuICAgIHJldHVybiBhdGFuMih0aGlzLnksIHRoaXMueClcclxuICB9XHJcbiAgZGlzdGFuY2VUbyh2Mil7XHJcbiAgICBcclxuICAgIHJldHVybiBzcXJ0KHBvdyh0aGlzLnggLSB2Mi54LDIpICsgcG93KHRoaXMueS12Mi55LDIpICsgcG93KHRoaXMuei12Mi56LDIpIClcclxuICAgIFxyXG4gIH1cclxuICBjbG9uZSgpe1xyXG4gICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54LHRoaXMueSx0aGlzLnopXHJcbiAgfVxyXG4gIGFkZCh2Mil7XHJcbiAgICB0aGlzLnggKz0gdjIueFxyXG4gICAgdGhpcy55ICs9IHYyLnlcclxuICAgIHRoaXMueiArPSB2Mi56XHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuICBzdWIodjIpe1xyXG4gICAgdGhpcy54IC09IHYyLnhcclxuICAgIHRoaXMueSAtPSB2Mi55XHJcbiAgICB0aGlzLnogLT0gdjIuelxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcbiAgZGl2aWRlU2NhbGFyKHYpe1xyXG4gICAgaWYodiA9PT0gMCkgdiA9IDFcclxuICAgIHRoaXMueCAvPSB2XHJcbiAgICB0aGlzLnkgLz0gdlxyXG4gICAgdGhpcy56IC89IHZcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG4gIG11bHRpcGx5U2NhbGFyKHYpe1xyXG4gICAgdGhpcy54ICo9IHZcclxuICAgIHRoaXMueSAqPSB2XHJcbiAgICB0aGlzLnogKj0gdlxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcbiAgbm9ybWFsaXplKCl7XHJcbiAgICAvLyBkZWJ1Z2dlclxyXG4gICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHRoaXMubGVuZ3RoKVxyXG4gIH1cclxuXHJcblxyXG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/vector.js\n");

/***/ })

/******/ });