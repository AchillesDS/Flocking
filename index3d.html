<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>flock</title>
  <style>
    *{margin: 0;padding: 0;}
    html,body{
      width:100%;height:100%;
    }
		#d1{
			width:100px;
			height:100px;
			border:1px solid black;
			display: none;
		}
  </style>
</head>
<body>
	<div id="d1"></div>
	<div id="wrap1">
			<!-- sepDist
			cohDist
			aliDist -->
			<!-- separation
alignment
cohesion -->
<!-- 
static sDist = 18
static cDist = 80
static aDist = 60 -->
		<!-- <p><label for="">separation</label> <input id="ipt_sep" type="range" min="0" max="100" value="40" step="1"></p>
		<p><label for="">alignment</label> <input id="ipt_coh" type="range" min="0" max="100" value="30" step="1"></p>
		<p><label for="">cohesion</label> <input id="ipt_ali" type="range" min="0" max="100" value="40" step="1"></p> -->
		<!-- <p><label for="">separation</label> <input id="ipt_sep" type="range" min="0" max="100" value="60" step="1"></p>
		<p><label for="">alignment</label> <input id="ipt_coh" type="range" min="0" max="100" value="80" step="1"></p>
		<p><label for="">cohesion</label> <input id="ipt_ali" type="range" min="0" max="100" value="60" step="1"></p> -->
		
	</div>
  <!-- <script src="cax.min.js"></script>
  <script src="./vector2D.js"></script>
  <script src="./vehicle.js"></script>
	<script src="./steered-vechicle.js"></script> -->
	
	<script src="/common/js/three-95.js"></script>
  <script src="/common/js/OrbitControls.js"></script>
  <!-- <script src="./THREEx.FullScreen.js"></script>
  <script src="./KeyboardState.js"></script> -->
  <!-- <script src="./Vector.js"></script> -->
  <!-- <script src="./Boid.js"></script> -->
  <script>

		// undefined is not an object (evaluating 'res['msg']['share'][item]['title']')|
		// url:http://www.xy.com/h5/game/play?gameid=37&from=wx&h5uid=87988768&come=&h5token=98d48a9446575b1ee7a6b96a0aceac3c|
		// row:421|col:54|
		// error:Array

		

		
    // function * generator() {
    //   yield 5;
    //   yield 6;
    // }

    // const gen = generator();

    // console.log(gen.next()); // {value: 5, done: false}
    // console.log(gen.next()); // {value: 5, done: false}


      // var addClassToEach = function*(elements, className){
      //   for (const el of Array.from(elements))
      //     yield el.classList.add(className);
      // }

      // const addClassToStrings = addClassToEach(document.querySelectorAll('.string'), 'addClassName');

      // document.querySelector('#btn').addEventListener('click', (el) => {
      //   if (addClassToStrings.next().done)

      //     console.log('3nd!!!!');
      //     //el.target.classList.add(className);
      // });
				
			

		// 	let {offsetWidth,offsetHeight} = document.body
    
    // let stage = new cax.Stage(offsetWidth, offsetHeight, 'body')
    // window.stage = stage
    // let mouseX,mouseY
    
    // let vehicleGroup = new cax.Group()
    // stage.add(vehicleGroup)

    //  // //  flock
    //   let _vehicles = []
    //   let _numVehicles = 100
    //   _vehicle = Array.from({length: _numVehicles},(v,i)=>{
    //     var vehicle = new SteeredVehicle();
		// 		vehicle.position = new Vector2D(Math.random() * stage.width, Math.random() * stage.height);
		// 		vehicle._velocity = new Vector2D(Math.random() * 20 - 10, Math.random() * 20 - 10);
		// 		// vehicle.edgeBehavior = Vehicle.BOUNCE;
    //     _vehicles.push(vehicle);
        
    //     vehicleGroup.add(vehicle)
        
    //     return vehicle
    //   })
    //   cax.tick(()=>{
    //     stage.update()
    //     _vehicle.forEach((vehicle, i)=>{
				
    //       _vehicles[i].flock(_vehicles, new Vector2D(stage.width*.5,stage.height*.5));
		// 		  _vehicles[i].update();
    //     })
    //   })



	// ///////////////////////////////
	// this.vfrom = new THREE.Vector3(0, 1, 0);
	// this.rot = new THREE.Euler(0, 0, 0);
	// update(){
	// 	this.vel.add(this.acc)
	// 	this.position.add(this.vel)

		
	// 	var quat = new THREE.Quaternion();
	// 	var v = new THREE.Vector3(this.vel.x, this.vel.y, this.vel.z);
	// 	v.normalize();
	// 	quat.setFromUnitVectors(this.vfrom, v);

	// 	this.rot.setFromQuaternion(quat);

	// 	this.rotation.x = this.rot.x
	// 	this.rotation.y = this.rot.y
	// 	this.rotation.z = this.rot.z
	
	// }
		
		let scene = new THREE.Scene()
		let camera = new THREE.PerspectiveCamera(45,innerWidth/innerHeight,.1,10000)
		let renderer = new THREE.WebGLRenderer()
		scene.fog = new THREE.FogExp2(0xcccccc, 0.0027);
		renderer.setClearColor(scene.fog.color)
		renderer.setSize(document.body.offsetWidth, document.body.offsetHeight)
		document.body.appendChild(renderer.domElement);

		let hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6)
		hemiLight.color.setHSL(0.6, 1, 0.6)
		hemiLight.groundColor.setHSL(0.095, 1, 0.75)
		hemiLight.position.set(0, 50, 0)
		scene.add(hemiLight)
		let hemiLightHelper = new THREE.HemisphereLightHelper(hemiLight, 10)
		scene.add(hemiLightHelper)
		let dirLight = new THREE.DirectionalLight(0xffffff, 1)
		dirLight.color.setHSL(0.1, 1, 0.95)
		dirLight.position.set(-1, 1.75, 1)
		dirLight.position.multiplyScalar(30)
		scene.add(dirLight)
		dirLight.castShadow = true
		dirLight.shadow.mapSize.width = 2048
		dirLight.shadow.mapSize.height = 2048
		let d = 50
		dirLight.shadow.camera.left = -d
		dirLight.shadow.camera.right = d
		dirLight.shadow.camera.top = d
		dirLight.shadow.camera.bottom = -d
		dirLight.shadow.camera.far = 3500
		dirLight.shadow.bias = -0.0001
	
		//clampLength
		// debugger
		camera.position.copy(new THREE.Vector3(0,0,.1))
		camera.lookAt(new THREE.Vector3(0,0,0))

		let controls = new THREE.OrbitControls(camera, renderer.domElement);
		controls.update()

		let constrain_spe = new THREE.Mesh(
			new THREE.SphereGeometry(700,50,50)
			,new THREE.MeshBasicMaterial({
				color:new THREE.Color().setRGB(0,0,0), wireframe:true 
				,side : THREE.DoubleSide
			})
		) 
		scene.add(constrain_spe)

		constrain_spe.position.set(0,0,0)
		
		let random = Math.random;


	// ipt_sep.addEventListener('change',e=>{
	// 	boids.forEach((boid)=>{
	// 		boid.sepDist = e.target.value*1
	// 	})
	// })
	// ipt_coh.addEventListener('change',e=>{

	// 	boids.forEach((boid)=>{
	// 		boid.cohDist = e.target.value*1
	// 	})
	// })
	// ipt_ali.addEventListener('change',e=>{

	// 	boids.forEach((boid)=>{
	// 		boid.aliDist = e.target.value*1
	// 	})
	// })

		class Boid extends THREE.Group{
			constructor(geo=new THREE.ConeGeometry( 3, 10, 3 )){
				super()
				// this.max_speed = 5
				// this.max_force = .1
				this.max_speed = 5/1.2
				this.max_force = .1
				
				
				// window.sepDist = 30;
				// window.cohDist = 25;
				// window.aliDist = 50;


				// this.sepDist = 20;
				// this.cohDist = 25;
				// this.aliDist = 50;
				
				//18,80,60
				this.sepDist = 50;
				this.cohDist = 100;
				this.aliDist = 70;
				

				this.ac = new THREE.Vector3()
				this.ve = new THREE.Vector3()
				this.rot = new THREE.Euler()
				// this.vfrom = new THREE.Vector3(0, 0, -1);
				this.vfrom = new THREE.Vector3(0, 1, 0);
				
				// var geometry = new THREE.ConeGeometry( 5, 20, 32 );
				// ConeGeometry(radius, height, radiusSegments, heightSegments, openEnded, thetaStart, thetaLength)
				this.el = new THREE.Mesh(
					geo
					,new THREE.MeshLambertMaterial({
						color:new THREE.Color().setHSL(Math.random() * 0.7, 0.75, 0.75)
					})
				)
				this.add(this.el)
				
				this.sharkFlag = false

			}
			seek(target){

				var desired_v = target.clone().sub(this.position).normalize()
				desired_v.multiplyScalar(this.sharkFlag? this.max_speed*2:this.max_speed)
				this.ac.add(desired_v.sub(this.ve).multiplyScalar(1))
			}
			flee(target){

				var desired_v = target.clone().sub(this.position).normalize()
				desired_v.multiplyScalar(this.sharkFlag? this.max_speed*2:this.max_speed)

				this.ac.sub(
					desired_v.sub(this.ve).multiplyScalar(1)
				)

				
			}
			update(boids, shark){
				//console.log(this.ve.length())
				
				// separation
				// alignment
				// cohesion
				
				this.sharkFlag = false
				
				//console.log(shark.position)

				if(shark.position.distanceTo(this.position)<80){
					this.sharkFlag = true
					this.flee(shark.position)

				}
				
				 {

					for(let i = 0; i < boids.length; i++){

						let dist = this.position.distanceTo(boids[i].position)
						// debugger
						if(dist > 0.001 && dist < this.sepDist*.5 && boids[i]!=this) {
							this.flee(boids[i].position)
						}
					}

					// let sum = new THREE.Vector3()
					// let count = 0
					// for(let i = 0; i < boids.length; i++){
						

					// 	let dist = this.position.distanceTo(boids[i].position)
					// 	// debugger
					// 	if(dist > 0.001 && dist < this.sepDist && boids[i]!=this) {
					// 		let diff = boids[i].position.clone().sub(this.position).normalize()
							
					// 		sum.add(diff ) 

					// 		++count
					// 	}
					// }
					// if(count){
					// 	//平均转向方向
					// 	sum.divideScalar(count)
					// 		//console.log(count)
					// 	//转向方向的最大速度
					// 	sum.normalize().multiplyScalar(this.max_speed);

					// 	sum.sub(this.ve)

					// 	let force = sum

					// 	this.ac.sub(force)

					// }
					

					 	// var count = 0;
						// var sum = new THREE.Vector3(0, 0, 0);
						
						// for(var i = 0; i != boids.length; i++) {
						// 		var dist = this.position.distanceTo(boids[i].position);
						// 		if(dist > 0.001 && dist < this.sepDist) {
						// 				var diff = this.position.clone()
						// 				diff.sub(boids[i].position);
						// 				diff.normalize();
						// 				diff.divideScalar(dist);
						// 				sum.add(diff);
						// 				count++;
						// 		}
						// }
						
						// if(count > 0) {
						// 		sum.divideScalar(count);
						// }
						
						// if(sum.x == 0 && sum.y == 0 && sum.z) {
						// 		return diff;
						// }
						
						// if(sum.length() > 0) {
						// 		sum.normalize();
						// 		sum.multiplyScalar(this.max_speed);
						// 		sum.sub(this.ve);

						// 		if(sum.length()>this.max_force) sum.normalize().multiplyScalar(this.max_force)

						// }

						// this.ac.add(sum)

				}


				{
					//alignment 对准，一个大致方向的转向力
					let count = 0;
					let sum = new THREE.Vector3()
					
					for(let i = 0; i < boids.length; i++){
						let dist = this.position.distanceTo(  boids[i].position)
						if(dist > 0.001 && dist < this.aliDist && boids[i]!=this) {
							sum.add(boids[i].ve)
							++count
						}
					}
					
					let force
					if(count > 0) {
						sum.divideScalar(count).normalize()
						sum.multiplyScalar(this.max_speed)
						//这个转向力=平均期望的方向-当前速度
						sum.sub(this.ve)
						force = sum
					} else {
						force = new THREE.Vector3()
					}

					this.ac.add(force)
					
				}
				
				{
					//cohesion 凝聚，往一个平均位置seek
					let count = 0;
					let sum = new THREE.Vector3(0);
					
					for(let i = 0; i < boids.length; i++){
						let dist = this.position.distanceTo(boids[i].position)
						
						let d = this.sharkFlag?this.coDist*1:this.coDist*2
						if(dist > 0.001 && dist < d && boids[i]!=this) {
							//累计相对位置
							sum.add(boids[i].position);
							++count
						}
							
					}
					// let force;
					if(count > 0) {
						//求出平均
						sum.divideScalar(count);

						this.seek(sum)
						// w往平均位置seek追向，凝聚起来，返回凝聚转向向量
					}
					
					
				// console.log(count)
				}
				
				if(this.ac.length()>this.max_force){
					// clampLength
					this.ac = this.ac.normalize().multiplyScalar(this.sharkFlag?this.max_force*2:this.max_force)
				}
				if(this.ve.length()>this.max_speed){
					this.ve = this.ve.normalize().multiplyScalar(this.sharkFlag?this.max_speed*2:this.max_speed)
				}
				
				//console.log(this.ve.length())
				//if(this.isShark){
					// debugger
				this.ve.add(this.ac)
				this.position.add(this.ve)
				//}
				
				this.seek(this.target)
			//	console.log(this.position)
				

				var quat = new THREE.Quaternion();
				var v = new THREE.Vector3(this.ve.x, this.ve.y, this.ve.z);
				v.normalize();
				quat.setFromUnitVectors(this.vfrom, v);

				this.rot.setFromQuaternion(quat);

				this.rotation.x = this.rot.x
				this.rotation.y = this.rot.y
				this.rotation.z = this.rot.z
			}
		}
		
		var target = new THREE.Vector3(0,0,-300)

		{
			var shark = new THREE.Mesh(
				// new THREE.ConeGeometry( 10, 17, 3 )
				new THREE.SphereGeometry(6)
				,new THREE.MeshLambertMaterial({
					color:new THREE.Color().setRGB(1,0,0)
				})
			)
			scene.add(shark)
			shark.position.copy(
				target.clone().add(new THREE.Vector3(0,0,0)) 
			)
			shark.visible = false
			
		}
		


		let boids = [...Array(100)].map(()=>{
			let boid = new Boid()
			let l = 1
			boid.ac = new THREE.Vector3()
			boid.ve = new THREE.Vector3(l-random()*l*2,l-random()*l*2,l-random()*l*2)
			boid.position.copy(new THREE.Vector3(100-random()*200,0,-100))

			boid.target = target.clone()
			
			
			scene.add(boid)
			return boid
		})

	var p = 2,
    q = 5;
  // t *= Math.PI * 2;
  // var tx = (2 + Math.cos(q * t)) * Math.cos(p * t),
  //   ty = (2 + Math.cos(q * t)) * Math.sin(p * t),
  //   tz = Math.sin(q * t);

  // return new THREE.Vector3(tx, ty, tz).multiplyScalar(this.scale);


		// var relativeCameraOffset = new THREE.Vector3(0, -20, 0);
		// var cameraOffset = relativeCameraOffset.applyMatrix4(bgroup.children[0].matrixWorld);
		// camera.position.x = cameraOffset.x;
		// camera.position.y = cameraOffset.y;
		// camera.position.z = cameraOffset.z;
		// camera.lookAt(bgroup.children[0].position);

		var tracking = false
		requestAnimationFrame(function animate(){
			requestAnimationFrame(animate)
			renderer.render(scene,camera)
			
			var t = Date.now()*.0001;
			var target = new THREE.Vector3(
				(2 + Math.cos(q * t)) * Math.cos(p * t)
				,(2 + Math.cos(q * t)) * Math.sin(p * t)
				,Math.sin(q * t)
			).multiplyScalar(document.body.offsetWidth*.1).add(new THREE.Vector3(0,0,-200))

			boids.forEach((boid)=>{
				//console.log(boid)
				
				boid.target = target.clone()

				boid.update(boids,shark)

				shark.position.copy(
					target.clone()
				)
				
			})


			if(tracking){

				camera.position.copy(new THREE.Vector3(0, -100,0).applyMatrix4(boids[10].matrixWorld))

				camera.lookAt(boids[10].position)

			}
			
		})

		
	
	// ////////////////////////////////




// ////////////////////////////////////

// var camera, controls, scene, renderer, loader, stats, clock;

// var boids, sharks, bgroup, sgroup, target, targetvel, goahead, keyboard;

// var boidGeometry, boidMaterial, sharkGeometry, sharkMaterial;

// goahead = false;

// init();
// render();

// function animate() {
// 	requestAnimationFrame(animate);
// 	render();
// }

// function boidMouseUp() {
// 	boidCount = (document.querySelector('#BoidCount').value);
// 	document.querySelector('#BoidCountLabel').value = boidCount;
	
// 	if(boidCount > boids.length) {
// 		var count = boidCount - boids.length;
// 		for(var i = 0; i != count; i++) {
// 			addBoid();
// 		}
// 	} else if(boidCount < boids.length) {
// 		var count = boids.length - boidCount;
// 		for(var i = 0; i != count; i++) {
// 			removeBoid();
// 		}
// 	}
// }

// function sharkMouseUp() {
// 	sharkCount = (document.querySelector('#SharkCount').value);
// 	document.querySelector('#SharkCountLabel').value = sharkCount;
	
// 	if(sharkCount > sharks.length) {
// 		var count = sharkCount - sharks.length;
// 		for(var i = 0; i != count; i++) {
// 			addShark();
// 		}
// 	} else if(sharkCount < sharks.length) {
// 		var count = sharks.length - sharkCount;
// 		for(var i = 0; i != count; i++) {
// 			removeShark();
// 		}
// 	}
// }

// function disableOrbit() {
// 	controls.enabled = false;
// }

// function enableOrbit() {
// 	controls.enabled = true;
// }

// function init() {

// 	// THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
	
// 	trackingShark = false;
// 	trackingBoid = false;
// 	mouse = new THREE.Vector2();
	
// 	clock = new THREE.Clock();
	
// 	count = 0;
	
// 	camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
// 	camera.position.z = 100;

// 	setupOrbitControls();

// 	scene = new THREE.Scene();
// 	scene.fog = new THREE.FogExp2(0xcccccc, 0.0027);

// 	//keyboard = new THREEx.KeyboardState();
	
// 	var light1 = new THREE.DirectionalLight(0xeeeeee);
// 	light1.position.x = Math.random() - 0.5;
// 	light1.position.y = Math.random() - 0.5;
// 	light1.position.z = Math.random() - 0.5;
// 	light1.position.normalize();
// 	light1.intensity = 1.5;
// 	scene.add(light1);
	
// 	var light2 = new THREE.DirectionalLight(0xeeeeee);
// 	light2.position.x = Math.random() - 0.5;
// 	light2.position.y = Math.random() - 0.5;
// 	light2.position.z = Math.random() - 0.5;
// 	light2.position.normalize();
// 	light2.intensity = 1;
// 	scene.add(light2);
	
// 	renderer = new THREE.WebGLRenderer();
// 	renderer.setClearColor(scene.fog.color);
// 	renderer.setPixelRatio(window.devicePixelRatio);
// 	renderer.setSize(window.innerWidth, window.innerHeight);
// 	document.body.appendChild(renderer.domElement);

	
// 	window.addEventListener('resize', onWindowResize, false);
	
// 	target = new Vector(0, 0, 0);
// 	loadBoids1();
	
// 	addContext();

// 	animate();
// }


// function setupOrbitControls() {
// 	controls = new THREE.OrbitControls(camera);
// 	controls.damping = 0.2;
//     controls.addEventListener('change', render);
// }

// function setupFirstPersonControls() {
// 	controls = new THREE.FirstPersonControls(camera);
//     controls.lookSpeed = 0.3;
//     controls.movementSpeed = 50;
//     controls.noFly = true;
//     controls.lookVertical = true;
//     controls.constrainVertical = true;
//     controls.verticalMin = .1;
//     controls.verticalMax = 5;
//     controls.lon = -150;
//     controls.lat = 120;
// }

// function addContext() {
// 	var cubeGeometry = new THREE.SphereGeometry(500, 16, 16);
// 	var dashMaterial = new THREE.LineDashedMaterial( { color: 0x000000, dashSize: 2, gapSize: 3 } );
	
// 	var cube = new THREE.Line(geo2line(cubeGeometry), dashMaterial, THREE.LinePieces);
// 	cube.position.set(0, 0, 0);
// 	scene.add(cube);
// }

// function geo2line( geo ) // credit to WestLangley!
// {
//     var geometry = new THREE.Geometry();
//     var vertices = geometry.vertices;
	
// 	for ( i = 0; i < geo.faces.length; i++ ) 
// 	{
//         var face = geo.faces[ i ];
//         if ( face instanceof THREE.Face3 ) 
// 		{
//             var a = geo.vertices[ face.a ].clone();
// 			var b = geo.vertices[ face.b ].clone();
// 			var c = geo.vertices[ face.c ].clone();
//             vertices.push( a,b, b,c, c,a );
//         } 
// 		else if ( face instanceof THREE.Face4 ) 
// 		{
// 			var a = geo.vertices[ face.a ].clone();
// 			var b = geo.vertices[ face.b ].clone();
// 			var c = geo.vertices[ face.c ].clone();
// 			var d = geo.vertices[ face.d ].clone();
//             vertices.push( a,b, b,c, c,d, d,a );
//         }
//     }
//     geometry.computeLineDistances();
//     return geometry;
// }

// function loadBoids1(amount) {
// 	boids = [];
// 	sharks = [];
// 	bgroup = new THREE.Group();
// 	sgroup = new THREE.Group();
// 	loader = new THREE.JSONLoader();
// 	loader2 = new THREE.JSONLoader();
	
// 	loader.load('models/shark.json', function (geometry) {
// 		THREE.GeometryUtils.center(geometry);
// 		sharkGeometry = geometry;
// 		sharkMaterial = new THREE.MeshLambertMaterial({color: 0x4444cc});
		
// 		for(var i = 0; i != sharkCount; i++) {
// 			var posx = Math.random() * 300 - 150;
// 			var posy = Math.random() * 300 - 150;
// 			var posz = Math.random() * 300 - 150;
			
// 			var rotx = 0;
// 			var roty = 0;
// 			var rotz = 0;
			
// 			var pos = new Vector(posx, posy, posz);
// 			var rot = new Vector(rotx, roty, rotz);
// 			var vel = new Vector(Math.random() * 10 - .5,
// 							     Math.random() * 10 - .5,
// 							     Math.random() * 10 - .5);
							     
// 			var boid = new Boid(pos, rot, vel, true);
// 			var	mesh = new THREE.Mesh(sharkGeometry, sharkMaterial);

// 			mesh.position.x = pos.x;
// 			mesh.position.y = pos.y;
// 			mesh.position.z = pos.z;
			
// 			mesh.rotation.x = rot.x;
// 			mesh.rotation.y = rot.y;
// 			mesh.rotation.z = rot.z;

// 			sharks.push(boid);
// 			sgroup.add(mesh);
// 		}
// 		loadBoids2();
// 	});
// }

// function loadBoids2() {
// 	loader2.load('models/vector.json', function (geometry) {
// 		THREE.GeometryUtils.center(geometry);
// 		boidGeometry = geometry;
// 		boidMaterial = new THREE.MeshLambertMaterial({color: 0xcc4444});
		
// 		for(var i = 0; i != boidCount; i++) {
// 			var posx = Math.random() * 300 - 150;
// 			var posy = Math.random() * 300 - 150;
// 			var posz = Math.random() * 300 - 150;
			
// 			var rotx = 0;
// 			var roty = 0;
// 			var rotz = 0;
			
// 			var pos = new Vector(posx, posy, posz);
// 			var rot = new Vector(rotx, roty, rotz);
// 			var vel = new Vector(Math.random() * 10 - .5,
// 							     Math.random() * 10 - .5,
// 							     Math.random() * 10 - .5);
							     

// 			var	boid = new Boid(pos, rot, vel, false);
// 			var	mesh = new THREE.Mesh(geometry, boidMaterial);
			
// 			mesh.position.x = pos.x;
// 			mesh.position.y = pos.y;
// 			mesh.position.z = pos.z;
			
// 			mesh.rotation.x = rot.x;
// 			mesh.rotation.y = rot.y;
// 			mesh.rotation.z = rot.z;

// 			boids.push(boid);
// 			bgroup.add(mesh);
// 		}
// 		goahead = true;
// 		loadBoids3();
// 	});
// }

// function loadBoids3() {
// 	scene.add(sgroup);
// 	scene.add(bgroup);
// }

// function addBoid() {
// 	var mesh = new THREE.Mesh(boidGeometry, boidMaterial);
// 	var posx = Math.random() * 100 - 50;
// 	var posy = Math.random() * 100 - 50;
// 	var posz = Math.random() * 100 - 50;
	
// 	var rotx = 0;
// 	var roty = 0;
// 	var rotz = 0;
	
// 	var pos = new Vector(posx, posy, posz);
// 	var rot = new Vector(rotx, roty, rotz);
// 	var vel = new Vector(Math.random() * 10 - .5,
// 					     Math.random() * 10 - .5,
// 					     Math.random() * 10 - .5);
	
// 	mesh.position.x = pos.x;
// 	mesh.position.y = pos.y;
// 	mesh.position.z = pos.z;
	
// 	mesh.rotation.x = rot.x;
// 	mesh.rotation.y = rot.y;
// 	mesh.rotation.z = rot.z;
	
// 	var boid = new Boid(pos, rot, vel);
	
// 	boids.push(boid);
// 	bgroup.add(mesh);
// }

// function addShark() {
// 	var mesh = new THREE.Mesh(sharkGeometry, sharkMaterial);
// 	var posx = Math.random() * 100 - 50;
// 	var posy = Math.random() * 100 - 50;
// 	var posz = Math.random() * 100 - 50;
	
// 	var rotx = 0;
// 	var roty = 0;
// 	var rotz = 0;
	
// 	var pos = new Vector(posx, posy, posz);
// 	var rot = new Vector(rotx, roty, rotz);
// 	var vel = new Vector(Math.random() * 10 - .5,
// 					     Math.random() * 10 - .5,
// 					     Math.random() * 10 - .5);
	
// 	mesh.position.x = pos.x;
// 	mesh.position.y = pos.y;
// 	mesh.position.z = pos.z;
	
// 	mesh.rotation.x = rot.x;
// 	mesh.rotation.y = rot.y;
// 	mesh.rotation.z = rot.z;
	
// 	var boid = new Boid(pos, rot, vel);
	
// 	sharks.push(boid);
// 	sgroup.add(mesh);
// }

// function removeShark() {
// 	sharks.pop();
// 	sgroup.children.pop();
// }

// function removeBoid() {
// 	boids.pop();
// 	bgroup.children.pop();
// }

// function onWindowResize() {
// 	camera.aspect = window.innerWidth / window.innerHeight;
// 	camera.updateProjectionMatrix();
// 	renderer.setSize(window.innerWidth, window.innerHeight);
// }

// function render() {
// 	var delta = clock.getDelta();
	
// 	renderer.render(scene, camera);
// 	stats.update();

// 	buttonUpdate();

// 	if(goahead) {
// 		boidsUpdate();
		
// 		if(keyboard.pressed("space")) {
// 			var center = new THREE.Vector3(0, 0, 0);
// 			for(var i = 0; i != bgroup.children.length; i++) {
// 				center.add(bgroup.children[i].position);
// 			}
// 			center.divideScalar(bgroup.children.length);
// 			camera.lookAt(center);
// 		    controls.target = center;
// 		}
// 	}
	
// 	if(trackingShark) {
// 		var relativeCameraOffset = new THREE.Vector3(0, -20, 0);
// 		var cameraOffset = relativeCameraOffset.applyMatrix4(sgroup.children[0].matrixWorld);
// 		camera.position.x = cameraOffset.x;
// 		camera.position.y = cameraOffset.y;
// 		camera.position.z = cameraOffset.z;
// 		camera.lookAt(sgroup.children[0].position);
// 	}
	
// 	if(trackingBoid) {
// 		var relativeCameraOffset = new THREE.Vector3(0, -20, 0);
// 		var cameraOffset = relativeCameraOffset.applyMatrix4(bgroup.children[0].matrixWorld);
// 		camera.position.x = cameraOffset.x;
// 		camera.position.y = cameraOffset.y;
// 		camera.position.z = cameraOffset.z;
// 		camera.lookAt(bgroup.children[0].position);
// 	}
	
	
// }

// function buttonUpdate() {
// 	sepFac = (document.querySelector('#SepForce').value) / 100;
// 	if(sepFac == 0) sepFac = 0.01;
// 	document.querySelector('#sfout').value = sepFac;
// 	sharkSepFac = sepFac * 5;
	
// 	cohFac = (document.querySelector('#CohForce').value) / 100;
// 	if(cohFac == 0) cohFac = 0.01;
// 	document.querySelector('#cfout').value = cohFac;
	
// 	aliFac = (document.querySelector('#AliForce').value) / 100;
// 	if(aliFac == 0) aliFac = 0.01;
// 	document.querySelector('#afout').value = aliFac;
	
// 	tarFac = (document.querySelector('#CenForce').value) / 100;
// 	if(tarFac == 0) tarFac = 0.001;
// 	document.querySelector('#tfout').value = tarFac;


	
// 	sepDist = (document.querySelector('#SepDist').value) / 1;
// 	if(sepFac == 0) SepDist = 0.1;
// 	document.querySelector('#sdout').value = sepDist;
// 	sharkSepDist = sepDist * 2;
	
// 	cohDist = (document.querySelector('#CohDist').value) / 1;
// 	if(cohFac == 0) cohDist = 0.1;
// 	document.querySelector('#cdout').value = cohDist;
	
// 	aliDist = (document.querySelector('#AliDist').value) / 1;
// 	if(aliDist== 0) aliDist = 0.1;
// 	document.querySelector('#adout').value = aliDist;
	
	
	
// 	maxSpeed = (document.querySelector('#MaxSpeed').value) / 100;
// 	if(maxSpeed == 0) maxSpeed = 0.01;
// 	sharkMaxSpeed = maxSpeed * 3;
// 	document.querySelector('#speedout').value = maxSpeed;
	
// 	maxForce = (document.querySelector('#Acceleration').value) / 1000;
// 	if(maxForce == 0) maxForce = 0.001;
// 	sharkMaxForce = maxForce * 3;
// 	document.querySelector('#accelout').value = maxForce;
// }

// function boidsUpdate() {	
// 	for(var i = 0; i != boidCount; i++) {
// 		if(i < boids.length) {
// 			boids[i].update(boids, target, sharks);
			
// 			bgroup.children[i].position.x = boids[i].pos.x;
// 			bgroup.children[i].position.y = boids[i].pos.y;
// 			bgroup.children[i].position.z = boids[i].pos.z;
			
// 			bgroup.children[i].rotation.x = boids[i].rot.x;
// 			bgroup.children[i].rotation.y = boids[i].rot.y;
// 			bgroup.children[i].rotation.z = boids[i].rot.z;
// 		}
// 	}
	
	// for(var i = 0; i != sharkCount; i++) {
	// 	if(i < sharks.length) {
	// 		sharks[i].update(boids, target, sharks);
			
	// 		sgroup.children[i].position.x = sharks[i].pos.x;
	// 		sgroup.children[i].position.y = sharks[i].pos.y;
	// 		sgroup.children[i].position.z = sharks[i].pos.z;
			
	// 		sgroup.children[i].rotation.x = sharks[i].rot.x;
	// 		sgroup.children[i].rotation.y = sharks[i].rot.y;
	// 		sgroup.children[i].rotation.z = sharks[i].rot.z;
	// 	}
	// }
//}


		
  </script>
</body>
</html>